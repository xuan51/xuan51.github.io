<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>轩</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sat, 27 Aug 2022 15:43:07 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title></title>
      <link>http://example.com/2022/08/30/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81Android/</link>
      <guid>http://example.com/2022/08/30/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81Android/</guid>
      <pubDate>Tue, 30 Aug 2022 03:07:55 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;第一行代码Android&quot;&gt;&lt;a href=&quot;#第一行代码Android&quot; class=&quot;headerlink&quot; title=&quot;第一行代码Android&quot;&gt;&lt;/a&gt;第一行代码Android&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="第一行代码Android"><a href="#第一行代码Android" class="headerlink" title="第一行代码Android"></a>第一行代码Android</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基于Android7.0系统</p><p>源码下载地址: <a href="https://github.com/guolindev/booksource">https://github.com/guolindev/booksource</a></p><h2 id="第1章-开始启程——你的第一行Android代码"><a href="#第1章-开始启程——你的第一行Android代码" class="headerlink" title="第1章 开始启程——你的第一行Android代码"></a>第1章 开始启程——你的第一行Android代码</h2><h3 id="1-1-了解全貌——Android王国简介"><a href="#1-1-了解全貌——Android王国简介" class="headerlink" title="1.1 了解全貌——Android王国简介"></a>1.1 了解全貌——Android王国简介</h3><h4 id="1-1-1-Android系统架构"><a href="#1-1-1-Android系统架构" class="headerlink" title="1.1.1 Android系统架构"></a>1.1.1 Android系统架构</h4><p>Android大致可以分为四层架构：Linux内核层、系统运行库层、应用框架层和应用层。</p><ul><li>Linux内核层<ul><li>这一层为Android设备的各种硬件提供了底层的驱动</li></ul></li><li>系统运行库层<ul><li>这一层通过一些C&#x2F;C++库来为Android系统提供了主要的特性支持</li><li>同样在这一层还有Android运行时库，它主要提供了一些核心库，能够允许开发者使用Java语言来编写Android应用</li><li>Android运行时库中还包含了Dalvik虚拟机（5.0系统之后改为ART运行环境），它使得每一个Android应用都能运行在独立的进程当中，并且拥有一个自己的Dalvik虚拟机实例。相较于Java虚拟机，Dalvik是专门为移动设备定制的，它针对手机内存、CPU性能有限等情况做了优化处理。</li></ul></li><li>应用框架层<ul><li>这一层主要提供了构建应用程序时可能用到的各种API</li></ul></li><li>应用层<ul><li>所有安装在手机上的应用程序都是属于这一层的所有安装在手机上的应用程序都是属于这一层的</li></ul></li><li><img src="/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81Android.assets/image-20220719100736778.png" alt="image-20220719100736778"></li></ul><h4 id="1-1-2-Android已发布的版本"><a href="#1-1-2-Android已发布的版本" class="headerlink" title="1.1.2 Android已发布的版本"></a>1.1.2 Android已发布的版本</h4><ul><li>2008年9月，谷歌正式发布了Android 1.0系统，这也是Android系统最早的版本</li><li>2.1、2.2、2.3系统的推出使Android占据了大量的市场</li><li>2011年2月，谷歌发布了Android 3.0系统，这个系统版本是专门为平板电脑设计的，但也是Android为数不多的比较失败的版本</li><li>在同年的10月，谷歌又发布了Android 4.0系统，这个版本不再对手机和平板进行差异化区分，既可以应用在手机上，也可以应用在平板上</li><li>2014年Google I&#x2F;O大会上，谷歌推出了号称史上版本改动最大的Android 5.0系统，其中使用ART运行环境替代了Dalvik虚拟机，大大提升了应用的运行速度，还提出了Material Design的概念来优化应用的界面设计。除此之外，还推出了Android Wear、Android Auto、Android TV系统，从而进军可穿戴设备、汽车、电视等全新领域</li><li>2015年Google I&#x2F;O大会上推出了Android 6.0系统，加入运行时权限功能</li><li>2016年Google I&#x2F;O大会上推出了Android 7.0系统，加入多窗口模式功能</li><li>查看最新数据: <a href="http://developer.android.google.cn/about/dashboards/">http://developer.android.google.cn/about/dashboards/</a><ul><li><img src="/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81Android.assets/image-20220719101407705.png" alt="image-20220719101407705"></li></ul></li></ul><h4 id="1-1-3-Android应用开发特色"><a href="#1-1-3-Android应用开发特色" class="headerlink" title="1.1.3 Android应用开发特色"></a>1.1.3 Android应用开发特色</h4><ol><li>四组件<ul><li>活动<ul><li>活动是所有Android应用程序的门面，凡是在应用中你看得到的东西，都是放在活动中的</li></ul></li><li>服务<ul><li>无法看到它，但它会一直在后台默默地运行，即使用户退出了应用，服务仍然是可以继续运行的</li></ul></li><li>广播接收器<ul><li>允许你的应用接收来自各处的广播消息，比如电话、短信等，当然你的应用同样也可以向外发出广播消息</li></ul></li><li>内容提供器<ul><li>为应用程序之间共享数据提供了可能，比如你想要读取系统电话簿中的联系人，就需要通过内容提供器来实现。</li></ul></li></ul></li><li>丰富的系统控件</li><li>SQLite数据库<ul><li>轻量级、运算速度极快的嵌入式关系型数据库</li><li>不仅支持标准的SQL语法，还可以通过Android封装好的API进行操作，让存储和读取数据变得非常方便</li></ul></li><li>强大的多媒体<ul><li>如音乐、视频、录音、拍照、闹铃，等等</li></ul></li><li>地理位置定位<ul><li>现在的Android手机都内置有GPS</li></ul></li></ol><h3 id="1-2-手把手带你搭建开发环境"><a href="#1-2-手把手带你搭建开发环境" class="headerlink" title="1.2 手把手带你搭建开发环境"></a>1.2 手把手带你搭建开发环境</h3><p>&#x3D;&#x3D;工欲善其事，必先利其器&#x3D;&#x3D;</p><h4 id="1-2-1-准备所需要的工具"><a href="#1-2-1-准备所需要的工具" class="headerlink" title="1.2.1 准备所需要的工具"></a>1.2.1 准备所需要的工具</h4><p>开发Android程序需要准备的工具</p><ul><li>JDK</li><li>Android SDK</li><li>Android Studio</li></ul><h4 id="1-2-2-搭建开发环境"><a href="#1-2-2-搭建开发环境" class="headerlink" title="1.2.2 搭建开发环境"></a>1.2.2 搭建开发环境</h4><p>下载地址</p><ul><li><a href="https://developer.android.google.cn/studio/index.html">https://developer.android.google.cn/studio/index.html</a></li><li><a href="https://pan.baidu.com/s/1nuABMDb">https://pan.baidu.com/s/1nuABMDb</a></li></ul><p>注意点</p><ul><li>选择安装组件时建议全部勾上</li><li>一开始会让你选择是否导入之前Android Studio版本的配置(如果这是我们首次安装，这里选择不导入就可以了)</li><li>Android Studio的安装类型，有Standard和Custom两种。Standard表示一切都使用默认的配置，比较方便；Custom则可以根据用户的特殊需求进行自定义。简单起见，这里我们就选择Standard类型了</li></ul><h3 id="1-3-创建你的第一个Android项目"><a href="#1-3-创建你的第一个Android项目" class="headerlink" title="1.3 创建你的第一个Android项目"></a>1.3 创建你的第一个Android项目</h3><h4 id="1-3-1-创建HelloWorld项目"><a href="#1-3-1-创建HelloWorld项目" class="headerlink" title="1.3.1 创建HelloWorld项目"></a>1.3.1 创建HelloWorld项目</h4><ul><li>Application name表示应用名称</li><li>Company Domain表示公司域名</li><li>Package name表示项目的包名，Android系统就是通过包名来区分不同应用程序的，因此包名一定要具有唯一性</li><li>Project location表示项目代码存放的位置，如果没有特殊要求的话，这里也保持默认就可以了</li></ul><p>项目的最低兼容版本设置</p><ul><li>这里我们将Minimum SDK指定成API 15就可以了</li><li>Wear、TV和Android Auto这几个选项分别是用于开发可穿戴设备、电视和汽车程序的</li></ul><p>内置模板</p><ul><li>选择Empty Activity来创建一个空的活动<ul><li>Activity Name表示活动的名字</li><li>Layout Name表示布局的命名</li></ul></li></ul><h4 id="1-3-2-启动模拟器"><a href="#1-3-2-启动模拟器" class="headerlink" title="1.3.2 启动模拟器"></a>1.3.2 启动模拟器</h4><p>Nexus 5X Android7.0</p><h4 id="1-3-3-运行HelloWorld"><a href="#1-3-3-运行HelloWorld" class="headerlink" title="1.3.3 运行HelloWorld"></a>1.3.3 运行HelloWorld</h4><p>在AVD上运行</p><h4 id="1-3-4-分析你的第一个Android程序"><a href="#1-3-4-分析你的第一个Android程序" class="headerlink" title="1.3.4 分析你的第一个Android程序"></a>1.3.4 分析你的第一个Android程序</h4><ol><li>.gradle和.idea<ul><li>放置的都是Android Studio自动生成的一些文件</li></ul></li><li>app<ul><li>项目中的代码、资源等内容几乎都是放置在这个目录下的</li></ul></li><li>build<ul><li>主要包含了一些在编译时自动生成的文件</li></ul></li><li>gradle<ul><li>这个目录下包含了gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，而是会自动根据本地的缓存情况决定是否需要联网下载gradle。Android Studio默认没有启用gradle wrapper的方式，如果需要打开，可以点击Android Studio导航栏→File→Settings→Build,Execution, Deployment→Gradle，进行配置更改。</li></ul></li><li>.gitignore<ul><li>这个文件是用来将指定的目录或文件排除在版本控制之外的</li></ul></li><li>build.gradle<ul><li>这是项目全局的gradle构建脚本，通常这个文件中的内容是不需要修改的。</li></ul></li><li>gradle.properties<ul><li>这个文件是全局的gradle配置文件，在这里配置的属性将会影响到项目中所有的gradle编译脚本。</li></ul></li><li>gradlew和gradlew.bat<ul><li>这两个文件是用来在命令行界面中执行gradle命令的，其中gradlew是在Linux或Mac系统中使用的，gradlew.bat是在Windows系统中使用的。</li></ul></li><li>HelloWorld.iml<ul><li>iml文件是所有IntelliJ IDEA项目都会自动生成的一个文件（Android Studio是基于IntelliJ IDEA开发的），用于标识这是一个IntelliJ IDEA项目，我们不需要修改这个文件中的任何内容。</li></ul></li><li>local.properties<ul><li>这个文件用于指定本机中的Android SDK路径，通常内容都是自动生成的，我们并不需要修改。除非你本机中的Android SDK位置发生了变化，那么就将这个文件中的路径改成新的位置即可。</li></ul></li><li>settings.gradle<ul><li>这个文件用于指定项目中所有引入的模块。由于HelloWorld项目中就只有一个app模块，因此该文件中也就只引入了app这一个模块。通常情况下模块的引入都是自动完成的，需要我们手动去修改这个文件的场景可能比较少。</li></ul></li></ol><p>app目录</p><ol><li>build<ul><li>这个目录和外层的build目录类似，主要也是包含了一些在编译时自动生成的文件，不过它里面的内容会更加更杂，我们不需要过多关心。</li></ul></li><li>lib<ul><li>如果你的项目中使用到了第三方jar包，就需要把这些jar包都放在libs目录下，放在这个目录下的jar包都会被自动添加到构建路径里去。</li></ul></li><li>androidTest<ul><li>此处是用来编写Android Test测试用例的，可以对项目进行一些自动化测试</li></ul></li><li>java<ul><li>java目录是放置我们所有Java代码的地方</li></ul></li><li>res<ul><li>简单点说，就是你在项目中使用到的所有图片、布局、字符串等资源都要存放在这个目录下。当然这个目录下还有很多子目录，图片放在drawable目录下，布局放在layout目录下，字符串放在values目录下，所以你不用担心会把整个res目录弄得乱糟糟的。</li></ul></li><li>AndroidManifest.xml<ul><li>这是你整个Android项目的配置文件，你在程序中定义的所有四大组件都需要在这个文件里注册，另外还可以在这个文件中给应用程序添加权限声明。</li></ul></li><li>test<ul><li>此处是用来编写Unit Test测试用例的，是对项目进行自动化测试的另一种方式。</li></ul></li><li>.gitignore<ul><li>这个文件用于将app模块内的指定的目录或文件排除在版本控制之外，作用和外层的.gitignore文件类似。</li></ul></li><li>app.iml<ul><li>IntelliJ IDEA项目自动生成的文件，我们不需要关心或修改这个文件中的内容。</li></ul></li><li>build.gradle<ul><li>这是app模块的gradle构建脚本，这个文件中会指定很多项目构建相关的配置</li></ul></li><li>proguard-rules.pro<ul><li>这个文件用于指定项目代码的混淆规则，当代码开发完成后打成安装包文件，如果不希望代码被别人破解，通常会将代码进行混淆，从而让破解者难以阅读。</li></ul></li></ol><p>Android-Manifest.xml</p><ul><li>没有在AndroidManifest.xml里注册的活动是不能使用的</li><li>android.intent.action.MAIN决定应用程序最先启动的Activity</li><li>android.intent.category.LAUNCHER决定应用程序是否显示在程序列表里</li><li>注意<ul><li>有MAIN无LAUNCHER则报错</li><li>多个MAIN+LAUNCHER则将会有多个图标显示在桌面上</li></ul></li></ul><p>HelloWorldActivity</p><ul><li>android中所有的活动都要继承于Activity，而AppCompatActivity是Activtiy的子类</li><li>AppCompatActivity是一种向下兼容的Activity，它可以将Activtiy在各个系统版本增加的特性和功能最低兼容到Android2.1系统。</li><li>HelloWorldActivity中有一个onCreate()方法，这个方法是一个活动被创建时必定要执行的方法</li><li>调用了setContentView()方法，就是这个方法给当前的活动引入了一个hello_world_layout布局</li></ul><p>布局文件</p><ul><li>布局文件都是定义在res&#x2F;layout目录下的</li></ul><h4 id="1-3-5-详解项目中的资源"><a href="#1-3-5-详解项目中的资源" class="headerlink" title="1.3.5 详解项目中的资源"></a>1.3.5 详解项目中的资源</h4><p>res目录</p><ul><li>所有以drawable开头的文件夹都是用来放图片的<ul><li>drawable文件夹也是相同的道理，虽然Android Studio没有帮我们自动生成，但是我们应该自己创建drawable-hdpi、drawable-xhdpi、drawable-xxhdpi等文件夹</li></ul></li><li>所有以mipmap开头的文件夹都是用来放应用图标的<ul><li>之所以有这么多mipmap开头的文件夹，其实主要是为了让程序能够更好地兼容各种设备</li></ul></li><li>所有以values开头的文件夹都是用来放字符串、样式、颜色等配置的</li><li>layout文件夹是用来放布局文件的</li><li>当然这只是理想情况，更多的时候美工只会提供给我们一份图片，这时你就把所有图片都放在drawable-xxhdpi文件夹下就好了。</li></ul><p>如何使用这些资源</p><ul><li><string name="app_name">HelloWorld</string><ul><li>在代码中通过R.string.app_name可以获得该字符串的引用。</li><li>在XML中通过@string&#x2F;app_name可以获得该字符串的引用。</li></ul></li><li>如果是引用的图片资源就可以替换成drawable，如果是引用的应用图标就可以替换成mipmap，如果是引用的布局文件就可以替换成layout，以此类推。</li></ul><h4 id="1-3-6-详解build-gradle文件"><a href="#1-3-6-详解build-gradle文件" class="headerlink" title="1.3.6 详解build.gradle文件"></a>1.3.6 详解build.gradle文件</h4><p>build.gradle</p><ul><li>Android Studio是采用Gradle来构建项目的。</li><li>Gradle是一个非常先进的项目构建工具，它使用了一种基于Groovy的领域特定语言（DSL）来声明项目设置，摒弃了传统基于XML（如Ant和Maven）的各种烦琐配置。</li><li>最外层目录下的<ul><li>jcenter()<ul><li>其实它是一个代码托管仓库，很多Android开源项目都会选择将代码托管到jcenter上，声明了这行配置之后，我们就可以在项目中轻松引用任何jcenter上的开源项目了。</li></ul></li><li>使用classpath声明了一个Gradle插件<ul><li>Gradle并不是专门为构建Android项目而开发的，Java、C++等很多种项目都可以使用Gradle来构建。因此如果我们要想使用它来构建Android项目，则需要声明com.android.tools.build:gradle:2.2.0这个插件。其中，最后面的部分是插件的版本号</li></ul></li></ul></li><li>app目录下的<ul><li>第一行应用了一个插件<ul><li>com.android.application表示这是一个应用程序模块</li><li>com.android.library表示这是一个库模块</li><li>应用程序模块和库模块的最大区别在于，一个是可以直接运行的，一个只能作为代码库依附于别的应用程序模块来运行。</li></ul></li><li>android闭包<ul><li>在这个闭包中我们可以配置项目构建的各种属性<ul><li>compileSdkVersion用于指定项目的编译版本</li><li>buildToolsVersion用于指定项目构建工具的版本</li></ul></li><li>嵌套了一个defaultConfig闭包<ul><li>defaultConfig闭包中可以对项目的更多细节进行配置<ul><li>applicationId用于指定项目的包名</li><li>minSdkVersion用于指定项目最低兼容的Android系统版本</li><li>targetSdkVersion指定的值表示你在该目标版本上已经做过了充分的测试，系统将会为你的应用程序启用一些最新的功能和特性</li><li>versionCode用于指定项目的版本号</li><li>versionName用于指定项目的版本名</li></ul></li></ul></li></ul></li><li>buildTypes闭包<ul><li>buildTypes闭包中用于指定生成安装文件的相关配置</li><li>通常只会有两个子闭包，一个是debug，一个是release</li><li>debug闭包用于指定生成测试版安装文件的配置，release闭包用于指定生成正式版安装文件的配置。另外，debug闭包是可以忽略不写的</li><li>release闭包<ul><li>minifyEnabled用于指定是否对项目的代码进行混淆</li><li>proguardFiles用于指定混淆时使用的规则文件，这里指定了两个文件，第一个proguard-android.txt是在Android SDK目录下的，里面是所有项目通用的混淆规则，第二个proguard-rules.pro是在当前项目的根目录下的，里面可以编写当前项目特有的混淆规则</li><li>需要注意的是，通过Android Studio直接运行项目生成的都是测试版安装文件</li></ul></li></ul></li><li>dependencies闭包<ul><li>它可以指定当前项目所有的依赖关系</li><li>通常Android Studio项目一共有3种依赖方式：本地依赖、库依赖和远程依赖</li><li>本地依赖可以对本地的Jar包或目录添加依赖关系</li><li>库依赖可以对项目中的库模块添加依赖关系</li><li>远程依赖则可以对jcenter库上的开源项目添加依赖关系</li></ul></li></ul></li></ul><h3 id="1-4-前行必备——掌握日志工具的使用"><a href="#1-4-前行必备——掌握日志工具的使用" class="headerlink" title="1.4 前行必备——掌握日志工具的使用"></a>1.4 前行必备——掌握日志工具的使用</h3><p>Android日志工具</p><h4 id="1-4-1-使用Android的日志工具Log"><a href="#1-4-1-使用Android的日志工具Log" class="headerlink" title="1.4.1 使用Android的日志工具Log"></a>1.4.1 使用Android的日志工具Log</h4><p>Android中的日志工具类是Log（android.util.Log）</p><ul><li>Log.v()。用于打印那些最为琐碎的、意义最小的日志信息。对应级别verbose</li><li>Log.d()。用于打印一些调试信息，这些信息对你调试程序和分析问题应该是有帮助的。对应级别debug</li><li>Log.i()。用于打印一些比较重要的数据，这些数据应该是你非常想看到的、可以帮你分析用户行为数据。对应级别info</li><li>Log.w()。用于打印一些警告信息，提示程序在这个地方可能会有潜在的风险，最好去修复一下这些出现警告的地方。对应级别warn</li><li>Log.e()。用于打印程序中的错误信息，比如程序进入到了catch语句当中。当有错误信息打印出来的时候，一般都代表你的程序出现严重问题了，必须尽快修复。对应级别error</li><li>参数<ul><li>第一个参数是tag，一般传入当前的类名就好，主要用于对打印信息进行过滤</li><li>第二个参数是msg，即想要打印的具体的内容</li></ul></li><li>点击Android Studio底部工具栏的Android Monitor，在logcat中就可以看到打印信息</li></ul><h4 id="1-4-2-为什么使用Log而不使用System-out"><a href="#1-4-2-为什么使用Log而不使用System-out" class="headerlink" title="1.4.2 为什么使用Log而不使用System.out"></a>1.4.2 为什么使用Log而不使用System.out</h4><p>缺点</p><ul><li>日志打印不可控制、打印时间无法确定、不能添加过滤器、日志没有级别区分……</li></ul><p>快捷输入</p><ul><li>比如你想打印一条debug级别的日志，那么只需要输入logd，然后按下Tab键，就会帮你自动补全一条完整的打印语句</li><li>我们在onCreate()方法的外面输入logt，然后按下Tab键，这时就会以当前的类名作为值自动生成一个TAG常量</li></ul><p>logcat中添加过滤器</p><ul><li>Show only selected application表示只显示当前选中程序的日志</li><li>Firebase是谷歌提供的一个分析工具，我们可以不用管它</li><li>No Filters相当于没有过滤器，会把所有的日志都显示出来</li><li>Edit Filter Configuration自定义过滤器</li></ul><p>logcat日志级别控制</p><ul><li>如果我们将级别选中为debug，这时只有我们使用debug及以上级别方法打印的日志才会显示出来</li></ul><p>关键字过滤</p><ul><li>关键字过滤是支持正则表达式的</li></ul><h3 id="1-5-小结与点评"><a href="#1-5-小结与点评" class="headerlink" title="1.5 小结与点评"></a>1.5 小结与点评</h3><h2 id="第2章-先从看得到的入手——探究活动"><a href="#第2章-先从看得到的入手——探究活动" class="headerlink" title="第2章 先从看得到的入手——探究活动"></a>第2章 先从看得到的入手——探究活动</h2><h3 id="2-1-活动是什么"><a href="#2-1-活动是什么" class="headerlink" title="2.1 活动是什么"></a>2.1 活动是什么</h3><p>活动</p><ul><li>它是一种可以包含用户界面的组件</li><li>主要用于和用户进行交互</li><li>一个应用程序中可以包含零个或多个活动，但不包含任何活动的应用程序很少见</li></ul><h3 id="2-2-活动的基本用法"><a href="#2-2-活动的基本用法" class="headerlink" title="2.2 活动的基本用法"></a>2.2 活动的基本用法</h3><h4 id="2-2-1-手动创建活动"><a href="#2-2-1-手动创建活动" class="headerlink" title="2.2.1 手动创建活动"></a>2.2.1 手动创建活动</h4><p>创建活动</p><ul><li>右击com.xuan.activitytest包→New→Activity→Empty Activity</li><li>Generate Layout File表示会自动为FirstActivity创建一个对应的布局文件</li><li>Launcher Activity表示会自动将FirstActivity设置为当前项目的主活动</li><li>勾选Backwards Compatibility表示会为项目启用向下兼容的模式，这个选项要勾上**(新版貌似没有)**</li></ul><h4 id="2-2-2-创建和加载布局"><a href="#2-2-2-创建和加载布局" class="headerlink" title="2.2.2 创建和加载布局"></a>2.2.2 创建和加载布局</h4><ol><li>右击app&#x2F;src&#x2F;main&#x2F;res目录→New→Directory，会弹出一个新建目录的窗口，这里先创建一个名为layout的目录</li><li>然后对着layout目录右键→New→Layout resource file</li><li>根元素就默认选择为LinearLayout</li><li>添加Button<ul><li>android:id是给当前的元素定义一个唯一标识符</li><li>如果你需要在XML中定义一个id，则要使用@+id&#x2F;id_name这种语法</li><li>match_parent表示让当前元素和父元素一样宽</li><li>wrap_content表示当前元素的高度只要能刚好包含里面的内容就行</li><li>android:text指定了元素中显示的文字内容</li></ul></li><li>在onCreate中设置setContentView<ul><li>项目中添加的任何资源都会在R文件中生成一个相应的资源id</li></ul></li></ol><h4 id="2-2-3-在AndroidManifest文件中注册"><a href="#2-2-3-在AndroidManifest文件中注册" class="headerlink" title="2.2.3 在AndroidManifest文件中注册"></a>2.2.3 在AndroidManifest文件中注册</h4><ul><li>所有的活动都要在AndroidManifest.xml中进行注册才能生效</li><li>而实际上FirstActivity已经在AndroidManifest.xml中注册过了</li><li>android:exported&#x3D;”false”<ul><li>是否支持其它应用调用当前组件。</li><li>默认值：如果包含有intent-filter 默认值为true; 没有intent-filter默认值为false</li></ul></li><li>为程序配置主活动<ul><li><action android:name="android.intent.action.MAIN"/></li><li><category  android:name="android.intent.category.LAUNCHER"/></li></ul></li><li>注意<ul><li>.FirstActivity是com.xuan.activitytest.FirstActivity的缩写。由于在最外层的<manifest>标签中已经通过package属性指定了程序的包名是com.xuan.activitytest，因此在注册活动时这一部分就可以省略了，直接使用.FirstAc-tivity</li><li>可以使用android:label指定活动中标题栏的内容，标题栏是显示在活动最顶部的</li><li>给主活动指定的label不仅会成为标题栏中的内容，还会成为启动器（Launcher）中应用程序显示的名称。</li><li>如果你的应用程序中没有声明任何一个活动作为主活动，这个程序仍然是可以正常安装的，只是你无法在启动器中看到或者打开这个程序。这种程序一般都是作为第三方服务供其他应用在内部进行调用的，如支付宝快捷支付服务</li></ul></li></ul><h4 id="2-2-4-在活动中使用Toast"><a href="#2-2-4-在活动中使用Toast" class="headerlink" title="2.2.4 在活动中使用Toast"></a>2.2.4 在活动中使用Toast</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toast.makeText(FirstActivity.<span class="built_in">this</span>, <span class="string">&quot;You clicked Button 1&quot;</span>, Toast.LENGTH_SHORT).show();</span><br></pre></td></tr></table></figure><p>activity.this和this</p><ul><li>this是我们当前对象的引用，如果都在类FirstActivity中，且不在其内部类或本类内部引用的其他类方法中，this等价于FirstActivity.this</li><li>但是如果在类中的内部类或本类中引用了其他类的方法（或重写）的时候，this指内部类或者其他的类，而不是外部类</li></ul><h4 id="2-2-5-在活动中使用Menu"><a href="#2-2-5-在活动中使用Menu" class="headerlink" title="2.2.5 在活动中使用Menu"></a>2.2.5 在活动中使用Menu</h4><ul><li><p>首先在res目录下新建一个menu文件夹，右击res目录→New→Directory，输入文件夹名menu</p></li><li><p>右击menu文件夹→New→Menu resource file</p></li><li><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item        android:id=&quot;@+id/additem&quot;        android:title=&quot;Add&quot;/&gt;    &lt;item        android:id=&quot;@+id/removeitem&quot;        android:title=&quot;Remove&quot;/&gt;&lt;/menu&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 回到FirstActivity中来重写onCreateOptionsMenu()方法，重写方法可以使用Ctrl+ O快捷键</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  public boolean onCreateOptionsMenu(Menu menu) &#123;</span><br><span class="line">      getMenuInflater().inflate(R.menu.main, menu);</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>- getMenuInflater()方法能够得到MenuInflater对象- 再调用它的inflate()方法就可以给当前活动创建菜单了- 第一个参数用于指定我们通过哪一个资源文件来创建菜单- 第二个参数用于指定我们的菜单项将添加到哪一个Menu对象当中- 这个方法返回true，表示允许创建的菜单显示出来，如果返回了false，创建的菜单将无法显示。</code></pre></li><li><p>定义菜单响应事件。</p><ul><li>在FirstActivity中重写onOptionsItemSelected()方法</li><li>通过调用item.getItemId()来判断我们点击的是哪一个菜单项</li><li>菜单项点击，不仅提供onOptionsItemSelected()的一种触发方式，我们将在后面试验其他的两种方法，如果我们希望将菜单项点击的事件传递下去，继续触发其他处理，则返回false，如果我们认为全部已经处理完，到此为止，不需要将事件传递下去，则返回true。如果采用return super.onOptionsItemSelected(item); 则返回值为flase，即系统缺省返回false。</li></ul></li></ul><h4 id="2-2-6-销毁一个活动"><a href="#2-2-6-销毁一个活动" class="headerlink" title="2.2.6 销毁一个活动"></a>2.2.6 销毁一个活动</h4><ol><li>按一下Back键就可以销毁当前的活动</li><li>Activity类提供了一个finish()方法，我们在活动中调用一下这个方法就可以销毁当前活动</li></ol><h3 id="2-3-使用Intent在活动之间穿梭"><a href="#2-3-使用Intent在活动之间穿梭" class="headerlink" title="2.3 使用Intent在活动之间穿梭"></a>2.3 使用Intent在活动之间穿梭</h3><h4 id="2-3-1-使用显式Intent"><a href="#2-3-1-使用显式Intent" class="headerlink" title="2.3.1 使用显式Intent"></a>2.3.1 使用显式Intent</h4><ol><li>Intent是Android程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据</li><li>Intent一般可被用于启动活动、启动服务以及发送广播等场景</li><li>Intent大致可以分为两种：显式Intent和隐式Intent</li><li>Intent(Context packageContext, Class&lt;? &gt;cls)和startActivity()</li><li>按下Back键就可以销毁当前活动，从而回到上一个活动</li></ol><h4 id="2-3-2-使用隐式Intent"><a href="#2-3-2-使用隐式Intent" class="headerlink" title="2.3.2 使用隐式Intent"></a>2.3.2 使用隐式Intent</h4><ol><li>并不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的action和category等信息，然后交由系统去分析这个Intent，并帮我们找出合适的活动去启动。</li><li>合适的活动: 简单来说就是可以响应我们这个隐式Intent的活动</li><li>通过在<activity>标签下配置<intent-filter>的内容，可以指定当前活动能够响应的action和category</li><li>只有<action>和<category>中的内容同时能够匹配上Intent中指定的action和category时，这个活动才能响应该Intent。</li><li>设置Action,Category和Data<ol><li>intent.setAction(action)</li><li>intent.setData(data)</li><li>intent.addCategory(category)</li></ol></li><li>android.intent.category.DEFAULT是一种默认的category，在调用startActivity()方法的时候会自动将这个category添加到Intent中。</li><li>每个Intent中只能指定一个action，但却能指定多个category。</li></ol><h4 id="2-3-3-更多隐式Intent的用法"><a href="#2-3-3-更多隐式Intent的用法" class="headerlink" title="2.3.3 更多隐式Intent的用法"></a>2.3.3 更多隐式Intent的用法</h4><ol><li>使用隐式Intent，我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，这使得Android多个应用程序之间的功能共享成为了可能</li><li>比如说你的应用程序中需要展示一个网页<ol><li>首先指定了Intent的action是Intent.ACTION_VIEW，这是一个Android系统内置的动作，其常量值为android.intent.action.VIEW</li><li>然后通过Uri.parse()方法，将一个网址字符串解析成一个Uri对象</li><li>再调用Intent的setData()方法将这个Uri对象传递进去。</li><li>setData()接收一个Uri对象，主要用于指定当前Intent正在操作的数据，而这些数据通常都是以字符串的形式传入到Uri.parse()方法中解析产生的。</li><li>可以在<intent-filter>标签中再配置一个<data>标签，用于更精确地指定当前活动能够响应什么类型的数据。<ul><li>android:scheme。用于指定数据的协议部分，如上例中的http部分</li><li>android:host。用于指定数据的主机名部分，如上例中的<a href="http://www.baidu.com部分./">www.baidu.com部分。</a></li><li>android:port。用于指定数据的端口部分，一般紧随在主机名之后。</li><li>android:path。用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容</li><li>android:mimeType。用于指定可以处理的数据类型，允许使用通配符的方式进行指定。</li></ul></li><li>只有<data>标签中指定的内容和Intent中携带的Data完全一致时，当前活动才能够响应该Intent。不过一般在<data>标签中都不会指定过多的内容，如上面浏览器示例中，其实只需要指定android:scheme为http，就可以响应所有的http协议的Intent了。</li></ol></li></ol><p>自定义活动,打开网页</p><ul><li>&#96;&#96;&#96;xml<intent-filter>    <action android:name="android.intent.action.VIEW"/>    <category android:name="android.intent.category.DEFAULT"/>    <!--去掉后虽然爆红却能用,添加后却不能用了,该参数表明这个activity能够被浏览器调用-->    <category android:name="android.intent.category.BROWSABLE"/>    <data android:scheme="http"/></intent-filter><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 除了http协议外，我们还可以指定很多其他协议，比如geo表示显示地理位置、tel表示拨打电话</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  Intent intent1 = new Intent(Intent.ACTION_DIAL);</span><br><span class="line">  intent1.setData(Uri.parse(&quot;tel:15839168273&quot;));</span><br><span class="line">  startActivity(intent1);</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-4-向下一个活动传递数据"><a href="#2-3-4-向下一个活动传递数据" class="headerlink" title="2.3.4 向下一个活动传递数据"></a>2.3.4 向下一个活动传递数据</h4><ul><li><pre><code class="java">String value = &quot;android&quot;;intent2.putExtra(&quot;key&quot;, value);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  Intent intent = getIntent();</span><br><span class="line">  String value = intent.getStringExtra(&quot;key&quot;);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>如果传递的是整型数据，则使用getIntExtra()方法；如果传递的是布尔型数据，则使用getBooleanExtra()方法，以此类推。</p></li></ul><h4 id="2-3-5-返回数据给上一个活动"><a href="#2-3-5-返回数据给上一个活动" class="headerlink" title="2.3.5 返回数据给上一个活动"></a>2.3.5 返回数据给上一个活动</h4><ul><li><p>Activity中还有一个startActivityForResult()方法也是用于启动活动的，但这个方法期望在活动销毁的时候能够返回一个结果给上一个活动。</p></li><li><p>startActivityForResult()方法接收两个参数，第一个参数还是Intent，第二个参数是请求码，用于在之后的回调中判断数据的来源。</p></li><li><pre><code class="java">startActivityForResult(intent, 1);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  Intent intent = new Intent();</span><br><span class="line">  intent.putExtra(&quot;key&quot;, &quot;value&quot;);</span><br><span class="line">  setResult(RESULT_OK, intent);</span><br><span class="line">  finish();</span><br></pre></td></tr></table></figure></code></pre></li><li><p>setResult()这个方法是专门用于向上一个活动返回数据的。setResult()方法接收两个参数，第一个参数用于向上一个活动返回处理结果，一般只使用RESULT_OK或RESULT_CANCELED这两个值，第二个参数则把带有数据的Intent传递回去</p></li><li><p>由于我们是使用startActivityForResult()方法来启动SecondActivity的，在SecondActivity被销毁之后会回调上一个活动的onActivityResult()方法</p></li><li><p>&#96;&#96;&#96;java<br>@Override<br>protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {<br>super.onActivityResult(requestCode, resultCode, data);<br>switch (requestCode) {<br>    case 1:<br>        if (resultCode &#x3D;&#x3D; RESULT_OK) {<br>            String value &#x3D; data.getStringExtra(“key”);<br>        }<br>        break;<br>}<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 如果用户在SecondActivity中并不是通过点击按钮，而是通过按下Back键回到FirstActivity，我们可以通过在SecondActivity中重写onBackPressed()方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.4 活动的生命周期</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.4.1 返回栈</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- Android是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈（Back Stack）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.4.2 活动状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">每个活动在其生命周期中最多可能会有4种状态</span><br><span class="line"></span><br><span class="line">1. 运行状态</span><br><span class="line">   - 位于返回栈的栈顶</span><br><span class="line">2. 暂停状态</span><br><span class="line">   - 动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。并不是每一个活动都会占满整个屏幕。只有在内存极低的情况下，系统才会去考虑回收这种活动。</span><br><span class="line">3. 停止状态</span><br><span class="line">   - 活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可能会被系统回收。</span><br><span class="line">4. 销毁状态</span><br><span class="line">   - 当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证手机的内存充足。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.4.3 活动的生存期</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Activity类中定义了7个回调方法</span><br><span class="line"></span><br><span class="line">1. onCreate()</span><br><span class="line">   - 活动第一次被创建的时候调用。</span><br><span class="line">2. onStart()</span><br><span class="line">   - 活动由不可见变为可见的时候调用。</span><br><span class="line">3. onResume()</span><br><span class="line">   - 这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并且处于运行状态。</span><br><span class="line">   - onResume方法是Activity第一次创建时 重新加载实例时调用 例如 我打开App第一个界面OnCreate完 就调用onResume 然后切换到下一个界面 第一个界面不finish 按Back键回来时 就调onResume,不调onCreate， 还有就是 App用到一半 有事Home键切出去了 在回来时调onResume</span><br><span class="line">4. onPause()</span><br><span class="line">   - 在系统准备去启动或者恢复另一个活动的时候调用。</span><br><span class="line">5. onStop()。</span><br><span class="line">   - 这个方法在活动完全不可见的时候调用。</span><br><span class="line">   - 它和onPause()方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么onPause()方法会得到执行，而onStop()方法并不会执行。</span><br><span class="line">6. onDestroy()。</span><br><span class="line">   - 这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。</span><br><span class="line">7. onDestroy()。</span><br><span class="line">   - 这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">三种生存期</span><br><span class="line"></span><br><span class="line">- **完整生存期**。活动在onCreate()方法和onDestroy()方法之间所经历的，就是完整生存期。</span><br><span class="line">- **完整生存期**。活动在onCreate()方法和onDestroy()方法之间所经历的，就是完整生存期。</span><br><span class="line">- **前台生存期**。活动在onResume()方法和onPause()方法之间所经历的就是前台生存期。</span><br><span class="line">- ![image-20220721152129157](第一行代码Android.assets/image-20220721152129157.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.4.4 体验活动的生命周期</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;!--设置对话框式主题--&gt;</span><br><span class="line">&lt;activity android:theme=&quot;@style/Theme.AppCompat.Dialog&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-4-5-活动被回收了怎么办"><a href="#2-4-5-活动被回收了怎么办" class="headerlink" title="2.4.5 活动被回收了怎么办"></a>2.4.5 活动被回收了怎么办</h4><ul><li><p>用户按下Back键返回活动A，其实还是会正常显示活动A的，只不过这时并不会执行onRestart()方法，而是会执行活动A的onCreate()方法，因为活动A在这种情况下会被重新创建一次。</p></li><li><p>被回收掉的临时数据和状态如何处理</p><ul><li><p>Activity中还提供了一个onSaveInstanceState()回调方法，这个方法可以保证在活动被回收之前一定会被调用，因此我们可以通过这个方法来解决活动被回收时临时数据得不到保存的问题。</p></li><li><p>onSaveInstanceState()方法会携带一个Bundle类型的参数，Bundle提供了一系列的方法用于保存数据，比如可以使用putString()方法保存字符串，使用putInt()方法保存整型数据，以此类推。</p></li><li><p>每个保存方法需要传入两个参数，第一个参数是键，用于后面从Bundle中取值，第二个参数是真正要保存的内容。</p></li><li><p>Intent也可以结合Bundle一起用于传递数据，首先可以把需要传递的数据都保存在Bundle对象中，然后再将Bundle对象存放在Intent里。</p></li><li><p>&#96;&#96;&#96;java<br>@Override<br>protected void onSaveInstanceState(@NonNull Bundle outState) {<br>super.onSaveInstanceState(outState);<br>String data &#x3D; “数据”;<br>outState.putString(“key”, data);<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 通过onCreate(Bundle savedInstanceState)中的savedInstanceState.getString(&quot;key&quot;)获取</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.5 活动的启动模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">启动模式一共有4种，分别是standard、singleTop、singleTask和singleInstance，可以在AndroidManifest.xml中通过给&lt;activity&gt;标签指定android:launchMode属性来选择启动模式。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.5.1 standard</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. standard是活动默认的启动模式</span><br><span class="line">2. 对于使用standard模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.5.2 singleTop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。</span><br><span class="line"></span><br><span class="line">- ```xml</span><br><span class="line">  &lt;activity android:launchMode=&quot;singleTop&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-5-3-singleTask"><a href="#2-5-3-singleTask" class="headerlink" title="2.5.3 singleTask"></a>2.5.3 singleTask</h4><ul><li><p>可以让某个活动在整个应用程序的上下文中只存在一个实例</p></li><li><p>如果已经有实例了，就把该目标Activity实例上面的activity都清除，从而将目标Activity暴露到最上面</p></li><li><p>taskAffinity属性</p><ul><li><p>默认取的是应用的包名</p></li><li><p>taskAffinity是标记当前activity附属到哪个task上</p></li><li><p>配合singleTask使用，意味着被这两个属性标记的activity可以被指定到一个新的task里</p></li><li><p>&#96;&#96;&#96;xml</p><activity android:taskAffinity="com.xuan.test.second"/><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 新建的Task处于下方。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.5.4 singleInstance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 指定为singleInstance模式的活动会启用一个新的返回栈来管理这个活动</span><br><span class="line">- 实现其他程序和我们的程序可以共享这个活动的实例</span><br><span class="line">- getTaskId()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.6 活动的最佳实践</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.6.1 知晓当前是在哪一个活动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//使所有Activity继承该类</span><br><span class="line">public class BaseActivity extends AppCompatActivity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        Log.d(&quot;BaseActivity&quot;, getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-6-2-随时随地退出程序"><a href="#2-6-2-随时随地退出程序" class="headerlink" title="2.6.2 随时随地退出程序"></a>2.6.2 随时随地退出程序</h4><ul><li>&#96;&#96;&#96;java<br>public class ActivityCollector {<br>public static List<Activity> activities &#x3D; new ArrayList&lt;&gt;();<br>public static void add(Activity activity) {<br>    activities.add(activity);<br>}<br>public static void remove(Activity activity) {<br>    activities.remove(activity);<br>}<br>public static void finishAll() {<br>    for (Activity activity : activities) {<br>        if (!activity.isFinishing()) {<br>            activity.finish();<br>        }<br>    }<br>    activities.clear();<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在BaseActivity的onCreate()方法中调用了ActivityCollector的add()方法</span><br><span class="line"></span><br><span class="line">- 在BaseActivity中重写onDestroy()方法，并调用了ActivityCollector的remove()方法</span><br><span class="line"></span><br><span class="line">- 你还可以在销毁所有活动的代码后面再加上杀掉当前进程的代码，以保证程序完全退出</span><br><span class="line"></span><br><span class="line">  - android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class="line">  - 通过myPid()方法来获得当前程序的进程id</span><br><span class="line">  - killProcess()方法只能用于杀掉当前程序的进程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2.6.3 启动活动的最佳写法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class SecondActivity extends BaseActivity &#123;</span><br><span class="line">    public static void actionStart(Context context, String data1, String data2) &#123;</span><br><span class="line">        Intent intent = new Intent(context, SecondActivity.class);</span><br><span class="line">        intent.putExtra(&quot;param1&quot;, data1);</span><br><span class="line">        intent.putExtra(&quot;param2&quot;, data2);</span><br><span class="line">        context.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-7-小结与点评"><a href="#2-7-小结与点评" class="headerlink" title="2.7 小结与点评"></a>2.7 小结与点评</h4><h2 id="第3章-软件也要拼脸蛋——UI开发的点点滴滴"><a href="#第3章-软件也要拼脸蛋——UI开发的点点滴滴" class="headerlink" title="第3章 软件也要拼脸蛋——UI开发的点点滴滴"></a>第3章 软件也要拼脸蛋——UI开发的点点滴滴</h2><h3 id="3-1-如何编写程序界面"><a href="#3-1-如何编写程序界面" class="headerlink" title="3.1 如何编写程序界面"></a>3.1 如何编写程序界面</h3><ol><li>可视化编辑器<ul><li>通过这种方式制作出的界面通常不具有很好的<strong>屏幕适配性</strong></li><li>当需要编写较为复杂的界面时，可视化编辑工具将很难胜任</li></ul></li><li>编写XML代码</li></ol><h3 id="3-2-常用控件的使用方法"><a href="#3-2-常用控件的使用方法" class="headerlink" title="3.2 常用控件的使用方法"></a>3.2 常用控件的使用方法</h3><h4 id="3-2-1-TextView"><a href="#3-2-1-TextView" class="headerlink" title="3.2.1 TextView"></a>3.2.1 TextView</h4><ol><li>使用android:layout_width和android:layout_height指定了控件的宽度和高度。Android中所有的控件都具有这两个属性<ul><li>可选值有3种：match_parent、fill_parent和wrap_content。其中match_parent和fill_parent的意义相同，现在官方更加推荐使用match_parent。</li></ul></li><li>TextView中的文字默认是居左上角对齐的<ul><li>android:gravity&#x3D;”center”</li><li>可选值有top、bottom、left、right、center等，可以用“|”来同时指定多个值</li><li>center效果等同于center_vertical|center_horizontal，表示文字在垂直和水平方向都居中对齐。</li></ul></li><li>textSize</li><li>textColor</li></ol><h4 id="3-2-2-Button"><a href="#3-2-2-Button" class="headerlink" title="3.2.2 Button"></a>3.2.2 Button</h4><ol><li><p>系统会对Button中的所有英文字母自动进行大写转换</p><ul><li>禁用这一默认特性:android:textAllCaps&#x3D;”false”</li></ul></li><li><p>注册监听器</p><ol><li><p>使用匿名类的方式来注册监听器</p></li><li><p>使用实现接口的方式来进行注册</p><ol><li><p>implements View.OnClickListener</p></li><li><p>&#96;&#96;&#96;java<br>button.setOnClickListener(this);<br>@Override<br>public void onClick(View v) {<br>switch (v.getId()) {<br>    case R.id.button:<br>        &#x2F;&#x2F;在此处添加逻辑<br>        break;<br>}<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 3.2.3 EditText</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 它允许用户在控件里输入和编辑内容，并可以在程序中对这些内容进行处理。</span><br><span class="line">2. 提示性文本:android:hint</span><br><span class="line">3. 防止随着输入的内容不断增多，EditText会被不断地拉长</span><br><span class="line">   - 设置**最大**行数:android:maxLines</span><br><span class="line">4. text默认为空</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 3.2.4 ImageView</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. ```xml</span><br><span class="line">   android:src=&quot;@drawable/img1&quot;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>&#96;&#96;&#96;java<br>imageView.setImageResource(R.drawable.img);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 3.2.5 ProgressBar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. Android控件的可见属性。</span><br><span class="line"></span><br><span class="line">   1. 所有的Android控件都具有这个属性，可以通过android:visibility进行指定</span><br><span class="line">   2. 可选值有3种：visible、invisible和gone。</span><br><span class="line">      1. visible表示控件是可见的，这个值是默认值。</span><br><span class="line">      2. invisible表示控件不可见，但是它仍然占据着原来的位置和大小，可以理解成控件变成透明状态了。</span><br><span class="line">      3. gone则表示控件不仅不可见，而且不再占用任何屏幕空间。</span><br><span class="line">   3. 还可以通过代码来设置控件的可见性，使用的是setVisibility()方法，可以传入View.VISIBLE、View.INVISIBLE和View.GONE这3种值。</span><br><span class="line"></span><br><span class="line">2. 还可以给ProgressBar指定不同的样式，通过style属性可以将它指定成水平进度条</span><br><span class="line"></span><br><span class="line">   1. ```xml</span><br><span class="line">      style=&quot;?android:attr/progressBarStyleHorizontal&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>getProgress和setProgress</li></ol></li></ol><h4 id="3-2-6-AlertDialog"><a href="#3-2-6-AlertDialog" class="headerlink" title="3.2.6 AlertDialog"></a>3.2.6 AlertDialog</h4><ol><li><p>对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力</p></li><li><p>通过AlertDialog.Builder创建一个AlertDialog的实例</p></li><li><pre><code class="java">//标题dialog.setTitle(&quot;This is Dialog&quot;);//内容dialog.setMessage(&quot;Something important&quot;);//可否用Back键关闭对话框 默认为truedialog.setCancelable(false);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. setPositiveButton()方法为对话框设置确定按钮的点击事件，调用setNegativeButton()方法设置取消按钮的点击事件</span><br><span class="line"></span><br><span class="line">5. 最后调用show()方法将对话框显示出来</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 3.2.7 ProgressDialog</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. ProgressDialog和AlertDialog有点类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力。</span><br><span class="line"></span><br><span class="line">2. 不同的是，ProgressDialog会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待。</span><br><span class="line"></span><br><span class="line">3. ```java</span><br><span class="line">   //标题</span><br><span class="line">   progressDialog.setTitle(&quot;This is ProgressDialog&quot;);</span><br><span class="line">   //内容</span><br><span class="line">   progressDialog.setMessage(&quot;Loading...&quot;);</span><br><span class="line">   //可否取消</span><br><span class="line">   progressDialog.setCancelable(true);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>最后通过调用show()方法将ProgressDialog显示出来。</p></li><li><p>注意，如果在setCancelable()中传入了false，表示ProgressDialog是不能通过Back键取消掉的，必须要调用ProgressDialog的dismiss()方法来关闭对话框。</p></li></ol><h3 id="3-3-详解4种基本布局"><a href="#3-3-详解4种基本布局" class="headerlink" title="3.3 详解4种基本布局"></a>3.3 详解4种基本布局</h3><ol><li>布局的内部除了放置控件外，也可以放置布局</li></ol><h4 id="3-3-1-线性布局"><a href="#3-3-1-线性布局" class="headerlink" title="3.3.1 线性布局"></a>3.3.1 线性布局</h4><ol><li>LinearLayout又称作线性布局，是一种非常常用的布局。这个布局会将它所包含的控件在线性方向上依次排列。</li><li>通过android:orientation属性指定排列方向<ol><li>vertical</li><li>horizontal(默认值)</li></ol></li><li>如果LinearLayout的排列方向是horizontal，内部的控件就绝对不能将宽度指定为match_parent，如果LinearLayout的排列方向是vertical，内部的控件就不能将高度指定为match_parent。</li><li>android:layout_gravity属性<ol><li>android:gravity用于指定文字在控件中的对齐方式，而android:layout_gravity用于指定控件在布局中的对齐方式。</li><li>android:layout_gravity的可选值和android:gravity差不多</li><li>当LinearLayout的排列方向是horizontal时，只有垂直方向上的对齐方式才会生效，当LinearLayout的排列方向是vertical时，只有水平方向上的对齐方式才会生效。</li></ol></li><li>android:layout_weight<ol><li>这个属性允许我们使用比例的方式来指定控件的大小，它在手机屏幕的适配性方面可以起到非常重要的作用。</li><li>使用了android:layout_weight属性，此时控件的宽度就不应该再由android:layout_width&#x2F;android:layout_height来决定，这里指定成0dp是一种比较规范的写法。</li></ol></li></ol><h4 id="3-3-2-相对布局"><a href="#3-3-2-相对布局" class="headerlink" title="3.3.2 相对布局"></a>3.3.2 相对布局</h4><ol><li>RelativeLayout又称作相对布局，也是一种非常常用的布局。和LinearLayout的排列规则不同，RelativeLayout显得更加随意一些，它可以通过相对定位的方式让控件出现在布局的任何位置。</li><li>android:layout_alignParentLeft、android:layout_alignParentTop、android:layout_alignParentRight、android:layout_alignParentBottom、android:layout_centerInParent</li><li>android:layout_above属性可以让一个控件位于另一个控件的上方，需要为这个属性指定相对控件id的引用</li><li>android:layout_below表示让一个控件位于另一个控件的下方，</li><li>android:layout_toLeftOf表示让一个控件位于另一个控件的左侧，</li><li>android:layout_toRightOf表示让一个控件位于另一个控件的右侧。</li><li>注意，当一个控件去引用另一个控件的id时，该控件<strong>一定要定义在引用控件的后面</strong>，不然会出现找不到id的情况。</li><li>android:layout_alignLeft表示让一个控件的左边缘和另一个控件的左边缘对齐，android:layout_alignRight表示让一个控件的右边缘和另一个控件的右边缘对齐。此外，还有android:layout_alignTop和android:layout_alignBottom</li></ol><h4 id="3-3-3-帧布局"><a href="#3-3-3-帧布局" class="headerlink" title="3.3.3 帧布局"></a>3.3.3 帧布局</h4><ol><li>FrameLayout又称作帧布局，它相比于前面两种布局就简单太多了，因此它的应用场景也少了很多。这种布局没有方便的定位方式，<strong>所有的控件都会默认摆放在布局的左上角</strong>。</li><li>可以使用layout_gravity属性来指定控件在布局中的对齐方式</li><li>总体来讲，FrameLayout由于定位方式的欠缺，导致它的应用场景也比较少</li></ol><h4 id="3-3-4-百分比布局"><a href="#3-3-4-百分比布局" class="headerlink" title="3.3.4 百分比布局"></a>3.3.4 百分比布局</h4><ol><li><p>由于LinearLayout本身已经支持按比例指定控件的大小了，因此百分比布局只为Frame-Layout和RelativeLayout进行了功能扩展，提供了PercentFrameLayout和PercentRelativeLayout这两个全新的布局</p></li><li><p>Android团队将百分比布局定义在了support库当中，我们只需要在项目的build.gradle中添加百分比布局库的依赖，就能保证百分比布局在Android所有系统版本上的兼容性了。打开app&#x2F;build.gradle文件，在dependencies闭包中添加如下内容：</p><ul><li>&#96;&#96;&#96;properties<br>dependencies {<br>implementation ‘com.android.support:percent:28.0.0’<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 由于百分比布局并不是内置在系统SDK当中的，所以需要把完整的包路径写出来。然后还必须定义一个app的命名空间，这样才能使用百分比布局的自定义属性。</span><br><span class="line"></span><br><span class="line">4. ```xml</span><br><span class="line">   &lt;android.support.percent.PercentFrameLayout/&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>android:layout_gravity</p></li><li><p>app:layout_widthPercent和app:layout_heightPercent</p></li><li><p>另外一个PercentRelativeLayout的用法也是非常相似的</p></li><li><p>Android中还有AbsoluteLayout、TableLayout等布局，不过使用得太少了</p></li></ol><h3 id="3-4-系统控件不够用？创建自定义控件"><a href="#3-4-系统控件不够用？创建自定义控件" class="headerlink" title="3.4 系统控件不够用？创建自定义控件"></a>3.4 系统控件不够用？创建自定义控件</h3><ol><li>控件和布局的继承结构<ul><li><img src="/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81Android.assets/image-20220722210638992.png" alt="image-20220722210638992"></li><li>View是Android中最基本的一种UI组件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件</li></ul></li></ol><h4 id="3-4-1-引入布局"><a href="#3-4-1-引入布局" class="headerlink" title="3.4.1 引入布局"></a>3.4.1 引入布局</h4><ol><li><p>android:background用于为布局或控件指定一个背景，可以使用颜色或图片来进行填充</p></li><li><p>android:layout_margin这个属性，它可以指定控件在上下左右方向上偏移的距离，当然也可以使用android:layout_marginLeft或android:layout_marginTop等属性来单独指定控件在某个方向上偏移的距离。</p></li><li><p>&#96;&#96;&#96;xml</p><include layout="@layout/title"/><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 在MainActivity中将系统自带的标题栏隐藏掉</span><br><span class="line"></span><br><span class="line">5. ```java</span><br><span class="line">   ActionBar actionBar = getSupportActionBar();</span><br><span class="line">   if (actionBar != null) &#123;</span><br><span class="line">       actionBar.hide();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-4-2-创建自定义控件"><a href="#3-4-2-创建自定义控件" class="headerlink" title="3.4.2 创建自定义控件"></a>3.4.2 创建自定义控件</h4><ol><li><pre><code class="java">public class TitleLayout extends LinearLayout &#123;    public TitleLayout(Context context, @Nullable AttributeSet attrs) &#123;        super(context, attrs);        LayoutInflater.from(context).inflate(R.layout.title, this);    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 通过LayoutInflater的from()方法可以构建出一个LayoutInflater对象，然后调用inflate()方法就可以动态加载一个布局文件，inflate()方法接收两个参数，第一个参数是要加载的布局文件的id，这里我们传入R.layout.title，第二个参数是给加载好的布局再添加一个父布局，这里我们想要指定为TitleLayout，于是直接传入this。</span><br><span class="line"></span><br><span class="line">3. ```xml</span><br><span class="line">   &lt;com.xuan.uicustomviews.TitleLayout/&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>包名在这里是不可以省略的。</p></li><li><p>尝试为该类的按钮注册点击事件等</p></li></ol><h3 id="3-5-最常用和最难用的控件——ListView"><a href="#3-5-最常用和最难用的控件——ListView" class="headerlink" title="3.5 最常用和最难用的控件——ListView"></a>3.5 最常用和最难用的控件——ListView</h3><ol><li>ListView允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕</li></ol><h4 id="3-5-1-ListView的简单用法"><a href="#3-5-1-ListView的简单用法" class="headerlink" title="3.5.1 ListView的简单用法"></a>3.5.1 ListView的简单用法</h4><ol><li>数组中的数据是无法直接传递给ListView的，我们还需要借助适配器来完成。Android中提供了很多适配器的实现类，其中我认为最好用的就是ArrayAdapter。它可以通过泛型来指定要适配的数据类型，然后在构造函数中把要适配的数据传入。</li><li>在ArrayAdapter的构造函数中依次传入当前上下文、ListView子项布局的id，以及要适配的数据。</li><li>注意，我们使用了android.R.layout.simple_list_item_1作为ListView子项布局的id，这是一个Android内置的布局文件，里面只有一个TextView，可用于简单地显示一段文本。</li><li>最后，还需要调用ListView的setAdapter()方法，将构建好的适配器对象传递进去</li></ol><h4 id="3-5-2-定制ListView的界面"><a href="#3-5-2-定制ListView的界面" class="headerlink" title="3.5.2 定制ListView的界面"></a>3.5.2 定制ListView的界面</h4><ol><li>定义一个实体类，作为ListView适配器的适配类型。</li><li>然后需要为ListView的子项指定一个我们自定义的布局，在layout目录下新建fruit_item.xml</li><li>接下来需要创建一个自定义的适配器，这个适配器继承自ArrayAdapter，并将泛型指定为Fruit类。<ol><li>FruitAdapter重写了父类的一组构造函数，用于将上下文、ListView子项布局的id和数据都传递进来。</li><li>另外又重写了getView()方法，这个方法在每个子项被滚动到屏幕内的时候会被调用。</li><li>在getView()方法中，首先通过getItem()方法得到当前项的Fruit实例，然后使用LayoutInflater来为这个子项加载我们传入的布局。</li><li>这里LayoutInflater的inflate()方法接收3个参数，前两个参数我们已经知道是什么意思了，第三个参数指定成false，表示只让我们在父布局中声明的layout属性生效，但不会为这个View添加父布局，因为一旦View有了父布局之后，它就不能再添加到ListView中了</li><li>接下来调用View的findViewById()方法分别获取到ImageView和TextView的实例，并分别调用它们的setImageResource()和setText()方法来设置显示的图片和文字，最后将布局返回</li></ol></li></ol><h4 id="3-5-3-提升ListView的运行效率"><a href="#3-5-3-提升ListView的运行效率" class="headerlink" title="3.5.3 提升ListView的运行效率"></a>3.5.3 提升ListView的运行效率</h4><ol><li><p>之所以说ListView这个控件很难用，就是因为它有很多细节可以优化，其中运行效率就是很重要的一点。</p></li><li><p>目前我们ListView的运行效率是很低的，因为在FruitAdapter的getView()方法中，每次都将布局重新加载了一遍，当ListView快速滚动的时候，这就会成为性能的瓶颈。</p></li><li><p>getView()方法中还有一个convertView参数，这个参数用于将之前加载好的布局进行缓存</p><ul><li><pre><code class="java">if (convertView == null) &#123;    view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false);&#125;else &#123;    view = convertView;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 每次在getView()方法中还是会调用View的findViewById()方法来获取一次控件的实例。我们可以借助一个ViewHolder来对这部分性能进行优化</span><br><span class="line"></span><br><span class="line">   - 新增一个内部类ViewHolder，用于对控件的实例进行缓存。</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     view.setTag(viewHolder);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>&#96;&#96;&#96;java<br>viewHolder &#x3D; (ViewHolder) view.getTag();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - 这样所有控件的实例都缓存在了ViewHolder里，就没有必要每次都通过findViewById()方法来获取控件实例了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 3.5.4 ListView的点击事件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 使用setOnItemClickListener()方法为ListView注册了一个监听器</span><br><span class="line">2. 当用户点击了ListView中的任何一个子项时，就会回调onItemClick()方法。在这个方法中可以通过position参数判断出用户点击的是哪一个子项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3.6 更强大的滚动控件——RecyclerView</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. ListView并不是完全没有缺点的，比如说如果我们不使用一些技巧来提升它的运行效率，那么ListView的性能就会非常差。</span><br><span class="line">2. ListView的扩展性也不够好，它只能实现数据纵向滚动的效果</span><br><span class="line">3. RecyclerView。它可以说是一个增强版的ListView，不仅可以轻松实现和ListView同样的效果，还优化了ListView中存在的各种不足之处。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 3.6.1 RecyclerView的基本用法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 和百分比布局类似，RecyclerView也属于新增的控件，为了让RecyclerView在所有Android版本上都能使用，Android团队采取了同样的方式，将RecyclerView定义在了support库当中。因此，想要使用RecyclerView这个控件，首先需要在项目的build.gradle中添加相应的依赖库才行。</span><br><span class="line"></span><br><span class="line">2. ```xml</span><br><span class="line">   &lt;!--app/build.gradle--&gt;</span><br><span class="line">   implementation &#x27;androidx.recyclerview:recyclerview:1.0.0&#x27;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>&#96;&#96;&#96;xml<br>&lt;androidx.recyclerview.widget.RecyclerView<br>android:layout_width&#x3D;”match_parent”<br>android:layout_height&#x3D;”match_parent”<br>android:id&#x3D;”@+id&#x2F;recycler_view”&#x2F;&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 首先定义了一个内部类ViewHolder,ViewHolder要继承自RecyclerView.ViewHolder。然后ViewHolder的构造函数中要传入一个View参数，这个参数通常就是RecyclerView子项的最外层布局，那么我们就可以通过findViewById()方法来获取到布局中的ImageView和TextView的实例</span><br><span class="line"></span><br><span class="line">5. FruitAdapter是继承自RecyclerView.Adapter的，那么就必须重写onCreateViewHolder()、onBindViewHolder()和getItemCount()这3个方法。</span><br><span class="line"></span><br><span class="line">   1. onCreate-ViewHolder()方法是用于创建ViewHolder实例的</span><br><span class="line">   2. onBindViewHolder()方法是用于对RecyclerView子项的数据进行赋值的，会在每个子项被滚动到屏幕内的时候执行</span><br><span class="line">   3. getItemCount()方法就非常简单了，它用于告诉RecyclerView一共有多少子项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 3.6.2 实现横向滚动和瀑布流布局</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. MainActivity中调用LinearLayoutManager的setOrientation()方法来设置布局的排列方向，默认是纵向排列的，我们传入LinearLayoutManager.HORIZONTAL表示让布局横行排列</span><br><span class="line">2. ListView的布局排列是由自身去管理的，而RecyclerView则将这个工作交给了LayoutManager</span><br><span class="line">3. 除了LinearLayoutManager之外，RecyclerView还给我们提供了GridLayoutManager和StaggeredGridLayoutManager这两种内置的布局排列方式。GridLayoutManager可以用于实现网格布局，StaggeredGridLayoutManager可以用于实现瀑布流布局。</span><br><span class="line">4. 瀑布流布局</span><br><span class="line">   - 瀑布流布局的宽度应该是根据布局的列数来自动适配的，而不是一个固定值。</span><br><span class="line">   - 创建了一个StaggeredGridLayoutManager的实例。StaggeredGridLayoutManager的构造函数接收两个参数，第一个参数用于指定布局的列数，传入3表示会把布局分为3列；第二个参数用于指定布局的排列方向，传入StaggeredGrid-LayoutManager.VERTICAL表示会让布局纵向排列，最后再把创建好的实例设置到RecyclerView当中就可以了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 3.6.3 RecyclerView的点击事件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. RecyclerView并没有提供类似于setOnItemClickListener()这样的注册监听器方法，而是需要我们自己给子项具体的View去注册点击事件</span><br><span class="line"></span><br><span class="line">2. ListView在点击事件上的处理并不人性化，setOnItemClickListener()方法注册的是子项的点击事件，但如果我想点击的是子项里具体的某一个按钮呢？虽然ListView也是能做到的，但是实现起来就相对比较麻烦了。为此，RecyclerView干脆直接摒弃了子项点击事件的监听器，所有的点击事件都由具体的View去注册，就再没有这个困扰了。</span><br><span class="line"></span><br><span class="line">3. 在ViewHolder中添加了fruitView变量来保存子项最外层布局的实例，然后在onCreateViewHolder()方法中注册点击事件就可以了。</span><br><span class="line"></span><br><span class="line">4. 在两个点击事件中先获取了用户点击的position，然后通过position拿到相应的Fruit实例</span><br><span class="line"></span><br><span class="line">5. ```java</span><br><span class="line">   int position = holder.getAdapterPosition();</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-7-编写界面的最佳实践"><a href="#3-7-编写界面的最佳实践" class="headerlink" title="3.7 编写界面的最佳实践"></a>3.7 编写界面的最佳实践</h3><h4 id="3-7-1-制作Nine-Patch图片"><a href="#3-7-1-制作Nine-Patch图片" class="headerlink" title="3.7.1 制作Nine-Patch图片"></a>3.7.1 制作Nine-Patch图片</h4><ol><li>在Android sdk目录下有一个tools文件夹，在这个文件夹中找到draw9patch.bat文件，我们就是使用它来制作Nine-Patch图片的。<ul><li>必须先将JDK的bin目录配置到环境变量当中才行</li></ul></li><li>在上边框和左边框绘制的部分表示当图片需要拉伸时就拉伸黑点标记的区域，在下边框和右边框绘制的部分表示内容会被放置的区域。<ul><li>使用鼠标在图片的边缘拖动就可以进行绘制了，按住Shift键拖动可以进行擦除。</li><li>.9.png</li></ul></li><li>当图片需要拉伸的时候，就可以只拉伸指定的区域</li></ol><h4 id="3-7-2-编写精美的聊天界面"><a href="#3-7-2-编写精美的聊天界面" class="headerlink" title="3.7.2 编写精美的聊天界面"></a>3.7.2 编写精美的聊天界面</h4><ol><li>调用了适配器的notifyItemInserted()方法，用于通知列表有新的数据插入，这样新增的一条消息才能够在RecyclerView中显示。参数为size() - 1</li><li>调用RecyclerView的scrollToPosition()方法将显示的数据定位到最后一行</li></ol><h3 id="3-8-小结与点评"><a href="#3-8-小结与点评" class="headerlink" title="3.8 小结与点评"></a>3.8 小结与点评</h3><ol><li>能够同时兼容手机和平板也是自Android 4.0系统开始就支持的特性。</li></ol><h2 id="第4章-手机平板要兼顾——探究碎片"><a href="#第4章-手机平板要兼顾——探究碎片" class="headerlink" title="第4章 手机平板要兼顾——探究碎片"></a>第4章 手机平板要兼顾——探究碎片</h2><ol><li>Android自3.0版本开始引入了碎片的概念，它可以让界面在平板上更好地展示</li><li>Android自3.0版本开始引入了碎片的概念，它可以让界面在平板上更好地展示</li></ol><h3 id="4-1-碎片是什么"><a href="#4-1-碎片是什么" class="headerlink" title="4.1 碎片是什么"></a>4.1 碎片是什么</h3><ol><li>碎片（Fragment）是一种<strong>可以嵌入在活动当中的UI片段</strong>，它能让程序更加合理和充分地利用大屏幕的空间，因而在平板上应用得非常广泛。</li><li>它和活动很像，同样都能包含布局，同样都有自己的生命周期。你甚至可以将碎片理解成一个迷你型的活动，虽然这个迷你型的活动有可能和普通的活动是一样大的。</li></ol><h3 id="4-2-碎片的使用方式"><a href="#4-2-碎片的使用方式" class="headerlink" title="4.2 碎片的使用方式"></a>4.2 碎片的使用方式</h3><ol><li>碎片通常都是在平板开发中使用的</li><li>创建一个平板模拟器</li></ol><h4 id="4-2-1-碎片的简单用法"><a href="#4-2-1-碎片的简单用法" class="headerlink" title="4.2.1 碎片的简单用法"></a>4.2.1 碎片的简单用法</h4><ol><li>这里可能会有两个不同包下的Fragment供你选择，一个是系统内置的android.app.Fragment，一个是support-v4库中的android.support.v4.app.Fragment。这里我强烈建议你使用support-v4库中的Fragment，因为它可以让碎片在所有Android系统版本中保持功能一致性。</li><li>比如说在Fragment中嵌套使用Fragment，这个功能是在Android 4.2系统中才开始支持的，如果你使用的是系统内置的Fragment，那么很遗憾，4.2系统之前的设备运行你的程序就会崩溃。而使用support-v4库中的Fragment就不会出现这个问题，只要你保证使用的是最新的support-v4库就可以了。</li><li>另外，我们并不需要在build.gradle文件中添加support-v4库的依赖，因为build.gradle文件中已经添加了appcompat-v7库的依赖，而这个库会将support-v4库也一起引入进来。</li><li>通过LayoutInflater的inflate()方法将刚才定义的left_fragment布局动态加载进来</li><li>使用<fragment>标签在布局中添加碎片，通过android:name属性来显式指明要添加的碎片类名，注意一定要将类的包名也加上。</li></ol><h4 id="4-2-2-动态添加碎片"><a href="#4-2-2-动态添加碎片" class="headerlink" title="4.2.2 动态添加碎片"></a>4.2.2 动态添加碎片</h4><ol><li>碎片真正的强大之处在于，它可以在程序运行时动态地添加到活动当中。</li><li>动态添加碎片。<ol><li>创建待添加的碎片实例。</li><li>获取FragmentManager，在活动中可以直接通过调用getSupportFragmentManager()方法得到。</li><li>开启一个事务，通过调用beginTransaction()方法开启。</li><li>向容器内添加或替换碎片，一般使用replace()方法实现，需要传入容器的id和待添加的碎片实例。</li><li>提交事务，调用commit()方法来完成。</li></ol></li></ol><h4 id="4-2-3-在碎片中模拟返回栈"><a href="#4-2-3-在碎片中模拟返回栈" class="headerlink" title="4.2.3 在碎片中模拟返回栈"></a>4.2.3 在碎片中模拟返回栈</h4><ol><li>FragmentTransaction中提供了一个addToBackStack()方法，可以用于将一个事务添加到返回栈中</li><li>在事务提交之前调用了FragmentTransaction的addToBackStack()方法，它可以接收一个名字用于描述返回栈的状态，一般传入null即可。</li></ol><h4 id="4-2-4-碎片和活动之间进行通信"><a href="#4-2-4-碎片和活动之间进行通信" class="headerlink" title="4.2.4 碎片和活动之间进行通信"></a>4.2.4 碎片和活动之间进行通信</h4><ol><li>为了方便碎片和活动之间进行通信，FragmentManager提供了一个类似于findViewById()的方法，专门用于从布局文件中获取碎片的实例</li><li>调用FragmentManager的findFragmentById()方法，可以在活动中得到相应碎片的实例，然后就能轻松地调用碎片里的方法了。</li><li>在碎片中又该怎样调用活动里的方法呢？<ol><li>在每个碎片中都可以通过调用getActivity()方法来得到和当前碎片相关联的活动实例</li><li>当碎片中需要使用Context对象时，也可以使用getActivity()方法，因为获取到的活动本身就是一个Context对象。</li></ol></li><li>碎片和碎片之间可不可以进行通信呢？<ol><li>在一个碎片中可以得到与它相关联的活动，然后再通过这个活动去获取另外一个碎片的实例，这样也就实现了不同碎片之间的通信功能</li></ol></li></ol><h3 id="4-3-碎片的生命周期"><a href="#4-3-碎片的生命周期" class="headerlink" title="4.3 碎片的生命周期"></a>4.3 碎片的生命周期</h3><ol><li>一共有运行状态、暂停状态、停止状态和销毁状态这4种。</li></ol><h4 id="4-3-1-碎片的状态和回调"><a href="#4-3-1-碎片的状态和回调" class="headerlink" title="4.3.1 碎片的状态和回调"></a>4.3.1 碎片的状态和回调</h4><ol><li>运行状态<ul><li>当一个碎片是可见的，并且它所关联的活动正处于运行状态时，该碎片也处于运行状态。</li></ul></li><li>暂停状态<ul><li>当一个活动进入暂停状态时（由于另一个未占满屏幕的活动被添加到了栈顶），与它相关联的可见碎片就会进入到暂停状态。</li></ul></li><li>停止状态<ul><li>当一个活动进入停止状态时，与它相关联的碎片就会进入到停止状态，或者通过调用FragmentTransaction的remove()、replace()方法将碎片从活动中移除，但如果在事务提交之前调用addToBackStack()方法，这时的碎片也会进入到停止状态。总的来说，进入停止状态的碎片对用户来说是完全不可见的，有可能会被系统回收。</li></ul></li><li>销毁状态<ul><li>碎片总是依附于活动而存在的，因此当活动被销毁时，与它相关联的碎片就会进入到销毁状态。或者通过调用FragmentTransaction的remove()、replace()方法将碎片从活动中移除，但在事务提交之前并没有调用addToBackStack()方法，这时的碎片也会进入到销毁状态。</li></ul></li><li>附加的回调方法<ol><li>onAttach()。当碎片和活动建立关联的时候调用。</li><li>onCreateView()。为碎片创建视图（加载布局）时调用。</li><li>onActivityCreated()。确保与碎片相关联的活动一定已经创建完毕的时候调用。</li><li>onDestroyView()。当与碎片关联的视图被移除的时候调用。</li><li>onDetach()。当碎片和活动解除关联的时候调用。</li></ol></li><li><img src="/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81Android.assets/image-20220724211849473.png" alt="image-20220724211849473"></li></ol><h4 id="4-3-2-体验碎片的生命周期"><a href="#4-3-2-体验碎片的生命周期" class="headerlink" title="4.3.2 体验碎片的生命周期"></a>4.3.2 体验碎片的生命周期</h4><ol><li>在碎片中你也是可以通过onSaveInstanceState()方法来保存数据的，因为进入停止状态的碎片有可能在系统内存不足的时候被回收。保存下来的数据在onCreate()、onCreateView()和onActivityCreated()这3个方法中你都可以重新得到，它们都含有一个Bundle类型的savedInstanceState参数。</li></ol><h3 id="4-4-动态加载布局的技巧"><a href="#4-4-动态加载布局的技巧" class="headerlink" title="4.4 动态加载布局的技巧"></a>4.4 动态加载布局的技巧</h3><h4 id="4-4-1-使用限定符"><a href="#4-4-1-使用限定符" class="headerlink" title="4.4.1 使用限定符"></a>4.4.1 使用限定符</h4><ol><li>很多的平板应用都采用的是双页模式（程序会在左侧的面板上显示一个包含子项的列表，在右侧的面板上显示内容）</li><li>怎样才能在运行时判断程序应该是使用双页模式还是单页模式呢？这就需要借助限定符（Qualifiers）来实现</li><li>layout&#x2F;activity_main布局只包含了一个碎片，即单页模式，而layout-large&#x2F;activity_main布局包含了两个碎片，即双页模式。<strong>其中large就是一个限定符</strong>，那些屏幕被认为是large的设备就会自动加载layout-large文件夹下的布局，而小屏幕的设备则还是会加载layout文件夹下的布局。</li><li>Android中一些常见的限定符<ul><li><img src="/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81Android.assets/image-20220724225316495.png" alt="image-20220724225316495"></li></ul></li></ol><h4 id="4-4-2-使用最小宽度限定符"><a href="#4-4-2-使用最小宽度限定符" class="headerlink" title="4.4.2 使用最小宽度限定符"></a>4.4.2 使用最小宽度限定符</h4><ol><li>large到底是指多大呢？有的时候我们希望可以更加灵活地为不同设备加载布局，不管它们是不是被系统认定为large，这时就可以使用最小宽度限定符（Smallest-width Qualifier）了。</li><li>最小宽度限定符允许我们对屏幕的宽度指定一个最小值（以dp为单位），然后以这个最小值为临界点，屏幕宽度大于这个值的设备就加载一个布局，屏幕宽度小于这个值的设备就加载另一个布局。</li><li>在res目录下新建layout-sw600dp文件夹<ul><li>这就意味着，当程序运行在屏幕宽度大于等于600dp的设备上时，会加载layout-sw600dp&#x2F;activity_main布局，当程序运行在屏幕宽度小于600dp的设备上时，则仍然加载默认的layout&#x2F;activity_main布局。</li></ul></li></ol><h3 id="4-5-碎片的最佳实践——一个简易版的新闻应用"><a href="#4-5-碎片的最佳实践——一个简易版的新闻应用" class="headerlink" title="4.5 碎片的最佳实践——一个简易版的新闻应用"></a>4.5 碎片的最佳实践——一个简易版的新闻应用</h3><ol><li>TextView属性<ol><li>android:padding表示给控件的周围加上补白，这样不至于让文本内容会紧靠在边缘上。</li><li>android:maxLines设置为1表示让这个TextView只能单行显示。</li><li>android:ellipsize用于设定当文本内容超出控件宽度时，文本的缩略方式，这里指定成end表示在尾部进行缩略。</li></ol></li><li>之前我们都是将适配器写成一个独立的类，其实也是可以写成内部类的</li></ol><h3 id="4-6-小结与点评"><a href="#4-6-小结与点评" class="headerlink" title="4.6 小结与点评"></a>4.6 小结与点评</h3><ol><li>比起只需要兼容一个终端的应用，我们要考虑的东西多了很多。不过在开发的过程中多付出一些，在以后的代码维护中就可以轻松很多。因此，有时候提前的付出还是很值得的。</li><li>本章其实是具有一个里程碑式的纪念意义的，因为到这里为止，我们已经基本将Android UI相关的重要知识点都讲完了。</li></ol><h2 id="第5章-全局大喇叭——详解广播机制"><a href="#第5章-全局大喇叭——详解广播机制" class="headerlink" title="第5章 全局大喇叭——详解广播机制"></a>第5章 全局大喇叭——详解广播机制</h2><ol><li>如果你了解网络通信原理应该会知道，在一个IP网络范围中，最大的IP地址是被保留作为广播地址来使用的。</li><li>广播数据包会被发送到同一网络上的所有端口，这样在该网络中的每台主机都将会收到这条广播。</li><li>为了便于进行系统级别的消息通知，Android也引入了一套类似的广播消息机制。</li></ol><h3 id="5-1-广播机制简介"><a href="#5-1-广播机制简介" class="headerlink" title="5.1 广播机制简介"></a>5.1 广播机制简介</h3><ol><li>Android中的广播机制更加灵活，因为Android中的每个应用程序都可以对自己感兴趣的广播进行注册，这样该程序就只会接收到自己所关心的广播内容，这些广播可能是来自于系统的，也可能是来自于其他应用程序的。</li><li>允许应用程序自由地发送和接收广播。</li><li>Android中的广播主要可以分为两种类型：标准广播和有序广播。<ol><li>标准广播（Normal broadcasts）是一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接收到这条广播消息，因此它们之间没有任何先后顺序可言。这种广播的效率会比较高，但同时也意味着它是无法被截断的。</li><li><img src="/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81Android.assets/image-20220725231139832.png" alt="image-20220725231139832"></li><li>有序广播（Ordered broadcasts）则是一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。优先级高的广播接收器就可以先收到广播消息，并且前面的广播接收器还可以截断正在传递的广播，这样后面的广播接收器就无法收到广播消息了。</li><li><img src="/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81Android.assets/image-20220725231255264.png" alt="image-20220725231255264"></li></ol></li></ol><h3 id="5-2-接收系统广播"><a href="#5-2-接收系统广播" class="headerlink" title="5.2 接收系统广播"></a>5.2 接收系统广播</h3><ol><li>Android内置了很多系统级别的广播，我们可以在应用程序中通过监听这些广播来得到各种系统的状态信息。<ol><li>比如手机开机完成后会发出一条广播，电池的电量发生变化会发出一条广播，时间或时区发生改变也会发出一条广播，等等。</li></ol></li><li>如果想要接收到这些广播，就需要使用广播接收器</li></ol><h4 id="5-2-1-动态注册监听网络变化"><a href="#5-2-1-动态注册监听网络变化" class="headerlink" title="5.2.1 动态注册监听网络变化"></a>5.2.1 动态注册监听网络变化</h4><ol><li><p>广播接收器可以自由地对自己感兴趣的广播进行注册，这样当有相应的广播发出时，广播接收器就能够收到该广播，并在内部处理相应的逻辑。</p></li><li><p>注册广播的方式一般有两种，在代码中注册和在AndroidManifest.xml中注册，其中前者也被称为动态注册，后者也被称为静态注册。</p></li><li><p>如何创建一个广播接收器呢？其实只需要新建一个类，让它继承自Broadcast-Receiver，并重写父类的onReceive()方法就行了。这样当有广播到来时，onReceive()方法就会得到执行</p></li><li><p>创建了一个IntentFilter的实例，并给它添加了一个值为android.net.conn.CONNECTIVITY_CHANGE的action，为当网络状态发生变化时，系统发出的正是一条值为android.net.conn.CONNECTIVITY_CHANGE的广播，我们的广播接收器想要监听什么广播，就在这里添加相应的action。</p></li><li><p>调用registerReceiver()方法进行注册，将NetworkChangeReceiver的实例和IntentFilter的实例都传进去</p></li><li><p>动态注册的广播接收器一定都要取消注册才行，这里我们是在onDestroy()方法中通过调用unregisterReceiver()方法来实现的。</p></li><li><p>判断网络连接状态</p><ol><li><p>通过getSystemService()方法得到了ConnectivityManager的实例，这是一个系统服务类，专门用于管理网络连接的。</p></li><li><p>调用它的getActiveNetwork-Info()方法可以得到NetworkInfo的实例，接着调用NetworkInfo的isAvailable()方法，就可以判断出当前是否有网络了，</p></li><li><p>&#96;&#96;&#96;java<br>ConnectivityManager connectivityManager &#x3D; (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);<br>NetworkInfo networkInfo &#x3D; connectivityManager.getActiveNetworkInfo();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">8. 非常重要的一点需要说明，Android系统为了保护用户设备的安全和隐私，做了严格的规定：如果程序需要进行一些对用户来说比较敏感的操作，就必须在配置文件中声明权限才可以，否则程序将会直接崩溃。比如这里访问系统的网络状态就是需要声明权限的。</span><br><span class="line"></span><br><span class="line">   1. ```xml</span><br><span class="line">      &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="5-2-2-静态注册实现开机启动"><a href="#5-2-2-静态注册实现开机启动" class="headerlink" title="5.2.2 静态注册实现开机启动"></a>5.2.2 静态注册实现开机启动</h4><ol><li>动态注册的广播接收器可以自由地控制注册与注销，在灵活性方面有很大的优势，但是它也存在着一个缺点，即必须要在程序启动之后才能接收到广播，因为注册的逻辑是写在onCreate()方法中的。</li><li>静态注册的方式可以让程序在未启动的情况下就能接收到广播</li><li>可以使用Android Studio提供的快捷方式来创建一个广播接收器，右击com.example.broadcasttest包→New→Other→Broadcast Receiver<ul><li>Exported属性表示是否允许这个广播接收器接收本程序以外的广播，Enabled属性表示是否启用这个广播接收器。</li></ul></li><li>静态的广播接收器一定要在AndroidManifest.xml文件中注册才可以使用，不过由于我们是使用Android Studio的快捷方式创建的广播接收器，因此注册这一步已经被自动完成了。<receiver></li><li>在<intent-filter>标签里添加了相应的action。<ol><li>Android系统启动完成后会发出一条值为android.intent.action.BOOT_COMPLETED的广播</li><li>监听系统开机广播也是需要声明权限的，可以看到，我们使用<uses-permission>标签又加入了一条android.permission.RECEIVE_BOOT_COMPLETED权限。</li></ol></li><li>不要在onReceive()方法中添加过多的逻辑或者进行任何的耗时操作，因为在广播接收器中是不允许开启线程的，当onReceive()方法运行了较长时间而没有结束时，程序就会报错。<ul><li>广播接收器更多的是扮演一种打开程序其他组件的角色，比如创建一条状态栏通知，或者启动一个服务等</li></ul></li></ol><h3 id="5-3-发送自定义广播"><a href="#5-3-发送自定义广播" class="headerlink" title="5.3 发送自定义广播"></a>5.3 发送自定义广播</h3><h4 id="5-3-1-发送标准广播"><a href="#5-3-1-发送标准广播" class="headerlink" title="5.3.1 发送标准广播"></a>5.3.1 发送标准广播</h4><ol><li><pre><code class="java">Intent intent = new Intent(&quot;com.xuan.broadcasttext.MY_BROADCAST&quot;);intent.setComponent(new ComponentName(&quot;com.xuan.broadcasttest&quot;,&quot;com.xuan.broadcasttest.MyBroadcastReceiver&quot;));sendBroadcast(intent);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - 第二行在Android 7.0及以下版本不是必须的，但是Android 8.0或者更高版本，发送广播的条件更加严苛，必须添加这一行内容。创建的ComponentName实例化对象有两个参数，第1个参数是指接收广播类的包名，第2个参数是指接收广播类的完整类名。</span><br><span class="line"></span><br><span class="line">2. 由于广播是使用Intent进行传递的，因此你还可以在Intent中携带一些数据传递给广播接收器。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 5.3.2 发送有序广播</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 发送有序广播只需要改动一行代码，即将sendBroadcast()方法改成send-OrderedBroadcast()方法。</span><br><span class="line"></span><br><span class="line">   1. sendOrderedBroadcast()方法接收两个参数，第一个参数仍然是Intent，第二个参数是一个与权限相关的字符串，这里传入null就行了。</span><br><span class="line"></span><br><span class="line">   2. ```java</span><br><span class="line">      sendOrderedBroadcast(intent, null);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>设定广播接收器的先后顺序</p><ol><li><p>通过android:priority属性给广播接收器设置优先级，优先级比较高的广播接收器就可以先收到广播。</p></li><li><p>&#96;&#96;&#96;xml<br><intent-filter android:priority="100"></intent-filter></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 总体来说：对于接收同一个广播，在相同优先级的情况下，动态注册优先级别高于静态注册。在动态注册中，最早动态注册优先级别最高；在静态注册中，最早安装的程序，静态注册优先级别最高（安装APK会解析manifest.xml,把其加入队列）。</span><br><span class="line"></span><br><span class="line">4. 接收无序广播的接收器接收到广播的顺序是有序的，接收无序广播的接收器也一样可以设置优先级的。</span><br><span class="line"></span><br><span class="line">5. 如果在onReceive()方法中调用了**abortBroadcast()**方法，就表示将这条广播截断，后面的广播接收器将无法再接收到这条广播。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.4 使用本地广播</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 为了能够简单地解决广播的安全性问题，Android引入了一套本地广播机制，使用这个机制发出的广播只能够在应用程序的内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播</span><br><span class="line">2. 本地广播的用法并不复杂，主要就是使用了一个LocalBroadcastManager来对广播进行管理，并提供了发送广播和注册广播接收器的方法。</span><br><span class="line">   - 基本上就和动态注册广播接收器以及发送广播的代码是一样的。</span><br><span class="line">   - 首先是通过LocalBroadcastManager的getInstance()方法得到了它的一个实例</span><br><span class="line">   - 注册广播接收器的时候调用的是LocalBroadcastManager的registerReceiver()方法，在发送广播的时候调用的是LocalBroadcastManager的sendBroadcast()方法</span><br><span class="line">3. 本地广播是无法通过静态注册的方式来接收的。</span><br><span class="line">   - 因为静态注册主要就是为了让程序在未启动的情况下也能收到广播，而发送本地广播时，我们的程序肯定是已经启动了，因此也完全不需要使用静态注册的功能。</span><br><span class="line">4. 使用本地广播的几点优势</span><br><span class="line">   1. 正在发送的广播不会离开我们的程序，因此不必担心机密数据泄漏。</span><br><span class="line">   2. 其他的程序无法将广播发送到我们程序的内部，因此不需要担心会有安全漏洞的隐患。</span><br><span class="line">   3. 发送本地广播比发送系统全局广播将会更加高效。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.5 广播的最佳实践——实现强制下线功能</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 由于广播接收器里面需要弹出一个对话框来阻塞用户的正常操作，但如果创建的是一个静态注册的广播接收器，是没有办法在onReceive()方法里弹出对话框这样的UI控件的，而我们显然也不可能在每个活动中都去注册一个动态的广播接收器。</span><br><span class="line">   - 只需要在BaseActivity中动态注册一个广播接收器就可以了，因为所有的活动都是继承自BaseActivity的。</span><br><span class="line">2. 重写了onResume()和onPause()这两个生命周期函数，然后分别在这两个方法里注册和取消注册了ForceOfflineReceiver。</span><br><span class="line">   - 我们始终需要保证只有处于栈顶的活动才能接收到这条强制下线广播，非栈顶的活动不应该也没有必要去接收这条广播，所以写在onResume()和onPause()方法里就可以很好地解决这个问题，当一个活动失去栈顶位置时就会自动取消广播接收器的注册。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.6 Git时间——初识版本控制工具</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 常见的版本控制工具主要有svn和Git</span><br><span class="line">2. Git是一个开源的分布式版本控制工具，它的开发者就是鼎鼎大名的Linux操作系统的作者Linus Torvalds。</span><br><span class="line">3. Git被开发出来的初衷是为了更好地管理Linux内核，而现在却早已被广泛应用于全球各种大中小型的项目中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 5.6.1 安装Git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. Git在Linux上的安装是最简单方便的。比如你使用的是Ubuntu系统，只需要打开shell界面，并输入：</span><br><span class="line"></span><br><span class="line">   - ```shell</span><br><span class="line">     sudo apt-get install git-core</span><br></pre></td></tr></table></figure></li></ol><ul><li>按下回车后输入密码，即可完成Git的安装。</li></ul></li><li><p>Windows上安装Git</p><ol><li>先把Git的安装包下载下来。访问网址<a href="https://git-for-windows.github.io/">https://git-for-windows.github.io/</a></li></ol></li></ol><h4 id="5-6-2-创建代码仓库"><a href="#5-6-2-创建代码仓库" class="headerlink" title="5.6.2 创建代码仓库"></a>5.6.2 创建代码仓库</h4><ol><li><p>通过命令来使用Git</p><ol><li><p>Linux系统，就先打开shell界面，Windows系统，就从开始里找到GitBash并打开。</p></li><li><p>首先应该配置一下你的身份，这样在提交代码的时候Git就可以知道是谁提交的了</p><ul><li>&#96;&#96;&#96;shell<br>git config –global user.name “xuan”<br>git config –global user.email “<a href="mailto:&#120;&#117;&#x61;&#x6e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;">&#120;&#117;&#x61;&#x6e;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#x6f;&#x6d;</a>“<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - 配置完成后你还可以使用同样的命令来查看是否配置成功，只需要将最后的名字和邮箱地址去掉即可</span><br><span class="line"></span><br><span class="line">3. 创建代码仓库</span><br><span class="line"></span><br><span class="line">   1. 仓库（Repository）是用于保存版本管理所需信息的地方，所有本地提交的代码都会被提交到代码仓库中，如果有需要还可以再推送到远程仓库中。</span><br><span class="line"></span><br><span class="line">   2. 给BroadcastBestPractice项目建立一个代码仓库。</span><br><span class="line"></span><br><span class="line">      1. 先进入到BroadcastBest-Practice项目的目录下面</span><br><span class="line"></span><br><span class="line">      2. ```shell</span><br><span class="line">         cd c:/users/DELL/Desktop/...</span><br></pre></td></tr></table></figure><ol start="3"><li><p>然后在这个目录下面输入如下命令：</p></li><li><p>&#96;&#96;&#96;shell<br>git init</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 仓库创建完成后，会在BroadcastBestPractice项目的根目录下生成一个隐藏的.git文件夹，这个文件夹就是用来记录本地所有的Git操作的</span><br><span class="line"></span><br><span class="line">4. 可以在项目目录下面输入如下命令来查看</span><br><span class="line"></span><br><span class="line">5. ```shell</span><br><span class="line">   ls -al</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="6"><li>如果你想要<strong>删除本地仓库</strong>，只需要删除这个文件夹就行了。</li></ol></li></ol></li></ol><h4 id="5-6-3-提交本地代码"><a href="#5-6-3-提交本地代码" class="headerlink" title="5.6.3 提交本地代码"></a>5.6.3 提交本地代码</h4><ol><li><p>代码仓库建立完之后就可以提交代码了，其实提交代码的方法也非常简单，只需要使用add和commit命令就可以了。</p><ol><li><p>add用于把想要提交的代码先添加进来</p></li><li><p>commit则是真正地去执行提交操作</p></li><li><p>&#96;&#96;&#96;shell</p><h1 id="添加单个文件"><a href="#添加单个文件" class="headerlink" title="添加单个文件"></a>添加单个文件</h1><p>git add build.gradle</p><h1 id="添加某个目录"><a href="#添加某个目录" class="headerlink" title="添加某个目录"></a>添加某个目录</h1><p>git add app</p><h1 id="添加所有的文件"><a href="#添加所有的文件" class="headerlink" title="添加所有的文件"></a>添加所有的文件</h1><p>git add .</p><h1 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h1><p>git commit -m “First commit.”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   4. **在commit命令的后面，我们一定要通过-m参数来加上提交的描述信息，没有描述信息的提交被认为是不合法的。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.7 小结与点评</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 第6章 数据存储全方案——详解持久化技术</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 6.1 持久化技术简介</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. Android系统中主要提供了3种方式用于简单地实现数据持久化功能</span><br><span class="line">   1. 文件存储</span><br><span class="line">   2. SharedPreferences存储</span><br><span class="line">   3. 数据库存储</span><br><span class="line">   4. 还可以将数据保存在手机的SD卡中，不过使用文件、SharedPreferences或数据库来保存数据会相对更简单一些，而且比起将数据保存在SD卡中会更加地安全。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 6.2 文件存储</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 它不对存储的内容进行任何的格式化处理，所有数据都是原封不动地保存到文件当中的，因而它比较适合用于存储一些简单的文本数据或二进制数据。</span><br><span class="line">2. 如果你想使用文件存储的方式来保存一些较为复杂的文本数据，就需要定义一套自己的格式规范，这样可以方便之后将数据从文件中重新解析出来。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 6.2.1 将数据存储到文件中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. Context类中提供了一个openFileOutput()方法，可以用于将数据存储到指定的文件中。</span><br><span class="line">   1. 这个方法接收两个参数，第一个参数是文件名，在文件创建的时候使用的就是这个名称，**注意这里指定的文件名不可以包含路径，因为所有的文件都是默认存储到/data/data/&lt;package name&gt;/files/目录下的。**</span><br><span class="line">   2. 第二个参数是文件的操作模式，主要有两种模式可选，MODE_PRIVATE和MODE_APPEND。其中MODE_PRIVATE是**默认**的操作模式，表示当指定同样文件名的时候，所写入的内容将会覆盖原文件中的内容，而MODE_APPEND则表示如果该文件已存在，就往文件里面追加内容，不存在就创建新文件。</span><br><span class="line">   3. 其实文件的操作模式本来还有另外两种：MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE，这两种模式表示允许其他的应用程序对我们程序中的文件进行读写操作，**不过由于这两种模式过于危险，很容易引起应用的安全性漏洞，已在Android 4.2版本中被废弃。**</span><br><span class="line">   4. openFileOutput()方法返回的是一个**FileOutputStream对象**</span><br><span class="line">2. 使用Java流的方式将数据写入到文件中</span><br><span class="line">   1. 通过openFileOutput()方法能够得到一个FileOutputStream对象</span><br><span class="line">   2. 然后再借助它构建出一个OutputStreamWriter对象</span><br><span class="line">   3. 接着再使用OutputStreamWriter构建出一个BufferedWriter对象</span><br><span class="line">   4. 这样你就可以通过BufferedWriter来将文本内容写入到文件中</span><br><span class="line">3. 借助Android Device Monitor工具来查看</span><br><span class="line">   1. ~~点击Android Studio导航栏中的Tools→Android，点击Android Device Monitor~~</span><br><span class="line">   2. 找到/data/data/com.example.filepersistencetest/files/目录，可以看到生成了一个data文件</span><br><span class="line">   3. **Android 7.0系统的模拟器可能无法正常查看FileExplorer中的内容，这或许是新版模拟器的一个bug**</span><br><span class="line">   4. 可以借助导出按钮将这个文件导出到电脑上，其次还有导入按钮</span><br><span class="line">   5. Android Studio导航栏中的View→Tool Windows→Device File Explorer</span><br><span class="line">   6. Android Studio导航栏Tools→SDK Manager找到Android SDK Location + &quot;\tools\lib\monitor-x86_64&quot;目录下找到monitor.exe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 6.2.2 从文件中读取数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. Context类中还提供了一个openFileInput()方法，用于从文件中读取数据。</span><br><span class="line"></span><br><span class="line">   - 它只接收一个参数，即要读取的文件名，然后系统会自动到/data/data/&lt;package name&gt;/files/目录下去加载这个文件，并返回一个FileInputStream对象</span><br><span class="line"></span><br><span class="line">   - 得到了这个对象之后再通过Java流的方式就可以将数据读取出来了。</span><br><span class="line"></span><br><span class="line">   - 首先通过openFileInput()方法获取到了一个FileInputStream对象，然后借助它又构建出了一个InputStreamReader对象，接着再使用InputStreamReader构建出一个BufferedReader对象</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     String content = reader.readLine();</span><br></pre></td></tr></table></figure></li></ol></li><li><pre><code class="java">//将输入光标移动到文本的末尾位置以便继续输入editText.setSelection(inputText.length());<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. **在对字符串进行非空判断的时候使用TextUtils.isEmpty()方法**</span><br><span class="line"></span><br><span class="line">   - 它可以一次性进行两种空值的判断。当传入的字符串等于null或者等于空字符串的时候，这个方法都会返回true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 6.3 SharedPreferences存储</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. SharedPreferences是使用键值对的方式来存储数据的</span><br><span class="line">2. SharedPreferences还支持多种不同的数据类型存储</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 6.3.1 将数据存储到SharedPreferences中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 首先需要获取到SharedPreferences对象。Android中主要提供了3种方法用于得到SharedPreferences对象。</span><br><span class="line">   1. Context类中的getSharedPreferences()方法</span><br><span class="line">      - 此方法接收两个参数，第一个参数用于指定SharedPreferences文件的名称，如果指定的文件不存在则会创建一个，SharedPreferences文件都是存放在/data/data/&lt;package name&gt;/shared_prefs/目录下的。</span><br><span class="line">      - 第二个参数用于指定操作模式，目前只有MODE_PRIVATE这一种模式可选，它是默认的操作模式，和直接传入0效果是相同的，表示只有当前的应用程序才可以对这个SharedPreferences文件进行读写。</span><br><span class="line">      - **其他几种操作模式均已被废弃，**MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE这两种模式是在Android 4.2版本中被废弃的，MODE_MULTI_PROCESS模式是在Android 6.0版本中被废弃的。</span><br><span class="line">   2. Activity类中的getPreferences()方法</span><br><span class="line">      - 它只接收一个操作模式参数，因为使用这个方法时会自动将当前活动的类名作为SharedPreferences的文件名。</span><br><span class="line">   3. PreferenceManager类中的getDefaultSharedPreferences()方法</span><br><span class="line">      - 这是一个静态方法，它接收一个Context参数，并自动使用当前应用程序的包名作为前缀来命名SharedPreferences文件。</span><br><span class="line">2. 向Shared-Preferences文件中存储数据，主要可以分为3步实现。</span><br><span class="line">   1. 调用SharedPreferences对象的edit()方法来获取一个SharedPreferences.Editor对象。</span><br><span class="line">   2. 向SharedPreferences.Editor对象中添加数据，比如添加一个布尔型数据就使用putBoolean()方法，添加一个字符串则使用putString()方法，以此类推。</span><br><span class="line">   3. 调用apply()方法将添加的数据提交，从而完成数据存储操作。</span><br><span class="line">3. SharedPreferences文件是使用XML格式来对数据进行管理的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 6.3.2 从SharedPreferences中读取数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. SharedPreferences对象中提供了一系列的get方法，用于对存储的数据进行读取，每种get方法都对应了Shared-Preferences.Editor中的一种put方法</span><br><span class="line">   1. 这些get方法都接收两个参数，第一个参数是键，传入存储数据时使用的键就可以得到相应的值了</span><br><span class="line">   2. 第二个参数是默认值，即表示当传入的键找不到对应的值时会以什么样的默认值进行返回。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 6.3.3 实现记住密码功能</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. CheckBox复选框控件</span><br><span class="line"></span><br><span class="line">2. 调用CheckBox的isChecked()方法来检查复选框是否被选中</span><br><span class="line"></span><br><span class="line">3. ```java</span><br><span class="line">   //将SharedPreferences文件中的数据全部清除掉</span><br><span class="line">   editor.clear();</span><br><span class="line">   editor.apply();</span><br></pre></td></tr></table></figure></code></pre></li><li><p>加密算法</p></li></ol><h3 id="6-4-SQLite数据库存储"><a href="#6-4-SQLite数据库存储" class="headerlink" title="6.4 SQLite数据库存储"></a>6.4 SQLite数据库存储</h3><ol><li>Android系统内置了数据库</li><li>SQLite是一款轻量级的关系型数据库，它的运算速度非常快，占用资源很少，通常只需要几百KB的内存就足够了，因而特别适合在移动设备上使用。</li><li>SQLite不仅支持标准的SQL语法，还遵循了数据库的ACID事务</li><li>SQLite比一般的数据库要简单得多，它甚至不用设置用户名和密码就可以使用。</li></ol><h4 id="6-4-1-创建数据库"><a href="#6-4-1-创建数据库" class="headerlink" title="6.4.1 创建数据库"></a>6.4.1 创建数据库</h4><ol><li>Android提供了一个SQLiteOpenHelper帮助类，借助这个类就可以非常简单地对数据库进行创建和升级。</li><li>SQLiteOpenHelper是一个抽象类<ol><li>SQLiteOpenHelper中有两个抽象方法，分别是onCreate()和onUpgrade()</li><li>SQLiteOpenHelper中还有两个非常重要的实例方法：getReadableDatabase()和getWritableDatabase()。<ul><li>这两个方法都可以创建或打开一个现有的数据库（如果数据库已存在则直接打开，否则创建一个新的数据库），并返回一个可对数据库进行读写操作的对象。</li><li>不同的是，当数据库不可写入的时候（如磁盘空间已满）,getReadableDatabase()方法返回的对象将以只读的方式去打开数据库，而getWritableDatabase()方法则将出现异常。</li></ul></li><li>SQLiteOpenHelper中有两个构造方法可供重写，一般使用参数少一点的那个构造方法即可。<ul><li>这个构造方法中接收4个参数，第一个参数是Context，必须要有它才能对数据库进行操作。</li><li>第二个参数是数据库名，创建数据库时使用的就是这里指定的名称。</li><li>第三个参数允许我们在查询数据的时候返回一个自定义的Cursor，一般都是传入null。</li><li>第四个参数表示当前数据库的版本号，可用于对数据库进行升级操作。</li></ul></li><li><strong>数据库文件会存放在&#x2F;data&#x2F;data&#x2F;<package name>&#x2F;databases&#x2F;目录下。</strong></li></ol></li><li>SQLite不像其他的数据库拥有众多繁杂的数据类型，它的数据类型很简单，integer表示整型，real表示浮点型，text表示文本类型，blob表示二进制类型。</li><li>primary key表示主键，autoincrement关键字表示id列是自增长的。</li><li>调用SQLiteDatabase的execSQL()方法执行建表语句</li><li>Book表是无法通过FileExplorer看到的。可以使用adb shell来对数据库和表的创建情况进行检查。<ul><li>adb是Android SDK中自带的一个调试工具，使用这个工具可以直接对连接在电脑上的手机或模拟器进行调试操作。</li><li>它存放在sdk的platform-tools目录下，如果想要在命令行中使用这个工具，就需要先把它的路径配置到环境变量里。</li><li>Windows系统，在系统变量里找到Path并点击编辑，将platform-tools目录配置进去</li><li>Linux或Mac系统，可以在home路径下编辑.bash_文件，将platform-tools目录配置进去即可</li><li>配置好了环境变量之后，就可以使用adb工具了。打开命令行界面，输入adb shell，就会进入到设备的控制台</li><li>#符号是超级管理员的意思，也就是说现在你可以访问模拟器中的一切数据。如果你的命令行上显示的是$符号，那么就表示你现在是普遍管理员，需输入su命令切换成超级管理员</li><li>接下来使用cd命令进入到&#x2F;data&#x2F;data&#x2F;com.example.databasetest&#x2F;databases&#x2F;目录下，并使用ls命令查看到该目录里的文件</li><li>BookStore. db-journal是为了让数据库能够支持事务而产生的临时日志文件</li><li>接下来我们就要借助sqlite命令来打开数据库了，只需要键入sqlite3，后面加上数据库名即可</li><li>查看目前数据库中有哪些表，键入.table命令</li><li>android_metadata表是每个数据库中都会自动生成的</li><li>可以通过.schema命令来查看它们的建表语句</li><li>键入.exit或.quit命令可以退出数据库的编辑，再键入exit命令就可以退出设备控制台了。</li></ul></li></ol><h4 id="6-4-2-升级数据库"><a href="#6-4-2-升级数据库" class="headerlink" title="6.4.2 升级数据库"></a>6.4.2 升级数据库</h4><ol><li>onUpgrade()方法是用于对数据库进行升级的</li><li>SQLiteOpenHelper的构造方法里接收的第四个参数，当前数据库的版本号，之前我们传入的是1，现在只要传入一个比1大的数，就可以让onUpgrade()方法得到执行了。将数据库版本号指定为2，表示我们对数据库进行升级了。</li><li>**个人总结:**初始化时调用onCreate方法,并设置version,再次调用时猜测会比较version,如果一样则不执行,低于则报错,高于则执行onUpgrade()方法</li></ol><h4 id="6-4-3-添加数据"><a href="#6-4-3-添加数据" class="headerlink" title="6.4.3 添加数据"></a>6.4.3 添加数据</h4><ol><li>数据操作，即CRUD。其中C代表添加（Create）, R代表查询（Retrieve）, U代表更新（Update）, D代表删除（Delete）。<ul><li>添加数据时使用insert，查询数据时使用select，更新数据时使用update，删除数据时使用delete。</li></ul></li><li>Android提供了一系列的辅助性方法，使得在Android中即使不去编写SQL语句，也能轻松完成所有的CRUD操作。<ol><li>SQLiteDatabase中提供了一个insert()方法，这个方法就是专门用于添加数据的。<ul><li>它接收3个参数，第一个参数是表名</li><li>第二个参数用于在未指定添加数据的情况下给某些可为空的列自动赋值NULL，一般我们用不到这个功能，直接传入null即可。</li><li>第三个参数是一个ContentValues对象，它提供了一系列的put()方法重载，用于向ContentValues中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可。</li><li>ContentValues对象有一个clear()方法</li></ul></li></ol></li></ol><h4 id="6-4-4-更新数据"><a href="#6-4-4-更新数据" class="headerlink" title="6.4.4 更新数据"></a>6.4.4 更新数据</h4><ol><li>SQLiteDatabase中提供了一个非常好用的update()方法，用于对数据进行更新<ol><li>这个方法接收4个参数，第一个参数和insert()方法一样，也是表名。</li><li>第二个参数是ContentValues对象，要把更新数据在这里组装进去。</li><li>第三、第四个参数用于约束更新某一行或某几行中的数据，不指定的话默认就是更新所有行。</li><li>第三个参数对应的是SQL语句的where部分，表示更新所有name等于？的行，而？是一个占位符，可以通过第四个参数提供的一个<strong>字符串数组</strong>为第三个参数中的每个占位符指定相应的内容。</li></ol></li></ol><h4 id="6-4-5-删除数据"><a href="#6-4-5-删除数据" class="headerlink" title="6.4.5 删除数据"></a>6.4.5 删除数据</h4><ol><li>SQLiteDatabase中提供了一个delete()方法，专门用于删除数据<ol><li>这个方法接收3个参数，第一个参数仍然是表名</li><li>第二、第三个参数又是用于约束删除某一行或某几行的数据，不指定的话默认就是删除所有行。</li></ol></li></ol><h4 id="6-4-6-查询数据"><a href="#6-4-6-查询数据" class="headerlink" title="6.4.6 查询数据"></a>6.4.6 查询数据</h4><ol><li>SQLiteDatabase中还提供了一个query()方法用于对数据进行查询。<ol><li>这个方法的参数非常复杂，最短的一个方法重载也需要传入7个参数。</li><li>第一个参数还是表名。</li><li>第二个参数用于指定去查询哪几列，如果不指定则默认查询所有列。</li><li>第三、第四个参数用于约束查询某一行或某几行的数据，不指定则默认查询所有行的数据。</li><li>第五个参数用于指定需要去group by的列，不指定则表示不对查询结果进行group by操作。</li><li>第六个参数用于对group by之后的数据进行进一步的过滤，不指定则表示不进行过滤。</li><li>第七个参数用于指定查询结果的排序方式，不指定则表示使用默认的排序方式。</li><li><img src="/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81Android.assets/image-20220727202715486.png" alt="image-20220727202715486"></li><li>不必为每条查询语句都指定所有的参数，多数情况下只需要传入少数几个参数就可以完成查询操作。</li></ol></li><li>调用query()方法后会返回一个Cursor对象，查询到的所有数据都将从这个对象中取出。<ol><li>Cursor对象的moveToFirst()方法将数据的指针移动到第一行的位置</li><li>通过Cursor的getColumnIndex()方法获取到某一列在表中对应的位置索引，然后将这个索引传入到相应的取值方法中**(例如getString方法)**，就可以得到从数据库中读取到的数据了。</li><li>调用close()方法来关闭Cursor。</li></ol></li></ol><h4 id="6-4-7-使用SQL操作数据库"><a href="#6-4-7-使用SQL操作数据库" class="headerlink" title="6.4.7 使用SQL操作数据库"></a>6.4.7 使用SQL操作数据库</h4><ol><li><p>Android同样提供了一系列的方法，使得可以直接通过SQL来操作数据库。</p></li><li><pre><code class="java">db.execSQL(&quot;delete from Book where pages &gt; ?&quot;, new String[]&#123;&quot;500&quot;&#125;);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. ```java</span><br><span class="line">   db.rawQuery(&quot;select * from Book&quot;, null);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>除了查询数据的时候调用的是SQLiteDatabase的rawQuery()方法，其他的操作都是调用的execSQL()方法。</p></li></ol><h3 id="6-5-使用LitePal操作数据库"><a href="#6-5-使用LitePal操作数据库" class="headerlink" title="6.5 使用LitePal操作数据库"></a>6.5 使用LitePal操作数据库</h3><h4 id="6-5-1-LitePal简介"><a href="#6-5-1-LitePal简介" class="headerlink" title="6.5.1 LitePal简介"></a>6.5.1 LitePal简介</h4><ol><li>现在有很多公司为了追求开发效率以及项目稳定性，都会选择使用开源库。</li><li>第一个开源库——LitePal。<ol><li>LitePal是一款开源的Android数据库框架，它采用了对象关系映射（ORM）的模式，并将我们平时开发最常用到的一些数据库功能进行了封装，使得不用编写一行SQL语句就可以完成各种建表和増删改查的操作。</li><li>LitePal的项目主页上也有详细的使用文档，地址是：<a href="https://github.com/LitePalFramework/LitePal">https://github.com/LitePalFramework/LitePal</a></li></ol></li></ol><h4 id="6-5-2-配置LitePal"><a href="#6-5-2-配置LitePal" class="headerlink" title="6.5.2 配置LitePal"></a>6.5.2 配置LitePal</h4><ol><li><p>过去的方式比较复杂，通常需要下载开源库的Jar包或者源码，然后再集成到我们的项目当中。</p></li><li><p>现在大多数的开源项目都会将版本提交到jcenter上，我们只需要在app&#x2F;build.gradle文件中声明该开源库的引用就可以了。</p><ul><li><pre><code class="json">dependencies &#123;    implementation &#39;org.litepal.guolindev:core:3.2.3&#39;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 接下来需要配置litepal.xml文件</span><br><span class="line"></span><br><span class="line">   - 右击app/src/main目录→New→Directory，创建一个assets目录，然后在assets目录下再新建一个litepal.xml文件</span><br><span class="line"></span><br><span class="line">   - ```xml</span><br><span class="line">     &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">     &lt;litepal&gt;</span><br><span class="line">         &lt;dbname value=&quot;BookStore&quot;&gt;&lt;/dbname&gt;</span><br><span class="line">         &lt;version value=&quot;1&quot;&gt;&lt;/version&gt;</span><br><span class="line">         &lt;list&gt;&lt;/list&gt;</span><br><span class="line">     &lt;/litepal&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p><dbname>标签用于指定数据库名，<version>标签用于指定数据库版本号，<list>标签用于指定所有的映射模型</p></li></ul></li><li><p>最后还需要再配置一下LitePalApplication，修改AndroidManifest.xml中的代码</p><ul><li><pre><code class="xml">&lt;application android:name=&quot;org.litepal.LitePalApplication&quot;&gt;&lt;/application&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  LitePal.initialize(this);</span><br></pre></td></tr></table></figure></code></pre></li><li><p><strong>遇到的问题: Unresolved package ‘litepal‘</strong> </p><ul><li><img src="/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81Android.assets/image-20220727223223506.png" alt="image-20220727223223506"></li><li>如果还是无法解决</li><li><img src="/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81Android.assets/image-20220727223207875.png" alt="image-20220727223207875"></li></ul></li></ul></li></ol><h4 id="6-5-3-创建和升级数据库"><a href="#6-5-3-创建和升级数据库" class="headerlink" title="6.5.3 创建和升级数据库"></a>6.5.3 创建和升级数据库</h4><ol><li><p>什么是对象关系映射（ORM）呢？简单点说，我们使用的编程语言是面向对象语言，而使用的数据库则是关系型数据库，那么将面向对象的语言和面向关系的数据库之间建立一种映射关系，这就是对象关系映射了。</p></li><li><p>将Book类添加到映射模型列表当中，Book类是一个典型的Java bean</p><ul><li><p>使用<mapping>标签来声明我们要配置的映射模型类</p></li><li><p>一定要使用完整的类名。</p></li><li><p>不管有多少模型类需要映射，都使用同样的方式配置在<list>标签下即可。</p></li><li><p>&#96;&#96;&#96;xml</p><list>    <mapping class="com.xuan.litepaltest.Book"></mapping></list><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 调用LitePal.getDatabase()方法就是一次最简单的数据库操作，数据库自动创建完成</span><br><span class="line"></span><br><span class="line">   - 这里有3张表，其中android_metadata表仍然不用管，table_schema表是LitePal内部使用的，我们也可以直接忽视，book表就是根据我们定义的Book类以及类中的字段来自动生成的了。</span><br><span class="line"></span><br><span class="line">4. 如果我们想要向Book表中添加一个press（出版社）列，直接修改Book类中的代码，添加一个press字段即可，然后将**版本号加1**就行了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 6.5.4 使用LitePal添加数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 创建出模型类的实例，再将所有要存储的数据设置好，最后调用一下save()方法就可以了。</span><br><span class="line">2. LitePal进行表管理操作时不需要模型类有任何的继承结构，但是进行CRUD操作时就不行了，必须要继承自**DataSupport类**才行</span><br><span class="line">3. ==DataSupport类被弃用问题==</span><br><span class="line">   1. 需要进行CRUD操作时，需要继承DataSupport类，这时可以用**LitepalSupport类**来代替。</span><br><span class="line">   2. 当需要进行DataSupport类的静态调用时，可以把**DataSupport改为LitePal。**</span><br><span class="line">4. save()方法是从LitepalSupport类中继承而来的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 6.5.5 使用LitePal更新数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 最简单的一种更新方式就是对已存储的对象重新设值，然后重新调用save()方法即可。</span><br><span class="line"></span><br><span class="line">2. 已存储对象</span><br><span class="line"></span><br><span class="line">   1. 对于LitePal来说，对象是否已存储就是根据调用model.isSaved()方法的结果来判断的，返回true就表示已存储，返回false就表示未存储。</span><br><span class="line">   2. 实际上只有在两种情况下model.isSaved()方法才会返回true，一种情况是已经调用过model.save()方法去添加数据了，此时model会被认为是已存储的对象。</span><br><span class="line">   3. 另一种情况是model对象是通过LitePal提供的查询API查出来的，由于是从数据库中查到的对象，因此也会被认为是已存储的对象。</span><br><span class="line"></span><br><span class="line">3. 另外一种更加灵巧的更新方式。</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      Book book = new Book();</span><br><span class="line">      book.setPrice(14.95);</span><br><span class="line">      book.updateAll(&quot;name=? and author =?&quot;, &quot;The Lost Symbol&quot;, &quot;Dan Brown&quot;);</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p>updateAll()方法中可以指定一个条件约束，和SQLiteDatabase中update()方法的where参数部分有点类似，但更加简洁，如果不指定条件语句的话，就表示更新所有数据。</p></li><li><p>&#x3D;&#x3D;注意:&#x3D;&#x3D; 当你想把一个字段的值更新成默认值时，是不可以使用上面的方式来set数据的。</p><ol><li><p>在Java中任何一种数据类型的字段都会有默认值，当new出一个Book对象时，其实所有字段都已经被初识化成默认值了，</p></li><li><p>因此，如果我们想把数据库表中的pages列更新成0，直接调用book.setPages(0)是不可以的，因为即使不调用这行代码，pages字段本身也是0, LitePal此时是不会对这个列进行更新的。</p></li><li><p>对于所有想要将为数据更新成默认值的操作，LitePal统一提供了一个setToDefault()方法，然后传入相应的列名就可以实现了。</p></li><li><p>&#96;&#96;&#96;java<br>Book book &#x3D; new Book();<br>book.setToDefault(“pages”);<br>book.updateAll();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 6.5.6 使用LitePal删除数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 使用LitePal删除数据的方式主要有两种</span><br><span class="line"></span><br><span class="line">   1. 第一种比较简单，就是直接调用**已存储对象**的delete()方法就可以了</span><br><span class="line"></span><br><span class="line">   2. 调用LitePal.deleteAll()方法来删除数据，其中deleteAll()方法的第一个参数用于指定删除哪张表中的数据，后面的参数用于指定约束条件</span><br><span class="line"></span><br><span class="line">   3. ```java</span><br><span class="line">      LitePal.deleteAll(Book.class, &quot;price &lt; ?&quot;, &quot;15&quot;);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>deleteAll()方法如果不指定约束条件，就意味着你要删除表中的所有数据，这一点和updateAll()方法是比较相似的。</p></li></ol></li></ol><h4 id="6-5-7-使用LitePal查询数据"><a href="#6-5-7-使用LitePal查询数据" class="headerlink" title="6.5.7 使用LitePal查询数据"></a>6.5.7 使用LitePal查询数据</h4><ol><li><pre><code class="java">List&lt;Book&gt; books = LitePal.findAll(Book.class);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 查询Book表中的第一条数据就可以这样写：</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      Book firstBook = LitePal.findFirst(Book.class);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>查询Book表中的最后一条数据findLast()</p></li><li><p>通过连缀查询来定制更多的查询功能</p><ol><li><p>select()方法用于指定查询哪几列的数据，对应了SQL当中的select关键字。</p></li><li><pre><code class="java">List&lt;Book&gt; books = LitePal.select(&quot;name&quot;, &quot;author&quot;).find(Book.class);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. where()方法用于指定查询的约束条件，对应了SQL当中的where关键字。</span><br><span class="line"></span><br><span class="line">4. ```java</span><br><span class="line">   List&lt;Book&gt; books = LitePal.where(&quot;pages &gt; ?&quot;, &quot;400&quot;).find(Book.class);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>order()方法用于指定结果的排序方式，对应了SQL当中的order by 关键字。</p></li><li><pre><code class="java">//desc表示降序排列，asc或者不写表示升序排列List&lt;Book&gt; books = LitePal.order(&quot;price desc&quot;).find(Book.class);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. limit()方法用于指定查询结果的数量</span><br><span class="line"></span><br><span class="line">8. ```java</span><br><span class="line">   //只查表中的前3条数据</span><br><span class="line">   List&lt;Book&gt; books = LitePal.limit(3).find(Book.class);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>offset()方法用于指定查询结果的偏移量</p></li><li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;查询表中的第2条、第3条、第4条数据<br>List<Book> books &#x3D; LitePal.limit(3).offset(1).find(Book.class);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">11. 对这5个方法进行任意的连缀组合</span><br><span class="line"></span><br><span class="line">12. ```java</span><br><span class="line">    List&lt;Book&gt; books = LitePal.select(&quot;name&quot;, &quot;author&quot;, &quot;pages&quot;)</span><br><span class="line">            .where(&quot;pages &gt; ?&quot;, &quot;400&quot;)</span><br><span class="line">            .order(&quot;pages&quot;)</span><br><span class="line">            .limit(10)</span><br><span class="line">            .offset(10)</span><br><span class="line">            .find(Book.class);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>LitePal仍然支持使用原生的SQL来进行查询</p><ol><li>&#96;&#96;&#96;java<br>Cursor c &#x3D; LitePal.findBySQL(“select * from Book where pages &gt; ? and price &lt; ?”, “400”, “20”);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   2. 第一个参数用于指定SQL语句，后面的参数用于指定占位符的值。</span><br><span class="line"></span><br><span class="line">   3. findBySQL()方法返回的是一个Cursor对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 6.6 小结与点评</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 第7章 跨程序共享数据——探究内容提供器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 7.1 内容提供器简介</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 内容提供器（Content Provider）主要用于在不同的应用程序之间实现数据共享的功能</span><br><span class="line">2. 它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访数据的安全性</span><br><span class="line">3. 内容提供器可以选择只对哪一部分数据进行共享，从而保证我们程序中的隐私数据不会有泄漏的风险</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 7.2 运行时权限</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. Android开发团队在Android 6.0系统中引用了运行时权限这个功能，从而更好地保护了用户的安全和隐私</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 7.2.1 Android权限机制详解</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. Android的权限机制从系统的第一个版本开始就已经存在了。</span><br><span class="line">2. 权限声明后对于用户设备的安全性</span><br><span class="line">   1. 一方面，如果用户在低于6.0系统的设备上安装该程序，会在安装界面给出提醒。这样用户就可以清楚地知晓该程序一共申请了哪些权限，从而决定是否要安装这个程序。</span><br><span class="line">   2. 另一方面，用户可以随时在应用程序管理界面查看任意一个程序的权限申请情况。这样该程序申请的所有权限就尽收眼底，什么都瞒不过用户的眼睛，以此保证应用程序不会出现各种滥用权限的情况。</span><br><span class="line">3. 权限的滥用</span><br><span class="line">   1. 很多常用软件不管到底用不用得到，反正先把权限申请了再说。</span><br><span class="line">   2. **&quot;店大欺客&quot;**</span><br><span class="line">4. 运行时权限功能</span><br><span class="line">   1. 用户不需要在安装软件的时候一次性授权所有申请的权限，而是可以在软件的使用过程中再对某一项权限申请进行授权。</span><br><span class="line">   2. 并不是所有权限都需要在运行时申请</span><br><span class="line">5. Android现在将所有的权限归成了两类，一类是普通权限，一类是危险权限。准确地讲，其实还有第三类特殊权限，不过这种权限使用得很少</span><br><span class="line">   1. 普通权限指的是那些不会直接威胁到用户的安全和隐私的权限，对于这部分权限申请，系统会自动帮我们进行授权，而不需要用户再去手动操作了</span><br><span class="line">   2. 危险权限则表示那些可能会触及用户隐私或者对设备安全性造成影响的权限，对于这部分权限申请，必须要由用户手动点击授权才可以，否则程序就无法使用相应的功能。</span><br><span class="line">   3. **除了危险权限之外，剩余的就都是普通权限了。Android中所有的危险权限，一共是9组24个权限。**</span><br><span class="line">   4. ![image-20220728144348306](第一行代码Android.assets/image-20220728144348306.png)</span><br><span class="line">   5. ==注意==:  表格中每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名，但是用户一旦同意授权了，那么该权限所对应的权限组中所有的其他权限也会同时被授权。</span><br><span class="line">   6. 访问http://developer.android.google.cn/reference/android/Manifest.permission.html可以查看Android系统中完整的权限列表。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 7.2.2 在程序运行时申请权限</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. CALL_PHONE这个权限是编写拨打电话功能的时候需要声明的，因为拨打电话会涉及用户手机的资费问题，因而被列为了危险权限。</span><br><span class="line"></span><br><span class="line">   - Intent.ACTION_DIAL，表示打开拨号界面，这个是不需要声明权限的</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     try &#123;</span><br><span class="line">         Intent intent = new Intent(Intent.ACTION_CALL);</span><br><span class="line">         intent.setData(Uri.parse(&quot;tel:10086&quot;));</span><br><span class="line">         startActivity(intent);</span><br><span class="line">     &#125;</span><br><span class="line">     catch (SecurityException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><pre><code class="xml">&lt;!--声明权限--&gt;&lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. **Permission Denial**，可以看出，是由于权限被禁止所导致的，因为6.0及以上系统在使用危险权限时都必须进行运行时权限处理。</span><br><span class="line"></span><br><span class="line">4. 运行时权限的完整流程</span><br><span class="line"></span><br><span class="line">   1. 先判断用户是不是已经给过我们授权了，借助的是ContextCompat.checkSelfPermission()方法。</span><br><span class="line"></span><br><span class="line">      - checkSelfPermission()方法接收两个参数，第一个参数是Context</span><br><span class="line">      - 第二个参数是具体的权限名，比如打电话的权限名就是Manifest.permission.CALL_PHONE</span><br><span class="line"></span><br><span class="line">   2. 然后我们使用方法的返回值和PackageManager.PERMISSION_GRANTED做比较，相等就说明用户已经授权，不等就表示用户没有授权。</span><br><span class="line"></span><br><span class="line">   3. 如果没有授权的话，则需要调用ActivityCompat.requestPermissions()方法来向用户申请授权</span><br><span class="line"></span><br><span class="line">      - requestPermissions()方法接收3个参数，第一个参数要求是Activity的实例</span><br><span class="line"></span><br><span class="line">      - 第二个参数是一个String数组，我们把要申请的权限名放在数组中即可</span><br><span class="line"></span><br><span class="line">      - 第三个参数是请求码，只要是唯一值就可以了，这里传入了1</span><br><span class="line"></span><br><span class="line">      - ```java</span><br><span class="line">        if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.CALL_PHONE&#125;, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            call();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>4. 调用完了requestPermissions()方法之后，系统会弹出一个权限申请的对话框，然后用户可以选择同意或拒绝我们的权限申请，不论是哪种结果，最终都会回调到onRequest-PermissionsResult()方法中，而授权的结果则会封装在grantResults参数当中。   - ```java     @Override     public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;         super.onRequestPermissionsResult(requestCode, permissions, grantResults);         switch (requestCode) &#123;             case 1:                 if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;                     call();                 &#125; else &#123;                     Toast.makeText(this, &quot;You denied the permission&quot;, Toast.LENGTH_SHORT).show();                 &#125;                 break;             default:         &#125;     &#125;     <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. 用户随时都可以将授予程序的危险权限进行关闭，进入Settings → Apps →RuntimePermissionTest → Permissions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 7.3 访问其他程序中的数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 内容提供器的用法一般有两种，一种是使用现有的内容提供器来读取和操作相应程序中的数据</span><br><span class="line">2. 另一种是创建自己的内容提供器给我们程序的数据提供外部访问接口</span><br><span class="line">3. 如果一个应用程序通过内容提供器对其数据提供了外部访问接口，那么任何其他的应用程序就都可以对这部分数据进行访问。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 7.3.1 ContentResolver的基本用法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 想要访问内容提供器中共享的数据，就一定要借助ContentResolver类，可以通过Context中的getContentResolver()方法获取到该类的实例。</span><br><span class="line"></span><br><span class="line">2. ContentResolver中提供了一系列的方法用于对数据进行CRUD操作，insert()，update()，delete()，query()</span><br><span class="line"></span><br><span class="line">3.  ContentResolver中的增删改查方法都是不接收表名参数的，而是使用一个Uri参数代替，这个参数被称为内容URI。</span><br><span class="line"></span><br><span class="line">   1. 内容URI给内容提供器中的数据建立了唯一标识符，它主要由两部分组成：authority和path。</span><br><span class="line"></span><br><span class="line">      - authority是用于对不同的应用程序做区分的，一般为了避免冲突，都会采用程序包名的方式来进行命名。</span><br><span class="line">      - path则是用于对同一应用程序中不同的表做区分的，通常都会添加到authority的后面。</span><br><span class="line"></span><br><span class="line">   2. 我们还需要在字符串的头部加上协议声明。</span><br><span class="line"></span><br><span class="line">      - ```http</span><br><span class="line">        content://com.xuan.app.provider/table1</span><br></pre></td></tr></table></figure>3. **内容URI可以非常清楚地表达出我们想要访问==哪个==程序中==哪张==表里的数据。**4. 得到了内容URI字符串之后，我们还需要将它解析成Uri对象才可以作为参数传入。   - 只需要调用Uri.parse()方法</code></pre></li><li><p>query()</p><ul><li><img src="/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81Android.assets/image-20220728163209355.png" alt="image-20220728163209355"></li><li>查询完成后返回的仍然是一个Cursor对象</li></ul></li><li><p>添加数据</p><ul><li>仍然是将待添加的数据组装到ContentValues中，然后调用ContentResolver的insert()方法，将Uri和ContentValues作为参数传入即可。</li></ul></li><li><p>更新数据</p><ul><li>借助ContentResolver的update()方法实现，可以使用selection和selectionArgs参数来对想要更新的数据进行约束，以防止所有的行都会受影响。</li></ul></li><li><p>删除数据</p><ul><li>调用ContentResolver的delete()方法实现，可以使用selection和selectionArgs参数来对想要删除的数据进行约束，以防止所有的行都会受影响。</li></ul></li></ol><h4 id="7-3-2-读取系统联系人"><a href="#7-3-2-读取系统联系人" class="headerlink" title="7.3.2 读取系统联系人"></a>7.3.2 读取系统联系人</h4><ol><li><p>权限</p><ul><li>READ_CONTACTS</li></ul></li><li><p>Uri</p><ul><li>ContactsContract.CommonDataKinds.Phone.CONTENT_URI</li></ul></li><li><p>getColumnIndex()参数</p><ol><li>ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME</li><li>ContactsContract.CommonDataKinds.Phone.NUMBER</li></ol></li><li><p><strong>最后千万不要忘记将Cursor对象关闭掉</strong></p></li><li><p>&#x3D;&#x3D;读取系统联系人的权限千万不能忘记声明&#x3D;&#x3D;</p><ul><li>&#96;&#96;&#96;xml<uses-permission android:name="android.permission.READ_CONTACTS"/><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 7.4 创建自己的内容提供器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 7.4.1 创建内容提供器的步骤</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 通过新建一个类去继承ContentProvider的方式来创建一个自己的内容提供器。</span><br><span class="line"></span><br><span class="line">2. ContentProvider类中有6个抽象方法，我们在使用子类继承它的时候，需要将这6个方法全部重写。</span><br><span class="line"></span><br><span class="line">   1. onCreate()初始化内容提供器的时候调用。通常会在这里完成对数据库的创建和升级等操作</span><br><span class="line"></span><br><span class="line">      - 返回true表示内容提供器初始化成功</span><br><span class="line">      - 返回false则表示失败</span><br><span class="line"></span><br><span class="line">   2. query()从内容提供器中查询数据。</span><br><span class="line"></span><br><span class="line">      - 使用uri参数来确定查询哪张表</span><br><span class="line">      - projection参数用于确定查询哪些列</span><br><span class="line">      - selection和selectionArgs参数用于约束查询哪些行</span><br><span class="line">      - sortOrder参数用于对结果进行排序</span><br><span class="line">      - 查询的结果存放在Cursor对象中返回</span><br><span class="line"></span><br><span class="line">   3. insert()向内容提供器中添加一条数据。</span><br><span class="line"></span><br><span class="line">      - 使用uri参数来确定要添加到的表</span><br><span class="line">      - 待添加的数据保存在values参数中</span><br><span class="line">      - 添加完成后，返回一个用于表示这条新记录的URI</span><br><span class="line"></span><br><span class="line">   4. update()更新内容提供器中已有的数据。</span><br><span class="line"></span><br><span class="line">      - 使用uri参数来确定更新哪一张表中的数据</span><br><span class="line">      - 新数据保存在values参数中</span><br><span class="line">      - selection和selectionArgs参数用于约束更新哪些行</span><br><span class="line">      - 受影响的行数将作为返回值返回。</span><br><span class="line"></span><br><span class="line">   5. delete()从内容提供器中删除数据。</span><br><span class="line"></span><br><span class="line">      - 使用uri参数来确定删除哪一张表中的数据</span><br><span class="line">      - selection和selectionArgs参数用于约束删除哪些行</span><br><span class="line">      - 被删除的行数将作为返回值返回。</span><br><span class="line"></span><br><span class="line">   6. getType()根据传入的内容URI来返回相应的MIME类型。</span><br><span class="line"></span><br><span class="line">      - MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的标准</span><br><span class="line"></span><br><span class="line">      - type/subtype</span><br><span class="line"></span><br><span class="line">      - 一个内容URI所对应的MIME字符串主要由3部分组成</span><br><span class="line"></span><br><span class="line">        1. 必须以vnd开头</span><br><span class="line"></span><br><span class="line">        2. 如果内容URI以路径结尾，则后接android.cursor.dir/，如果内容URI以id结尾，则后接android.cursor.item/</span><br><span class="line"></span><br><span class="line">        3. 最后接上vnd.&lt;authority&gt;.&lt;path&gt;</span><br><span class="line"></span><br><span class="line">        4. ```http</span><br><span class="line">           vnd.android.cursor.dir/vnd.com.xuan.app.provider.table1</span><br></pre></td></tr></table></figure><ol start="5"><li>&#96;&#96;&#96;http<br>vnd.android.cursor.item&#x2F;vnd.com.xuan.app.provider.table1<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   7. 几乎每一个方法都会带有Uri这个参数，这个参数也正是调用ContentResolver的增删改查方法时传递过来的。而现在，我们需要对传入的Uri参数进行解析，从中分析出调用方期望访问的表和数据。</span><br><span class="line"></span><br><span class="line">3. 内容URI的格式主要就只有两种</span><br><span class="line"></span><br><span class="line">   1. 以路径结尾就表示期望访问该表中所有的数据</span><br><span class="line"></span><br><span class="line">      - ```http</span><br><span class="line">        content://com.xuan.app.provider/table1</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="2"><li><p>以id结尾就表示期望访问该表中拥有相应id的数据</p><ul><li>&#96;&#96;&#96;http<br>content:&#x2F;&#x2F;com.xuan.app.provider&#x2F;table1&#x2F;1<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   3. 们可以使用**通配符**的方式来分别匹配这两种格式的内容URI</span><br><span class="line"></span><br><span class="line">      - *：表示匹配任意长度的任意字符</span><br><span class="line">      - #：表示匹配任意长度的数字</span><br><span class="line"></span><br><span class="line">   4. 接着，我们再借助UriMatcher这个类就可以轻松地实现匹配内容URI的功能。UriMatcher中提供了一个addURI()方法</span><br><span class="line"></span><br><span class="line">      - 这个方法接收3个参数，可以分别把authority、path和一个自定义代码传进去。</span><br><span class="line"></span><br><span class="line">   5. 这样，当调用UriMatcher的match()方法时，就可以将一个Uri对象传入，返回值是某个能够匹配这个Uri对象所对应的自定义代码，利用这个代码，我们就可以判断出调用方期望访问的是哪张表中的数据了</span><br><span class="line"></span><br><span class="line">4. query()、insert()、update()、delete()这几个方法都会携带Uri这个参数，然后利用UriMatcher的match()方法判断出调用方期望访问的是哪张表，再对该表中的数据进行相应的操作就可以了。</span><br><span class="line"></span><br><span class="line">5. 实现getType()方法中的逻辑</span><br><span class="line"></span><br><span class="line">6. ==如何才能保证隐私数据不会泄漏出去呢？==</span><br><span class="line"></span><br><span class="line">   - 所有的CRUD操作都一定要匹配到相应的内容URI格式才能进行的，而我们当然不可能向UriMatcher中添加隐私数据的URI，所以这部分数据根本无法被外部程序访问到，安全问题也就不存在了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 7.4.2 实现跨程序数据共享</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 跨程序访问时我们不能直接使用Toast</span><br><span class="line"></span><br><span class="line">2. 创建一个内容提供器，右击com.xuan.databasetest包→New→Other→Content Provider</span><br><span class="line"></span><br><span class="line">   - 内容提供器命名为DatabaseProvider</span><br><span class="line">   - authority指定为com.xuan.databasetest.provider</span><br><span class="line">   - Exported属性表示是否允许外部程序访问我们的内容提供器</span><br><span class="line">   - Enabled属性表示是否启用这个内容提供器</span><br><span class="line">   - 将两个属性都勾中</span><br><span class="line"></span><br><span class="line">3. 获取ID</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     String bookId = uri.getPathSegments().get(1);</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li>Uri对象的getPathSegments()方法，它会将内容URI权限之后的部分以“&#x2F;”符号进行分割，并把分割后的结果放入到一个字符串列表中，那这个列表的第0个位置存放的就是路径，第1个位置存放的就是id了。</li></ul></li><li><p>insert()</p><ul><li>&#96;&#96;&#96;java<br>long newBookId &#x3D; db.insert(“Book”, null, values);<br>uriReturn &#x3D; Uri.parse(“content:&#x2F;&#x2F;“ + AUTHORITY + “&#x2F;book” + newBookId);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - insert()方法要求返回一个能够表示这条新增数据的URI，所以我们还需要调用Uri.parse()方法来将一个内容URI解析成Uri对象，当然这个内容URI是以新增数据的id结尾的。</span><br><span class="line"></span><br><span class="line">5. 另外还有一点需要注意，内容提供器一定要在AndroidManifest.xml文件中注册才可以使用。不过由于我们是使用Android Studio的快捷方式创建的内容提供器，因此注册这一步已经被自动完成了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 7.5 Git时间——版本控制工具进阶</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 7.5.1 忽略文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. build目录下的文件都是编译项目时自动生成的，我们不应该将这部分文件添加到版本控制当中</span><br><span class="line">2. Git提供了一种可配性很强的机制来允许用户将指定的文件或目录排除在版本控制之外，它会检查代码仓库的目录下是否存在一个名为.gitignore的文件，如果存在的话，就去一行行读取这个文件中的内容，并把每一行指定的文件或目录排除在版本控制之外。注意.gitignore中指定的文件或目录是可以使用“*”通配符的。</span><br><span class="line">3. 我们并不需要自己去创建.gitignore文件，Android Studio在创建项目的时候会自动帮我们创建出两个.gitignore文件，一个在根目录下面，一个在app模块下面。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 7.5.2 查看修改内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 如何使用Git来查看自上次提交后文件修改的内容。</span><br><span class="line"></span><br><span class="line">   1. 查看文件修改情况的方法非常简单，只需要使用status命令就可以了，在项目的根目录下输入如下命令：</span><br><span class="line"></span><br><span class="line">      - ```shell</span><br><span class="line">        git status</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p>如何才能看到更改的内容呢？这就需要借助diff命令了，用法如下所示：</p><ul><li><pre><code class="shell">git diff<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 如果你只想查看MainActivity.java这个文件的更改内容，可以使用如下命令：</span><br><span class="line"></span><br><span class="line">   - ```shell</span><br><span class="line">     git diff app/src/main/java/com/xuan/providertest/MainActivity.java</span><br></pre></td></tr></table></figure></code></pre></li><li><p>其中，减号代表删除的部分，加号代表添加的部分</p></li></ul></li></ol></li></ol><h4 id="7-5-3-撤销未提交的修改"><a href="#7-5-3-撤销未提交的修改" class="headerlink" title="7.5.3 撤销未提交的修改"></a>7.5.3 撤销未提交的修改</h4><ol><li><p>只要代码还未提交，所有修改的内容都是可以撤销的。</p></li><li><p>比如我们修改了MainActivity里一本书的价格，现在如果想要撤销这个修改就可以使用checkout命令，用法如下所示：</p><ul><li><pre><code class="shell">git checkout app/src/main/java/com/xuan/providertest/MainActivity.java<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - 这种撤销方式只适用于那些还没有执行过add命令的文件，如果某个文件已经被添加过了，这种方式就无法撤销其更改的内容</span><br><span class="line"></span><br><span class="line">3. 对于已添加的文件我们应该先对其取消添加，然后才可以撤回提交。取消添加使用的是reset命令，用法如下所示：</span><br><span class="line"></span><br><span class="line">   - ```shell</span><br><span class="line">     git reset HEAD app/src/main/java/com/xuan/providertest/MainActivity.java</span><br></pre></td></tr></table></figure></code></pre></li><li><p>此时就可以使用checkout命令来将修改的内容进行撤销了。</p></li></ul></li></ol><h4 id="7-5-4-查看提交记录"><a href="#7-5-4-查看提交记录" class="headerlink" title="7.5.4 查看提交记录"></a>7.5.4 查看提交记录</h4><ol><li><p>可以使用log命令查看历史提交信息，用法如下所示：</p><ul><li><pre><code class="shell">git log<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - 每次提交记录都会包含提交id、提交人、提交日期以及提交描述这4个信息。</span><br><span class="line"></span><br><span class="line">2. 当提交记录非常多的时候，如果我们只想查看其中一条记录，可以在命令中指定该记录的id，并加上-1参数表示我们只想看到一行记录，如下所示：</span><br><span class="line"></span><br><span class="line">   - ```shell</span><br><span class="line">     git log git 1fa380b502a00b82bfc8d84c5ab5e15b8fbf7dac -1</span><br></pre></td></tr></table></figure></code></pre></li><li><p>如果想要查看这条提交记录具体修改了什么内容，可以在命令中加入-p参数，命令如下：</p><ul><li><pre><code class="shell">git log git 1fa380b502a00b82bfc8d84c5ab5e15b8fbf7dac -1 -p<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     - 其中减号代表删除的部分，加号代表添加的部分。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 7.6 小结与点评</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. **每次在创建内容提供器的时候，你都需要提醒一下自己，我是不是应该这么做？因为只有真正需要将数据共享出去的时候我们才应该创建内容提供器，仅仅是用于程序内部访问的数据就没有必要这么做，所以千万别对它进行滥用。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 第8章 丰富你的程序——运用手机多媒体</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 8.1 将程序运行到手机上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 先通过数据线把手机连接到电脑上</span><br><span class="line">2. 然后进入到设置→开发者选项界面，并在这个界面中勾选中USB调试选项</span><br><span class="line">   - ==注意==从Android 4.2系统开始，开发者选项默认是隐藏的，你需要先进入到“关于手机”界面，然后对着最下面的版本号那一栏连续点击，就会让开发者选项显示出来。</span><br><span class="line">3. 如果你使用的是Windows操作系统，还需要在电脑上安装手机的驱动。</span><br><span class="line">   - 一般借助360手机助手或豌豆荚等工具都可以快速地进行安装</span><br><span class="line">4. 在Android Monitor中切换到刚刚连接上的手机，然后运行当前项目</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 8.2 使用通知</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 通知（Notification）是Android系统中比较有特色的一个功能，当某个应用程序希望向用户发出一些提示信息，而该应用程序又不在前台运行时，就可以借助通知来实现。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 8.2.1 通知的基本用法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 通知既可以在活动里创建，也可以在广播接收器里创建，当然还可以在服务里创建。</span><br><span class="line"></span><br><span class="line">   - 相比于广播接收器和服务，在活动里创建通知的场景还是比较少的，因为一般只有当程序进入到后台的时候我们才需要使用通知。</span><br><span class="line"></span><br><span class="line">2. 创建通知的详细步骤</span><br><span class="line"></span><br><span class="line">   1. 首先需要一个**NotificationManager**来对通知进行管理，可以调用**Context的getSystemService()**方法获取到</span><br><span class="line"></span><br><span class="line">      - getSystemService()方法接收一个字符串参数用于确定获取系统的哪个服务，这里我们传入**Context.NOTIFICATION_SERVICE**即可</span><br><span class="line"></span><br><span class="line">   2. 接下来需要使用一个Builder构造器来创建Notification对象</span><br><span class="line"></span><br><span class="line">      - 几乎Android系统的每一个版本都会对通知这部分功能进行或多或少的修改，API不稳定性问题在通知上面突显得尤其严重。</span><br><span class="line"></span><br><span class="line">      - 解决方案就是使用support库中提供的兼容API。support-v4库中提供了一个NotificationCompat类，使用这个类的构造器来创建Notification对象</span><br><span class="line"></span><br><span class="line">      - ```java</span><br><span class="line">        Notification notification = new NotificationCompat.Builder(context).build();</span><br></pre></td></tr></table></figure></code></pre></li><li><p>只是创建了一个空的Notification对象，并没有什么实际作用，我们可以在最终的build()方法之前连缀任意多的设置方法来创建一个丰富的Notification对象</p></li><li><p>设置方法</p><ol><li><p>setContentTitle()方法用于指定通知的标题内容，下拉系统状态栏就可以看到这部分内容。</p></li><li><p>setContentText()方法用于指定通知的正文内容，同样下拉系统状态栏就可以看到这部分内容。</p></li><li><p>setWhen()方法用于指定通知被创建的时间，以毫秒为单位，当下拉系统状态栏时，这里指定的时间会显示在相应的通知上。</p><ul><li>&#96;&#96;&#96;java<br>setWhen(System.currentTimeMillis())<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. setSmallIcon()方法用于设置通知的小图标，注意只能使用纯alpha图层的图片进行设置，小图标会显示在系统状态栏上。</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     setSmallIcon(R.mipmap.ic_launcher)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>setLargeIcon()方法用于设置通知的大图标，当下拉系统状态栏时，就可以看到设置的大图标了。</p><ul><li>&#96;&#96;&#96;java<br>setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     6. setContentIntent()方法，接收的参数是一个PendingIntent对象</span><br><span class="line"></span><br><span class="line">3. 调用NotificationManager的notify()方法就可以让通知显示出来</span><br><span class="line"></span><br><span class="line">   - notify()方法接收两个参数，第一个参数是id，要保证为每个通知所指定的id都是不同的</span><br><span class="line">   - 第二个参数则是Notification对象</span><br><span class="line"></span><br><span class="line">4. ==这里需要注意，Android8.0也就是API26开始要求创建 Channel 渠道==</span><br><span class="line"></span><br><span class="line">   - ![image-20220730110613329](第一行代码Android.assets/image-20220730110613329.png)</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">         NotificationChannel notificationChannel = new NotificationChannel(&quot;channelId&quot;, &quot;channelName&quot;, NotificationManager.IMPORTANCE_DEFAULT);</span><br><span class="line">         manager.createNotificationChannel(notificationChannel);</span><br><span class="line">         builder = new NotificationCompat.Builder(MainActivity.this,&quot;channelId&quot;);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         builder = new NotificationCompat.Builder(MainActivity.this);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul></li></ul></li><li><p>PendingIntent和Intent</p><ol><li>可以去指明某一个“意图”，都可以用于启动活动、启动服务以及发送广播等</li><li>Intent更加倾向于去立即执行某个动作，而PendingIntent更加倾向于在某个合适的时机去执行某个动作。</li><li>可以把PendingIntent简单地理解为延迟执行的Intent。</li><li>获取PendingIntent的实例<ul><li>它主要提供了几个静态方法用于获取PendingIntent的实例，可以根据需求来选择是使用getActivity()方法、getBroadcast()方法，还是getService()方法。</li><li>这几个方法所接收的参数都是相同的，第一个参数依旧是Context。</li><li>第二个参数一般用不到，通常都是传入0即可。</li><li>第三个参数是一个Intent对象，我们可以通过这个对象构建出PendingIntent的“意图”。</li><li>第四个参数用于确定PendingIntent的行为，有FLAG_ONE_SHOT、FLAG_NO_CREATE、FLAG_CANCEL_CURRENT和FLAG_UPDATE_CURRENT这4种值可选，通常情况下这个参数传入0就可以了。</li></ul></li></ol></li><li><p>实现通知的点击效果</p><ul><li>创建PendingIntent的实例并且在NotificationCompat.Builder这个构造器后再连缀一个setContentIntent()方法</li></ul></li><li><p>对通知进行取消</p><ol><li><p>如果我们没有在代码中对该通知进行取消，它就会一直显示在系统的状态栏上。</p></li><li><p>解决的方法有两种，一种是在NotificationCompat.Builder中再连缀一个setAutoCancel()方法</p><ul><li>&#96;&#96;&#96;java<br> builder.setAutoCancel(true); <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 一种是显式地调用NotificationManager的cancel()方法将它取消</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">      //1是notify()方法接受的Id</span><br><span class="line">      manager.cancel(1);</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ol><h4 id="8-2-2-通知的进阶技巧"><a href="#8-2-2-通知的进阶技巧" class="headerlink" title="8.2.2 通知的进阶技巧"></a>8.2.2 通知的进阶技巧</h4><ol><li><p>NotificationCompat.Builder中提供了非常丰富的API来让我们创建出更加多样的通知效果。</p></li><li><p>setSound()方法</p><ul><li><p>它可以在通知发出的时候播放一段音频</p></li><li><p>setSound()方法接收一个Uri参数，所以在指定音频文件的时候还需要先获取到音频文件对应的URI</p></li><li><p>每个手机的&#x2F;system&#x2F;media&#x2F;audio&#x2F;ringtones目录下都有很多的音频文件，我们可以从中随便选一个音频文件</p></li><li><pre><code class="java">builder.setSound(Uri.fromFile(new File(&quot;/system/media/audio/ringtones/Luna.ogg&quot;)));<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 还可以在通知到来的时候让手机进行振动，使用的是vibrate这个属性</span><br><span class="line"></span><br><span class="line">   - 它是一个长整型的数组，用于设置手机静止和振动的时长，以毫秒为单位</span><br><span class="line"></span><br><span class="line">   - 下标为0的值表示手机静止的时长，下标为1的值表示手机振动的时长，下标为2的值又表示手机静止的时长，以此类推</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     builder.setVibrate(new long[]&#123;0, 1000, 1000, 1000&#125;);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>&#x3D;&#x3D;控制手机振动还需要声明权限&#x3D;&#x3D;</p><ul><li>&#96;&#96;&#96;xml<uses-permission android:name="android.permission.VIBRATE"/><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 在通知到来时控制手机LED灯的显示</span><br><span class="line"></span><br><span class="line">   - 使用setLights()方法来实现</span><br><span class="line"></span><br><span class="line">   - setLights()方法接收3个参数，第一个参数用于指定LED灯的颜色</span><br><span class="line"></span><br><span class="line">   - 第二个参数用于指定LED灯亮起的时长，以毫秒为单位</span><br><span class="line"></span><br><span class="line">   - 第三个参数用于指定LED灯暗去的时长，也是以毫秒为单位</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     builder.setLights(Color.GREEN, 1000, 1000);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>如果你不想进行那么多繁杂的设置，也可以直接使用通知的默认效果，它会根据当前手机的环境来决定播放什么铃声，以及如何振动</p><ul><li>&#96;&#96;&#96;java<br>builder.setDefaults(NotificationCompat.DEFAULT_ALL);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 8.2.3 通知的高级功能</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 继续观察NotificationCompat.Builder这个类，你会发现里面还有很多API是我们没有使用过的</span><br><span class="line"></span><br><span class="line">2. setStyle()方法</span><br><span class="line"></span><br><span class="line">   1. 这个方法允许我们构建出富文本的通知内容。也就是说通知中不光可以有文字和图标，还可以包含更多的东西。</span><br><span class="line"></span><br><span class="line">   2. setStyle()方法接收一个NotificationCompat.Style参数，这个参数就是用来构建具体的富文本信息的，如长文字、图片等。</span><br><span class="line"></span><br><span class="line">   3. 设置长文字</span><br><span class="line"></span><br><span class="line">      - ```java</span><br><span class="line">        builder.setStyle(new NotificationCompat.BigTextStyle().bigText(&quot;长文字&quot;));</span><br></pre></td></tr></table></figure><ul><li><p>在setStyle()方法中创建了一个NotificationCompat.BigTextStyle对象，这个对象就是用于封装长文字信息的</p></li><li><p>然后调用它的bigText()方法并将文字内容传入</p></li></ul></li></ul><ol start="4"><li><p>显示一张大图片</p><ul><li>&#96;&#96;&#96;java<br>builder.setStyle(new NotificationCompat.BigPictureStyle().bigPicture(BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher_background)));<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      - 在参数中创建了一个NotificationCompat.BigPictureStyle对象，这个对象就是用于设置大图片的</span><br><span class="line"></span><br><span class="line">      - 然后调用它的bigPicture()方法并将图片传入</span><br><span class="line"></span><br><span class="line">      - 事先准备好了一张图片，通过BitmapFactory的decodeResource()方法将图片解析成Bitmap对象，再传入到bigPicture()方法中</span><br><span class="line"></span><br><span class="line">3. setPriority()方法，它可以用于设置通知的重要程度</span><br><span class="line"></span><br><span class="line">   1. setPriority()方法接收一个整型参数用于设置这条通知的重要程度，一共有5个常量值可选</span><br><span class="line"></span><br><span class="line">   2. PRIORITY_DEFAULT表示默认的重要程度，和不设置效果是一样的</span><br><span class="line"></span><br><span class="line">   3. PRIORITY_MIN表示最低的重要程度，系统可能只会在特定的场景才显示这条通知，比如用户下拉状态栏的时候</span><br><span class="line"></span><br><span class="line">   4. PRIORITY_LOW表示较低的重要程度，系统可能会将这类通知缩小，或改变其显示的顺序，将其排在更重要的通知之后</span><br><span class="line"></span><br><span class="line">   5. PRIORITY_HIGH表示较高的重要程度，系统可能会将这类通知放大，或改变其显示的顺序，将其排在比较靠前的位置</span><br><span class="line"></span><br><span class="line">   6. PRIORITY_MAX表示最高的重要程度，这类通知消息必须要让用户立刻看到，甚至需要用户做出响应操作</span><br><span class="line"></span><br><span class="line">   7. ```java</span><br><span class="line">      builder.setPriority(NotificationCompat.PRIORITY_MAX);</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ol><h3 id="8-3-调用摄像头和相册"><a href="#8-3-调用摄像头和相册" class="headerlink" title="8.3 调用摄像头和相册"></a>8.3 调用摄像头和相册</h3><h4 id="8-3-1-调用摄像头拍照"><a href="#8-3-1-调用摄像头拍照" class="headerlink" title="8.3.1 调用摄像头拍照"></a>8.3.1 调用摄像头拍照</h4><ol><li><p>首先这里创建了一个File对象，用于存放摄像头拍下的图片，这里我们把图片命名为output_image.jpg，并将它存放在手机SD卡的应用关联缓存目录下</p><ol><li><p><strong>应用关联缓存目录:</strong> 就是指SD卡中专门用于存放当前应用缓存数据的位置，调用getExternalCacheDir()方法可以得到这个目录，具体的路径是&#x2F;sdcard&#x2F;Android&#x2F;data&#x2F;<package name>&#x2F;cache</p></li><li><p><strong>从Android 6.0系统开始，读写SD卡被列为了危险权限，如果将图片存放在SD卡的任何其他目录，都要进行运行时权限处理才行，而使用应用关联目录则可以跳过这一步</strong></p></li><li><p>&#96;&#96;&#96;java<br>File outputImage &#x3D; new File(getExternalCacheDir(), “output_image.jpg”);<br>try {<br>if (outputImage.exists()) {<br>    outputImage.delete();<br>}<br>outputImage.createNewFile();<br>}<br>catch (IOException e) {<br>e.printStackTrace();<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 接着会进行一个判断，如果运行设备的系统版本低于Android 7.0，就调用Uri的fromFile()方法将File对象转换成Uri对象，这个Uri对象标识着output_image.jpg这张图片的本地真实路径。否则，就调用FileProvider的getUriForFile()方法将File对象转换成一个封装过的Uri对象</span><br><span class="line"></span><br><span class="line">   1. getUriForFile()方法接收3个参数，第一个参数要求传入Context对象</span><br><span class="line"></span><br><span class="line">   2. 第二个参数可以是任意唯一的字符串</span><br><span class="line"></span><br><span class="line">   3. 第三个参数则是我们刚刚创建的File对象</span><br><span class="line"></span><br><span class="line">   4. 之所以要进行这样一层转换，是因为从Android 7.0系统开始，直接使用本地真实路径的Uri被认为是不安全的，会抛出一个FileUriExposedException异常。而FileProvider则是一种特殊的内容提供器，它使用了和内容提供器类似的机制来对数据进行保护，可以选择性地将封装过的Uri共享给外部，从而提高了应用的安全性。</span><br><span class="line"></span><br><span class="line">   5. ```java</span><br><span class="line">      //Android 7.0</span><br><span class="line">      if (Build.VERSION.SDK_INT &gt;= 24) &#123;</span><br><span class="line">          imageUri = FileProvider.getUriForFile(MainActivity.this, &quot;com.xuan.cameraalbumtext.fileprivider&quot;, outputImage);</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">          imageUri = Uri.fromFile(outputImage);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>接下来构建出了一个Intent对象，并将这个Intent的action指定为android.media. action.IMAGE_CAPTURE，再调用Intent的putExtra()方法指定图片的输出地址，这里填入刚刚得到的Uri对象，最后调用startActivityForResult()来启动活动。由于我们使用的是一个隐式Intent，系统会找出能够响应这个Intent的活动去启动，这样照相机程序就会被打开，拍下的照片将会输出到output_image.jpg中。</p><ul><li>&#96;&#96;&#96;java<br>&#x2F;&#x2F;启动相机程序<br>Intent intent &#x3D; new Intent(“android.media.action.IMAGE_CAPTURE”);<br>&#x2F;&#x2F;指定图片的输入地址<br>intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);<br>startActivityForResult(intent, TAKE_PHOTO);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 刚才我们是使用startActivityForResult()来启动活动的，因此拍完照后会有结果返回到onActivityResult()方法中。如果发现拍照成功，就可以调用BitmapFactory的decodeStream()方法将output_image.jpg这张照片解析成Bitmap对象，然后把它设置到Image-View中显示出来。</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     switch (requestCode) &#123;</span><br><span class="line">         case TAKE_PHOTO:</span><br><span class="line">             if (resultCode == RESULT_OK) &#123;</span><br><span class="line">                 try &#123;</span><br><span class="line">                     //将拍摄的照片显示出来</span><br><span class="line">                     Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri));</span><br><span class="line">                     picture.setImageBitmap(bitmap);</span><br><span class="line">                 &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             break;</span><br><span class="line">         default:</span><br><span class="line">             break;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在AndroidManifest.xml中对内容提供器进行注册</p><ol><li><p>android:name属性的值是固定的</p></li><li><p>android:authorities属性的值必须要和刚才FileProvider.getUriForFile()方法中的第二个参数一致</p></li><li><p>这里还在<provider>标签的内部使用<meta-data>来指定Uri的共享路径，并引用了一个@xml&#x2F;file_paths资源，下面我们来创建这个资源</p></li><li><pre><code class="xml">&lt;provider          android:authorities=&quot;com.xuan.cameraalbumtest.fileprovider&quot;          android:name=&quot;androidx.core.content.FileProvider&quot;          android:exported=&quot;false&quot;          android:grantUriPermissions=&quot;true&quot;&gt;    &lt;meta-data               android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;               android:resource=&quot;@xml/file_paths&quot;/&gt;&lt;/provider&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. 右击res目录→New→Directory，创建一个xml目录，接着右击xml目录→New→File，创建一个file_paths.xml文件</span><br><span class="line"></span><br><span class="line">   1. external-path就是用来指定Uri共享的</span><br><span class="line"></span><br><span class="line">   2. name属性的值可以随便填</span><br><span class="line"></span><br><span class="line">   3. path属性的值表示共享的具体路径</span><br><span class="line"></span><br><span class="line">      - 这里设置**&quot;.&quot;**表示该根目录下所有的文件夹都可以临时授权访问的。当然你也可以仅共享我们存放output_image.jpg这张图片的路径。</span><br><span class="line"></span><br><span class="line">   4. ```xml</span><br><span class="line">      &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">      &lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">          &lt;external-path</span><br><span class="line">              name=&quot;my_images&quot;</span><br><span class="line">              path=&quot;.&quot;/&gt;</span><br><span class="line">      &lt;/paths&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p><strong>还有一点要注意，在Android 4.4系统之前，访问SD卡的应用关联目录也是要声明权限的，从4.4系统开始不再需要权限声明。那么我们为了能够兼容老版本系统的手机，还需要在AndroidManifest.xml中声明一下访问SD卡的权限：</strong></p><ul><li>&#96;&#96;&#96;xml<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 8.3.2 从相册中选择照片</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 进行一个运行时权限处理，动态申请WRITE_EXTERNAL_STORAGE这个危险权限</span><br><span class="line"></span><br><span class="line">   1. 相册中的照片都是存储在SD卡上的，我们要从SD卡中读取照片就需要申请这个权限</span><br><span class="line"></span><br><span class="line">   2. WRITE_EXTERNAL_STORAGE表示同时授予程序对SD卡读和写的能力</span><br><span class="line"></span><br><span class="line">   3. ```java</span><br><span class="line">      if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">          ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">          openAlbum();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>&#96;&#96;&#96;java<br>@Override<br>public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {<br>super.onRequestPermissionsResult(requestCode, permissions, grantResults);<br>switch (requestCode) {<br>    case 1:<br>        if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] &#x3D;&#x3D; PackageManager.PERMISSION_GRANTED) {<br>            openAlbum();<br>        }<br>        else {<br>            Toast.makeText(this, “You denied the permission”, Toast.LENGTH_SHORT).show();<br>        }<br>        break;<br>    default:<br>        break;<br>}<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 授权了权限申请之后调用openAlbum()方法，这里我们先是构建出了一个Intent对象，并将它的action指定为android.intent.action.GET_CONTENT。接着给这个Intent对象设置一些必要的参数，然后调用startActivityForResult()方法</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     private void openAlbum()  &#123;</span><br><span class="line">         Intent intent = new Intent(&quot;android.intent.action.GET_CONTENT&quot;);</span><br><span class="line">         intent.setType(&quot;image/*&quot;);</span><br><span class="line">         //打开相册</span><br><span class="line">         startActivityForResult(intent, CHOOSE_PHOTO);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>为了兼容新老版本的手机，我们做了一个判断，如果是4.4及以上系统的手机就调用handleImageOnKitKat()方法来处理图片，否则就调用handleImageBeforeKitKat()方法来处理图片</p><ol><li><p><strong>Android系统从4.4版本开始，选取相册中的图片不再返回图片真实的Uri了，而是一个封装过的Uri，因此如果是4.4版本以上的手机就需要对这个Uri进行解析才行。</strong></p></li><li><p>这里有好几种判断情况，如果返回的Uri是document类型的话，那就取出document id进行处理，如果不是的话，那就使用普通的方式处理。</p></li><li><p>如果Uri的authority是media格式的话，document id还需要再进行一次解析，要通过字符串分割的方式取出后半部分才能得到真正的数字id。取出的id用于构建新的Uri和条件语句，然后把这些值作为参数传入到getImagePath()方法当中，就可以获取到图片的真实路径了</p></li><li><pre><code class="java">@Overrideprotected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123;    super.onActivityResult(requestCode, resultCode, data);    switch (requestCode) &#123;        case TAKE_PHOTO:            //...            break;        case CHOOSE_PHOTO:            if (requestCode == RESULT_OK) &#123;                //判断手机系统版本号                if (Build.VERSION.SDK_INT &gt;= 19) &#123;                    //4.4及以上系统使用这个方法处理图片                    handleImageOnKitKat(data);                &#125;                else &#123;                    hanldeImageBeforeKitKat(data);                &#125;            &#125;        default:            break;    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. ```java</span><br><span class="line">   private void handleImageOnKitKat(Intent data) &#123;</span><br><span class="line">       String imagePath = null;</span><br><span class="line">       Uri uri = data.getData();</span><br><span class="line">       if (DocumentsContract.isDocumentUri(this, uri)) &#123;</span><br><span class="line">           //如果是document类型的Uri,则通过document id处理</span><br><span class="line">           String docId = DocumentsContract.getDocumentId(uri);</span><br><span class="line">           if (&quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority())) &#123;</span><br><span class="line">               //解析出数字格式的id</span><br><span class="line">               String id = docId.split(&quot;:&quot;)[1];</span><br><span class="line">               String selection = MediaStore.Images.Media._ID + &quot;=&quot; + id;</span><br><span class="line">               imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);</span><br><span class="line">           &#125;</span><br><span class="line">           else if (&quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority())) &#123;</span><br><span class="line">               Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;), Long.valueOf(docId));</span><br><span class="line">               imagePath = getImagePath(contentUri, null);</span><br><span class="line">           &#125;</span><br><span class="line">           else if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">               //如果是content类型的Uri,则使用普通方式处理</span><br><span class="line">               imagePath = getImagePath(uri, null);</span><br><span class="line">           &#125;</span><br><span class="line">           else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">               //如果是file类型的Uri,则直接获取图片路径即可</span><br><span class="line">               imagePath = uri.getPath();</span><br><span class="line">           &#125;</span><br><span class="line">           //根据图片路径显示图片</span><br><span class="line">           displayImage(imagePath);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>&#96;&#96;&#96;java<br>private void hanldeImageBeforeKitKat(Intent data) {<br>Uri uri &#x3D; data.getData();<br>String imagePath &#x3D; getImagePath(uri, null);<br>displayImage(imagePath);<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. ```java</span><br><span class="line">   @SuppressLint(&quot;Range&quot;)</span><br><span class="line">   private String getImagePath(Uri uri, String selection) &#123;</span><br><span class="line">       String path = null;</span><br><span class="line">       //通过Uri和selection来获取真是的图片路径</span><br><span class="line">       Cursor cursor = getContentResolver().query(uri, null, selection, null, null);</span><br><span class="line">       if (cursor != null) &#123;</span><br><span class="line">           if (cursor.moveToFirst()) &#123;</span><br><span class="line">               path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA));</span><br><span class="line">           &#125;</span><br><span class="line">           cursor.close();</span><br><span class="line">       &#125;</span><br><span class="line">       return path;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>拿到图片的路径之后，再调用displayImage()方法将图片显示到界面上</p><ul><li>&#96;&#96;&#96;java<br>private void displayImage(String imagePath) {<br>if (imagePath !&#x3D; null) {<br>    Bitmap bitmap &#x3D; BitmapFactory.decodeFile(imagePath);<br>    picture.setImageBitmap(bitmap);<br>}<br>else {<br>    Toast.makeText(this, “failed to get iamge”, Toast.LENGTH_SHORT).show();<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. **某些照片即使经过裁剪后体积仍然很大，直接加载到内存中有可能会导致程序崩溃。更好的做法是根据项目的需求先对照片进行适当的压缩，然后再加载到内存中。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 8.4 播放多媒体文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 8.4.1 播放音频</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 在Android中播放音频文件一般都是使用MediaPlayer类来实现的，它对多种格式的音频文件提供了非常全面的控制方法</span><br><span class="line"></span><br><span class="line">2. MediaPlayer类中一些较为常用的控制方法</span><br><span class="line">   - ![image-20220802154150357](第一行代码Android.assets/image-20220802154150357.png)</span><br><span class="line"></span><br><span class="line">3. MediaPlayer的工作流程</span><br><span class="line"></span><br><span class="line">   1. 首先需要创建出一个MediaPlayer对象</span><br><span class="line"></span><br><span class="line">   2. 动态申请WRITE_EXTERNAL_STORAGE权限</span><br><span class="line"></span><br><span class="line">      1. **我们会在SD卡中放置一个音频文件，程序为了播放这个音频文件必须拥有访问SD卡的权限才行**</span><br><span class="line"></span><br><span class="line">      2. ```java</span><br><span class="line">         if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">             ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1);</span><br><span class="line">         &#125;</span><br><span class="line">         else &#123;</span><br><span class="line">             initMediaPlayer();</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>&#96;&#96;&#96;java<br>@Override<br>public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {<br>super.onRequestPermissionsResult(requestCode, permissions, grantResults);<br>switch (requestCode) {<br>    case 1:<br>        if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] &#x3D;&#x3D; PackageManager.PERMISSION_GRANTED) {<br>            initMediaPlayer();<br>        }<br>        else {<br>            Toast.makeText(this, “拒绝权限将无法使用程序”, Toast.LENGTH_SHORT).show();<br>            finish();<br>        }<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 然后调用setDataSource()方法来设置音频文件的路径</span><br><span class="line"></span><br><span class="line">4. 再调用prepare()方法使MediaPlayer进入到准备状态</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     private void initMediaPlayer() &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             File file = new File(Environment.getExternalStorageDirectory(), &quot;music.mp3&quot;);</span><br><span class="line">             //指定音频文件的路径</span><br><span class="line">             mediaPlayer.setDataSource(file.getPath());</span><br><span class="line">             //让MediaPlayer进入到准备状态</span><br><span class="line">             mediaPlayer.prepare();</span><br><span class="line">         &#125;</span><br><span class="line">         catch (Exception e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="5"><li><p>接下来调用start()方法就可以开始播放音频</p></li><li><p>调用pause()方法就会暂停播放</p></li><li><p>调用reset()方法就会停止播放</p><ul><li>&#96;&#96;&#96;java<br> @Override<br> public void onClick(View view) {<br> switch (view.getId()) {<br>     case R.id.play:<br>         if (!mediaPlayer.isPlaying()) {<br>             &#x2F;&#x2F;开始播放<br>             mediaPlayer.start();<br>         }<br>         break;<br>     case R.id.pause:<br>         if (mediaPlayer.isPlaying()) {<br>             mediaPlayer.pause();<br>         }<br>         break;<br>     case R.id.stop:<br>         if (mediaPlayer.isPlaying()) {<br>             &#x2F;&#x2F;调用reset()方法将MediaPlayer重置为刚刚创建的状态<br>             mediaPlayer.reset();<br>             initMediaPlayer();<br>         }<br>     default:<br>         break;<br> }<br> } <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">8. 最后在onDestroy()方法中，我们还需要分别调用stop()方法和release()方法，将与MediaPlayer相关的资源释放掉</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">      @Override</span><br><span class="line">      protected void onDestroy() &#123;</span><br><span class="line">          super.onDestroy();</span><br><span class="line">          if (mediaPlayer != null) &#123;</span><br><span class="line">              mediaPlayer.stop();</span><br><span class="line">              mediaPlayer.release();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><p>在AndroidManifest.xml文件中声明用到的权限</p><ul><li>&#96;&#96;&#96;xml<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. **stop()从内存中清除缓冲的音乐，而pause()则不清除。尽可能多地释放内存是一种很好的做法。它会让你的应用保持稳定。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 8.4.2 播放视频</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 主要是使用VideoView类来实现的。这个类将视频的显示和控制集于一身</span><br><span class="line"></span><br><span class="line">2. VideoView的常用方法:</span><br><span class="line"></span><br><span class="line">   - ![image-20220802174940400](第一行代码Android.assets/image-20220802174940400.png)</span><br><span class="line"></span><br><span class="line">3. VideoView工作流程</span><br><span class="line"></span><br><span class="line">   1. 首先创建VideoView对象</span><br><span class="line"></span><br><span class="line">      - ```java</span><br><span class="line">        VideoView videoView = findViewById(R.id.video_view);</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p>动态申请权限</p><ul><li>&#96;&#96;&#96;java<br>if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) !&#x3D; PackageManager.PERMISSION_GRANTED) {<br>ActivityCompat.requestPermissions(MainActivity.this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1);<br>}<br>else {<br>initVideoPath();<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  @Override</span><br><span class="line">  public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;</span><br><span class="line">      super.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">      switch (requestCode) &#123;</span><br><span class="line">          case 1:</span><br><span class="line">              if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                  initVideoPath();</span><br><span class="line">              &#125;</span><br><span class="line">              else &#123;</span><br><span class="line">                  Toast.makeText(this, &quot;拒绝权限将无法使用程序&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                  finish();</span><br><span class="line">              &#125;</span><br><span class="line">          default:</span><br><span class="line">              break;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>初始化</p><ul><li>&#96;&#96;&#96;java<br>private void initVideoPath() {<br>File file &#x3D; new File(Environment.getExternalStorageDirectory(), “movie.mp4”);<br>&#x2F;&#x2F;指定视频文件的路径<br>videoView.setVideoPath(file.getPath());<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 调用start()等方法</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     @Override</span><br><span class="line">     public void onClick(View view) &#123;</span><br><span class="line">         switch (view.getId()) &#123;</span><br><span class="line">             case R.id.play:</span><br><span class="line">                 if (!videoView.isPlaying()) &#123;</span><br><span class="line">                     videoView.start();</span><br><span class="line">                 &#125;</span><br><span class="line">                 break;</span><br><span class="line">             case R.id.pause:</span><br><span class="line">                 if (videoView.isPlaying()) &#123;</span><br><span class="line">                     videoView.pause();</span><br><span class="line">                 &#125;</span><br><span class="line">                 break;</span><br><span class="line">             case R.id.replay:</span><br><span class="line">                 if (videoView.isPlaying()) &#123;</span><br><span class="line">                     //重新播放</span><br><span class="line">                     videoView.resume();</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>释放资源</p><ul><li>&#96;&#96;&#96;java<br>@Override<br>protected void onDestroy() {<br>super.onDestroy();<br>if (videoView !&#x3D; null) {<br>    videoView.suspend();<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 在AndroidManifest.xml文件中声明用到的权限</span><br><span class="line"></span><br><span class="line">   - ```xml</span><br><span class="line">     &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><p><strong>为什么VideoView的用法和MediaPlayer这么相似呢？</strong></p><ol><li>VideoView只是帮我们做了一个很好的封装而已，它的背后仍然是使用MediaPlayer来对视频文件进行控制的。</li></ol></li><li><p>&#x3D;&#x3D;另外需要注意&#x3D;&#x3D;，VideoView并不是一个万能的视频播放工具类，它在视频格式的支持以及播放效率方面都存在着较大的不足。所以，如果想要仅仅使用VideoView就编写出一个功能非常强大的视频播放器是不太现实的。但是如果只是用于播放一些游戏的片头动画，或者某个应用的视频宣传，使用VideoView还是绰绰有余的。</p></li></ol><h3 id="8-5-小结与点评"><a href="#8-5-小结与点评" class="headerlink" title="8.5 小结与点评"></a>8.5 小结与点评</h3><h2 id="第9章-看看精彩的世界——使用网络技术"><a href="#第9章-看看精彩的世界——使用网络技术" class="headerlink" title="第9章 看看精彩的世界——使用网络技术"></a>第9章 看看精彩的世界——使用网络技术</h2><ul><li><strong>如何在手机端使用HTTP协议和服务器端进行网络交互，并对服务器返回的数据进行解析</strong></li></ul><h3 id="9-1-WebView的用法"><a href="#9-1-WebView的用法" class="headerlink" title="9.1 WebView的用法"></a>9.1 WebView的用法</h3><ol><li><p>在应用程序里展示一些网页</p></li><li><p>WebView控件，借助它我们就可以在自己的应用程序里嵌入一个浏览器，从而非常轻松地展示各种各样的网页</p></li><li><pre><code class="java">WebView webView = findViewById(R.id.web_view);webView.getSettings().setJavaScriptEnabled(true);webView.setWebViewClient(new WebViewClient());webView.loadUrl(&quot;http://www.baidu.com&quot;);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   1. 首先使用findViewById()方法获取到了WebView的实例</span><br><span class="line">   2. 然后调用WebView的getSettings()方法可以去设置一些浏览器的属性</span><br><span class="line">      - 这里我们并不去设置过多的属性，只是调用了setJavaScriptEnabled()方法来让WebView支持JavaScript脚本</span><br><span class="line">   3. 调用WebView的setWebViewClient()方法，并传入了一个WebViewClient的实例</span><br><span class="line">      - 这段代码的作用是，当需要从一个网页跳转到另一个网页时，我们希望目标网页仍然在当前WebView中显示，而不是打开系统浏览器</span><br><span class="line">   4. 调用WebView的loadUrl()方法，并将网址传入，即可展示相应网页的内容</span><br><span class="line"></span><br><span class="line">4. 由于使用到了网络功能，而访问网络是需要声明权限的，因此我们还得修改AndroidManifest.xml文件，并加入权限声明</span><br><span class="line"></span><br><span class="line">   - ```xml</span><br><span class="line">     &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p><strong>向百度的服务器发起了一条HTTP请求，接着服务器分析出我们想要访问的是百度的首页，于是会把该网页的HTML代码进行返回，然后WebView再调用手机浏览器的内核对返回的HTML代码进行解析，最终将页面展示出来</strong></p></li></ol><h3 id="9-2-使用HTTP协议访问网络"><a href="#9-2-使用HTTP协议访问网络" class="headerlink" title="9.2 使用HTTP协议访问网络"></a>9.2 使用HTTP协议访问网络</h3><ol><li>工作原理<ul><li>客户端向服务器发出一条HTTP请求，服务器收到请求之后会返回一些数据给客户端，然后客户端再对这些数据进行解析和处理</li></ul></li></ol><h4 id="9-2-1-使用HttpURLConnection"><a href="#9-2-1-使用HttpURLConnection" class="headerlink" title="9.2.1 使用HttpURLConnection"></a>9.2.1 使用HttpURLConnection</h4><ol><li><p>在过去，Android上发送HTTP请求一般有两种方式：HttpURLConnection和HttpClient</p><ul><li>不过由于HttpClient存在API数量过多、扩展困难等缺点，Android团队越来越不建议我们使用这种方式。终于在Android 6.0系统中，HttpClient的功能被完全移除了</li></ul></li><li><p>首先需要获取到HttpURLConnection的实例</p><ul><li>一般只需new出一个URL对象，并传入目标的网络地址，然后调用一下openConnection()方法即可</li></ul></li><li><p>得到了HttpURLConnection的实例之后，我们可以设置一下HTTP请求所使用的方法</p><ul><li>常用的方法主要有两个：GET和POST。GET表示希望从服务器那里获取数据，而POST则表示希望提交数据给服务器</li></ul></li><li><p>自由定制</p><ul><li>比如设置连接超时、读取超时的毫秒数，以及服务器希望得到的一些消息头等</li></ul></li><li><p>之后再调用getInputStream()方法就可以获取到服务器返回的输入流了，剩下的任务就是对输入流进行读取</p></li><li><p>最后可以调用disconnect()方法将这个HTTP连接关闭掉</p></li><li><pre><code class="java">private void sendRequestWithHttpURLConnection() &#123;    //开启线程来发起网络请求    new Thread(new Runnable() &#123;        @Override        public void run() &#123;            HttpURLConnection connection = null;            BufferedReader reader = null;            try &#123;                URL url = new URL(&quot;https://www.baidu.com&quot;);                connection = (HttpURLConnection) url.openConnection();                connection.setRequestMethod(&quot;GET&quot;);                connection.setConnectTimeout(8000);                connection.setReadTimeout(8000);                InputStream in = connection.getInputStream();                //对获取到的输入流进行读取                reader = new BufferedReader(new InputStreamReader(in));                StringBuffer response = new StringBuffer();                String line;                while ((line = reader.readLine()) != null) &#123;                    response.append(line);                &#125;                showResponse(response.toString());            &#125;            catch (Exception e) &#123;                e.printStackTrace();            &#125;            finally &#123;                if (reader != null) &#123;                    try &#123;                        reader.close();                    &#125;                    catch (IOException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                if (connection != null) &#123;                    connection.disconnect();                &#125;            &#125;        &#125;    &#125;).start();&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">8. ```java</span><br><span class="line">   private void showResponse(final String response) &#123;</span><br><span class="line">       runOnUiThread(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               //进行UI操作,将结果显示到界面上</span><br><span class="line">               responseText.setText(response);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>- **为什么要用这个runOnUiThread()方法呢？这是因为==Android是不允许在子线程中进行UI操作的==，我们需要通过这个方法将线程切换到主线程，然后再更新UI元素**</code></pre></li><li><p>ScrollView</p><ul><li>借助ScrollView控件的话，我们就可以以滚动的形式查看屏幕外的那部分内容</li></ul></li><li><p>声明网络权限</p><ul><li>&#96;&#96;&#96;xml<uses-permission android:name="android.permission.INTERNET"/><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">11. 提交数据给服务器</span><br><span class="line"></span><br><span class="line">    1. 将HTTP请求的方法改成POST，并在获取输入流之前把要提交的数据写出即可。==注意==每条数据都要以**键值对**的形式存在，数据与数据之间用“&amp;”符号隔开</span><br><span class="line"></span><br><span class="line">    2. ```java</span><br><span class="line">       connection.setRequestMethod(&quot;POST&quot;);</span><br><span class="line">       DataOutputStream out = new DataOutputStream(connection.getOutPutStream());</span><br><span class="line">       out.writeBytes(&quot;username=admin&amp;password=123&quot;);</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="9-2-2-使用OkHttp"><a href="#9-2-2-使用OkHttp" class="headerlink" title="9.2.2 使用OkHttp"></a>9.2.2 使用OkHttp</h4><ol><li><p>有许多出色的网络通信库都可以替代原生的HttpURLConnection，而其中OkHttp无疑是做得最出色的一个</p><ol><li>OkHttp是由鼎鼎大名的Square公司开发的，这个公司在开源事业上面贡献良多，除了OkHttp之外，还开发了像Picasso、Retrofit等著名的开源项目</li><li>OkHttp不仅在接口封装上面做得简单易用，就连在底层实现上也是自成一派，比起原生的HttpURLConnection，可以说是有过之而无不及，现在已经成了广大Android开发者首选的网络通信库</li><li>OkHttp的项目主页地址是：<a href="https://github.com/square/okhttp">https://github.com/square/okhttp</a></li></ol></li><li><p>在使用OkHttp之前，我们需要先在项目中添加OkHttp库的依赖。编辑app&#x2F;build.gradle文件，在dependencies闭包中添加如下内容：</p><ul><li>&#96;&#96;&#96;json<br>dependencies {<br>implementation ‘com.squareup.okhttp3:okhttp:4.9.0’<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - 添加上述依赖会自动下载两个库，一个是OkHttp库，一个是Okio库，后者是前者的通信基础</span><br><span class="line"></span><br><span class="line">3. OkHttp的具体用法</span><br><span class="line"></span><br><span class="line">   1. 首先需要创建一个OkHttpClient的实例</span><br><span class="line"></span><br><span class="line">      - ```java</span><br><span class="line">        OkHttpClient client = new OkHttpClient();</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p>如果想要发起一条HTTP请求，就需要创建一个Request对象</p><ul><li>&#96;&#96;&#96;java<br>Request request &#x3D; new Request.Builder().build();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 我们可以在最终的build()方法之前连缀很多其他方法来丰富这个Request对象。比如可以通过url()方法来设置目标的网络地址</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    Request request = new Request.Builder()</span><br><span class="line">        .url(&quot;https://www.baidu.com&quot;)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>之后调用OkHttpClient的newCall()方法来创建一个Call对象，并调用它的execute()方法来发送请求并获取服务器返回的数据</p><ul><li>&#96;&#96;&#96;java<br>Response response &#x3D; client.newCall(request).execute();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 其中Response对象就是服务器返回的数据，我们可以使用如下写法来得到返回的具体内容</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    String responseData = response.body().string();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果是发起一条POST请求会比GET请求稍微复杂一点，我们需要先构建出一个RequestBody对象来存放待提交的参数</p><ul><li>&#96;&#96;&#96;java<br>RequestBody requestBody &#x3D; new FormBody.Builder()<br>.add(“username”, “admin”)<br>.add(“password”, “123”)<br>.build();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. 然后在Request.Builder中调用一下post()方法，并将RequestBody对象传入</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     Request request = new Request.Builder()</span><br><span class="line">         .url(&quot;https://www.baidu.com&quot;)</span><br><span class="line">         .post(requestBody)</span><br><span class="line">         .build();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>接下来的操作就和GET请求一样了，调用execute()方法来发送请求并获取服务器返回的数据即可</p></li><li><pre><code class="java">private void sendRequestWithOkHttp() &#123;    new Thread(new Runnable() &#123;        @Override        public void run() &#123;            try &#123;                OkHttpClient client = new OkHttpClient();                Request request = new Request.Builder()                    .url(&quot;https://www.baidu.com&quot;)                    .build();                Response response = client.newCall(request).execute();                String responseData = response.body().string();                showResponse(responseData);            &#125;            catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;).start();&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 9.3 解析XML格式数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 通常情况下，每个需要访问网络的应用程序都会有一个自己的服务器，我们可以向服务器提交数据，也可以从服务器上获取数据</span><br><span class="line"></span><br><span class="line">2. 这些数据到底要以什么样的格式在网络上传输呢？</span><br><span class="line"></span><br><span class="line">   - 一般我们都会在网络上传输一些格式化后的数据，这种数据会有一定的结构规格和语义，当另一方收到数据消息之后就可以按照相同的结构规格进行解析，从而取出他想要的那部分内容</span><br><span class="line"></span><br><span class="line">3. 在网络上传输数据时最常用的格式有两种：XML和JSON</span><br><span class="line"></span><br><span class="line">4. 从哪儿才能获取一段XML格式的数据呢？</span><br><span class="line"></span><br><span class="line">   - 搭建一个最简单的Web服务器，在这个服务器上提供一段XML文本，然后我们在程序里去访问这个服务器，再对得到的XML文本进行解析</span><br><span class="line"></span><br><span class="line">5. 搭建Web服务器</span><br><span class="line"></span><br><span class="line">   1. 准备使用Apache服务器</span><br><span class="line"></span><br><span class="line">   2. Apache服务器的安装包，官方下载地址是：http://httpd.apache.org/download.cgi</span><br><span class="line"></span><br><span class="line">   3. 点击链接**a number of third party vendors**</span><br><span class="line"></span><br><span class="line">   4. 找到**Downloading Apache for Windows** 点击**ApacheHaus**链接</span><br><span class="line"></span><br><span class="line">   5. 点击图标即可开始下载，x86是32位的，x64是64位的，根据自己的操作系统选择下载</span><br><span class="line"></span><br><span class="line">   6. 保存到想要保存的位置，解压压缩包，打开httpd.conf文件（.\Apache24\conf下）</span><br><span class="line"></span><br><span class="line">      - 修改Apache安装目录，（其中“$&#123;SRVROOT&#125;”指定义的SRVROOT路径变量）</span><br><span class="line"></span><br><span class="line">      - ```shell</span><br><span class="line">        Define SRVROOT &quot;E:\Program Files (x86)\Apache\Apache24&quot;</span><br><span class="line">        ServerRoot &quot;$&#123;SRVROOT&#125;&quot;</span><br></pre></td></tr></table></figure>- 修改端口号- ```shell  Listen 8080  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. 配置安装Apache的主服务，打开cmd(以管理员身份运行)，复制输入&quot;E:\Program Files (x86)\Apache\Apache24\bin\httpd.exe&quot; -k install -n apache，该命令意思是安装Apache服务，并将该服务命名为“apache”</span><br><span class="line"></span><br><span class="line">8. 启动Apache服务：双击运行bin目录下的ApacheMonitor.exe</span><br><span class="line"></span><br><span class="line">9. 测试Apache服务器是否可用http://localhost:8080</span><br><span class="line"></span><br><span class="line">10. 接下来进入到.\Apache24\htdocs目录下，在这里新建一个名为get_data.xml的文件</span><br><span class="line"></span><br><span class="line">    - ```xml</span><br><span class="line">      &lt;apps&gt;</span><br><span class="line">          &lt;app&gt;</span><br><span class="line">              &lt;id&gt;1&lt;/id&gt;</span><br><span class="line">              &lt;name&gt;Google Maps&lt;/name&gt;</span><br><span class="line">              &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">          &lt;/app&gt;</span><br><span class="line">      &lt;/apps&gt;</span><br></pre></td></tr></table></figure> - VSCode在cmd中启动   - ```shell     code get_data.xml     code .     <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. **Android P(API 28)全面禁止了非https链接，并严格审查网站的CA证书**</span><br><span class="line"></span><br><span class="line">   1. 在res文件夹下新建目录xml，然后创建文件`network_security_config.xml`(这个名字可以自定义，旨在开启http请求)</span><br><span class="line"></span><br><span class="line">      - ```xml</span><br><span class="line">         &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line">         &lt;network-security-config&gt;</span><br><span class="line">             &lt;base-config cleartextTrafficPermitted=&quot;true&quot;/&gt;</span><br><span class="line">         &lt;/network-security-config&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>然后在AndroidManifest.xml文件的Application标签添加属性</p><ul><li>&#96;&#96;&#96;xml<br> <application android:networkSecurityConfig="@xml/network_security_config"></application> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   3. **模拟机访问127.0.0.1来访问，都是访问模拟器本身。你想在模拟器上面访问安装模拟器的电脑，那么就使android内置的IP：10.0.2.2 。10.0.2.2 是模拟器设置的特定ip，是你的电脑的别名。**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 9.3.1 Pull解析方式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 解析XML格式的数据其实也有挺多种方式的，比较常用的两种，Pull解析和SAX解析</span><br><span class="line"></span><br><span class="line">2. 首先要获取到一个XmlPullParserFactory的实例，并借助这个实例得到XmlPullParser对象，然后调用XmlPullParser的setInput()方法将服务器返回的XML数据设置进去就可以开始解析了</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     XmlPullParserFactory factory = XmlPullParserFactory.newInstance();</span><br><span class="line">     XmlPullParser xmlPullParser = factory.newPullParser();</span><br><span class="line">     xmlPullParser.setInput(new StringReader(xmlData));</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><p>通过getEventType()可以得到当前的解析事件</p><ul><li>&#96;&#96;&#96;java<br>int eventType &#x3D; xmlPullParser.getEventType();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 然后在一个while循环中不断地进行解析，如果当前的解析事件不等于XmlPullParser.END_DOCUMENT，说明解析工作还没完成，调用next()方法后可以获取下一个解析事件</span><br><span class="line"></span><br><span class="line">5. 在while循环中，我们通过getName()方法得到当前节点的名字，如果发现节点名等于id、name或version，就调用nextText()方法来获取节点内具体的内容，每当解析完一个app节点后就将获取到的内容打印出来</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     while (eventType != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">         String nodeName = xmlPullParser.getName();</span><br><span class="line">         switch (eventType) &#123;</span><br><span class="line">                 //开始解析某个节点</span><br><span class="line">             case XmlPullParser.START_TAG: &#123;</span><br><span class="line">                 if (&quot;id&quot;.equals(nodeName)) &#123;</span><br><span class="line">                     id = xmlPullParser.nextText();</span><br><span class="line">                 &#125;</span><br><span class="line">                 else if (&quot;name&quot;.equals(nodeName)) &#123;</span><br><span class="line">                     name = xmlPullParser.nextText();</span><br><span class="line">                 &#125;</span><br><span class="line">                 else if (&quot;version&quot;.equals(nodeName)) &#123;</span><br><span class="line">                     version = xmlPullParser.nextText();</span><br><span class="line">                 &#125;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">                 //完成解析某个节点</span><br><span class="line">             case XmlPullParser.END_TAG: &#123;</span><br><span class="line">                 if (&quot;app&quot;.equals(nodeName)) &#123;</span><br><span class="line">                     Log.d(&quot;TAG&quot;, &quot;parseXMLWithPull: id is &quot; + id);</span><br><span class="line">                     Log.d(&quot;TAG&quot;, &quot;parseXMLWithPull: name is &quot; + name);</span><br><span class="line">                     Log.d(&quot;TAG&quot;, &quot;parseXMLWithPull: version is &quot; + version);</span><br><span class="line">                 &#125;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">             default:</span><br><span class="line">                 break;</span><br><span class="line">         &#125;</span><br><span class="line">         eventType = xmlPullParser.next();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="9-3-2-SAX解析方式"><a href="#9-3-2-SAX解析方式" class="headerlink" title="9.3.2 SAX解析方式"></a>9.3.2 SAX解析方式</h4><ol><li><p>SAX解析也是一种特别常用的XML解析方式，虽然它的用法比Pull解析要复杂一些，但在语义方面会更加清楚</p></li><li><p>通常情况下我们都会新建一个类继承自DefaultHandler，并重写父类的5个方法</p><ol><li>startDocument()方法会在开始XML解析的时候调用</li><li>startElement()方法会在开始解析某个节点的时候调用</li><li>characters()方法会在获取节点中内容的时候调用</li><li>endElement()方法会在完成解析某个节点的时候调用</li><li>endDocument()方法会在完成整个XML解析的时候调用</li><li>startElement()、characters()和endElement()这3个方法是有参数的，从XML中解析出的数据就会以参数的形式传入到这些方法中</li><li>&#x3D;&#x3D;需要注意的是&#x3D;&#x3D;，在获取节点中的内容时，characters()方法可能会被调用多次，一些换行符也被当作内容解析出来，我们需要针对这种情况在代码中做好控制</li></ol></li><li><p>&#96;&#96;&#96;java<br>private void parseXMLWithSAX(String xmlData) {<br>try {<br>    SAXParserFactory factory  &#x3D; SAXParserFactory.newInstance();<br>    XMLReader xmlReader &#x3D; factory.newSAXParser().getXMLReader();<br>    MyHandler handler &#x3D; new MyHandler();<br>    &#x2F;&#x2F;将ContentHandler的实例设置到XMLReader中<br>    xmlReader.setContentHandler(handler);<br>    &#x2F;&#x2F;开始执行解析<br>    xmlReader.parse(new InputSource(new StringReader(xmlData)));<br>}<br>catch (Exception e) {<br>    e.printStackTrace();<br>}<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   1. 先是创建了一个SAXParserFactory的对象</span><br><span class="line">   2. 然后再获取到XMLReader对象</span><br><span class="line">   3. 接着将我们编写的MyHandler的实例设置到XMLReader中</span><br><span class="line">   4. 最后调用parse()方法开始执行解析</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 9.4 解析JSON格式数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 比起XML, JSON的主要优势在于它的体积更小，在网络上传输的时候可以更省流量</span><br><span class="line"></span><br><span class="line">2. 缺点在于，它的语义性较差，看起来不如XML直观</span><br><span class="line"></span><br><span class="line">3. `/htdocs/get_data.json`</span><br><span class="line"></span><br><span class="line">   - ```json</span><br><span class="line">     [&#123;&quot;id&quot;:&quot;5&quot;, &quot;version&quot;:&quot;5.5&quot;, &quot;name&quot;:&quot;Clash of Clans&quot;&#125;,</span><br><span class="line">     &#123;&quot;id&quot;:&quot;6&quot;, &quot;version&quot;:&quot;7.0&quot;, &quot;name&quot;:&quot;Boom Beach&quot;&#125;,</span><br><span class="line">     &#123;&quot;id&quot;:&quot;7&quot;, &quot;version&quot;:&quot;3.5&quot;, &quot;name&quot;:&quot;Clash Royale&quot;&#125;]</span><br></pre></td></tr></table></figure></li></ol><h4 id="9-4-1-使用JSONObject"><a href="#9-4-1-使用JSONObject" class="headerlink" title="9.4.1 使用JSONObject"></a>9.4.1 使用JSONObject</h4><ol><li><p>解析JSON数据也有很多种方法，可以使用官方提供的<strong>JSONObject</strong>，也可以使用谷歌的开源库<strong>GSON</strong>。另外，一些第三方的开源库如<strong>Jackson、FastJSON</strong>等也非常不错</p></li><li><pre><code class="java">private void parseJSONWithJSONObject(String jsonData) &#123;    try &#123;        JSONArray jsonArray = new JSONArray(jsonData);        for (int i = 0; i &lt; jsonArray.length(); i++) &#123;            JSONObject jsonObject = jsonArray.getJSONObject(i);            String id = jsonObject.getString(&quot;id&quot;);            String name = jsonObject.getString(&quot;name&quot;);            String version = jsonObject.getString(&quot;version&quot;);        &#125;    &#125;    catch (Exception e) &#123;        e.printStackTrace();    &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   1. 首先是将服务器返回的数据传入到了一个JSONArray对象中</span><br><span class="line">   2. 然后循环遍历这个JSONArray，从中取出的每一个元素都是一个JSONObject对象</span><br><span class="line">   3. 每个JSONObject对象中又会包含id、name和version这些数据</span><br><span class="line">   4. 接下来只需要调用getString()方法将这些数据取出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 9.4.2 使用GSON</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 谷歌提供的GSON开源库可以让解析JSON数据的工作简单到让你不敢想象的地步</span><br><span class="line"></span><br><span class="line">2. GSON并没有被添加到Android官方的API中，因此如果想要使用这个功能的话，就必须要在项目中添加GSON库的依赖</span><br><span class="line"></span><br><span class="line">   - 编辑app/build.gradle文件，在dependencies闭包中添加如下内容：</span><br><span class="line"></span><br><span class="line">   - ```json</span><br><span class="line">     dependencies &#123;</span><br><span class="line">       implementation &#x27;com.google.code.gson:gson:2.9.1&#x27;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p><strong>GSON库究竟是神奇在哪里呢？</strong>其实它主要就是可以将一段JSON格式的字符串自动映射成一个对象，从而不需要我们再手动去编写代码进行解析</p></li><li><p>映射对象</p><ul><li>&#96;&#96;&#96;java<br>public class App {<br>private String id;<br>private String name;<br>private String version;<br>&#x2F;&#x2F;Getter and Setter<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. ```java</span><br><span class="line">   private void parseJSONWithGSON(String jsonData) &#123;</span><br><span class="line">       Gson gson = new Gson();</span><br><span class="line">       //App app = gson.fromJson(jsonData, App.class); //单例</span><br><span class="line">       //数组</span><br><span class="line">       List&lt;App&gt; appList = gson.fromJson(jsonData, new TypeToken&lt;List&lt;App&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">       for (App app: appList) &#123;</span><br><span class="line">           Log.d(&quot;TAG&quot;, &quot;parseJSONWithGSON: id is &quot; + app.getId());</span><br><span class="line">           Log.d(&quot;TAG&quot;, &quot;parseJSONWithGSON: name is &quot; + app.getName());</span><br><span class="line">           Log.d(&quot;TAG&quot;, &quot;parseJSONWithGSON: version is &quot; + app.getVersion());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="9-5-网络编程的最佳实践"><a href="#9-5-网络编程的最佳实践" class="headerlink" title="9.5 网络编程的最佳实践"></a>9.5 网络编程的最佳实践</h3><ol><li><p>通常情况下我们都应该将这些通用的网络操作提取到一个公共的类里，并提供一个静态方法，当想要发起网络请求的时候，只需简单地调用一下这个方法即可</p><ul><li>&#96;&#96;&#96;java<br>String address &#x3D; “<a href="https://www.baidu.com&quot;/">https://www.baidu.com&quot;</a>;<br>String response &#x3D; HttpUtil.sendHttpRequest(address);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 网络请求通常都是属于耗时操作，而sendHttpRequest()方法的内部并没有开启线程，这样就有可能导致在调用sendHttpRequest()方法的时候使得主线程被阻塞住</span><br><span class="line"></span><br><span class="line">   1. **在sendHttpRequest()方法内部开启一个线程不就解决这个问题了吗？**</span><br><span class="line">   2. 如果我们在sendHttpRequest()方法中开启了一个线程来发起HTTP请求，那么服务器响应的数据是无法进行返回的，所有的耗时逻辑都是在子线程里进行的，sendHttpRequest()方法会在服务器还没来得及响应的时候就执行结束了，当然也就无法返回响应的数据了</span><br><span class="line">   3. ==解决方法并不难，只需要使用Java的回调机制就可以了==</span><br><span class="line"></span><br><span class="line">3. 回调机制</span><br><span class="line"></span><br><span class="line">   1. 首先需要定义一个接口，比如将它命名成HttpCallbackListener</span><br><span class="line"></span><br><span class="line">      - ```java</span><br><span class="line">        public interface HttpCallbackListener &#123;</span><br><span class="line">            void onFinish(String response);</span><br><span class="line">            void onError(Exception e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li><p>onFinish()方法表示当服务器成功响应我们请求的时候调用</p></li><li><p>onError()表示当进行网络操作出现错误的时候调用</p></li><li><p>这两个方法都带有参数，onFinish()方法中的参数代表着服务器返回的数据，而onError()方法中的参数记录着错误的详细信息</p></li></ul></li></ul><ol start="2"><li><pre><code class="java">public static void sendHttpRequest(final String address, final HttpCallbackListener listener) &#123;    new Thread(new Runnable() &#123;        @Override        public void run() &#123;            HttpURLConnection connection = null;            try &#123;                URL url = new URL(address);                connection = (HttpURLConnection) url.openConnection();                connection.setRequestMethod(&quot;GET&quot;);                connection.setConnectTimeout(8000);                connection.setReadTimeout(8000);                connection.setDoInput(true);                connection.setDoOutput(true);                InputStream in = connection.getInputStream();                BufferedReader reader = new BufferedReader(new InputStreamReader(in));                StringBuilder response = new StringBuilder();                String line;                while ((line = reader.readLine()) != null) &#123;                    response.append(line);                &#125;                if (listener != null) &#123;                    //回调onFinish()方法                    listener.onFinish(response.toString());                &#125;            &#125;            catch (Exception e) &#123;                e.printStackTrace();                if (listener != null) &#123;                    //回调onError()方法                    listener.onError(e);                &#125;            &#125;            finally &#123;                if (connection != null) &#123;                    connection.disconnect();                &#125;            &#125;        &#125;    &#125;).start();&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. 给sendHttpRequest()方法添加了一个HttpCallbackListener参数，并在方法的内部开启了一个子线程，然后在子线程里去执行具体的网络操作</span><br><span class="line"></span><br><span class="line">2. ==注意==，**子线程中是无法通过return语句来返回数据的**，因此这里我们将服务器响应的数据传入了HttpCallbackListener的onFinish()方法中，如果出现了异常就将异常原因传入到onError()方法中</span><br><span class="line"></span><br><span class="line">3. 我们在调用sendHttpRequest()方法的时候还需要将HttpCallbackListener的实例传入</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     HttpUtil.sendHttpRequest(address, new HttpCallbackListener() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void onFinish(String response) &#123;</span><br><span class="line">             //在这里根据返回内容执行具体的逻辑</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line">         @Override</span><br><span class="line">         public void onError(Exception e) &#123;</span><br><span class="line">             //在这里对异常情况进行处理</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>当服务器成功响应的时候，我们就可以在onFinish()方法里对响应数据进行处理了。类似地，如果出现了异常，就可以在onError()方法里对异常情况进行处理。如此一来，我们就巧妙地利用回调机制将响应数据成功返回给调用方了</p></li><li><p>使用OkHttp</p><ul><li>&#96;&#96;&#96;java<br>public static void sendOkHttpRequest(String address, okhttp3.Callback callback) {<br>OkHttpClient client &#x3D; new OkHttpClient();<br>Request request &#x3D; new Request.Builder()<br>    .url(address)<br>    .build();<br>client.newCall(request).enqueue(callback);<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - sendOkHttpRequest()方法中有一个okhttp3.Callback参数，这个是OkHttp库中自带的一个回调接口，类似于我们刚才自己编写的HttpCallbackListener</span><br><span class="line"></span><br><span class="line">   - 然后在client. newCall()之后没有像之前那样一直调用execute()方法，而是调用了一个enqueue()方法，并把okhttp3.Callback参数传入。OkHttp在enqueue()方法的内部已经帮我们开好子线程了，然后会在子线程中去执行HTTP请求，并将最终的请求结果回调到okhttp3.Callback当中</span><br><span class="line"></span><br><span class="line">5. 调用sendOkHttpRequest()方法的时</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     HttpUtil.sendOkHttpRequest(address, new okhttp3.Callback() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException &#123;</span><br><span class="line">             //得到服务器返回的具体内容</span><br><span class="line">         &#125;</span><br><span class="line">     </span><br><span class="line">         @Override</span><br><span class="line">         public void onFailure(@NonNull Call call, @NonNull IOException e) &#123;</span><br><span class="line">             //在这里对异常情况进行处理</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>&#x3D;&#x3D;另外需要注意的是&#x3D;&#x3D;，不管是使用HttpURLConnection还是OkHttp，最终的回调接口都还是在子线程中运行的，因此我们<strong>不可以在这里执行任何的UI操作，除非借助runOnUiThread()方法来进行线程转换</strong></p></li></ol></li></ol><h3 id="9-6-小结与点评"><a href="#9-6-小结与点评" class="headerlink" title="9.6 小结与点评"></a>9.6 小结与点评</h3><h2 id="第10章-后台默默的劳动者——探究服务"><a href="#第10章-后台默默的劳动者——探究服务" class="headerlink" title="第10章 后台默默的劳动者——探究服务"></a>第10章 后台默默的劳动者——探究服务</h2><ol><li>iPhone属于少数人才拥有的稀有物品，Android甚至还没面世，那个时候全球的手机市场是由诺基亚统治着的。当时诺基亚的Symbian操作系统做得特别出色，因为比起一般的手机，它可以支持后台功能</li><li>如今，Symbian早已风光不再，Android和iOS几乎占据了智能手机全部的市场份额</li><li>在这两大移动操作系统中，iOS一开始是不支持后台的，后来逐渐意识到这个功能的重要性，才加入了后台功能</li><li>而Android则是沿用了Symbian的老习惯，从一开始就支持后台功能，这使得应用程序即使在关闭的情况下仍然可以在后台继续运行</li></ol><h3 id="10-1-服务是什么"><a href="#10-1-服务是什么" class="headerlink" title="10.1 服务是什么"></a>10.1 服务是什么</h3><ol><li>服务（Service）是Android中实现程序后台运行的解决方案，它非常适合去执行那些不需要和用户交互而且还要求长期运行的任务</li><li>服务的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行</li><li>不过需要注意的是，服务并不是运行在一个独立的进程当中的，而是依赖于创建服务时所在的应用程序进程</li><li>当某个应用程序进程被杀掉时，所有依赖于该进程的服务也会停止运行</li><li>另外，也不要被服务的后台概念所迷惑，实际上服务并不会自动开启线程，所有的代码都是默认运行在主线程当中的</li><li>也就是说，我们需要在服务的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞住的情况</li></ol><h3 id="10-2-Android多线程编程"><a href="#10-2-Android多线程编程" class="headerlink" title="10.2 Android多线程编程"></a>10.2 Android多线程编程</h3><ol><li>执行一些耗时操作</li><li>服务器未必会立刻响应我们的请求</li><li>如果不将这类操作放在子线程里去运行，就会导致主线程被阻塞住</li></ol><h4 id="10-2-1-线程的基本用法"><a href="#10-2-1-线程的基本用法" class="headerlink" title="10.2.1 线程的基本用法"></a>10.2.1 线程的基本用法</h4><ol><li><p>Android多线程编程其实并不比Java多线程编程特殊，基本都是使用相同的语法</p></li><li><p>定义一个线程只需要新建一个类继承自Thread，然后重写父类的run()方法，并在里面编写耗时逻辑即可</p><ul><li>&#96;&#96;&#96;java<br>class MyThread extends Thread {<br>@Override<br>public void run() {<br>    &#x2F;&#x2F;处理具体的逻辑<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 启动这个线程？只需要new出MyThread的实例，然后调用它的start()方法，这样run()方法中的代码就会在子线程当中运行了</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     new MyThread().start();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用继承的方式耦合性有点高，更多的时候我们都会选择使用实现Runnable接口的方式来定义一个线程</p><ul><li>&#96;&#96;&#96;java<br>class MyThread implements Runnable {<br>@Override<br>public void run() {<br>    &#x2F;&#x2F;处理具体的逻辑<br>}<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. 启动这个线程</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     MyThread myThread = new MyThread();</span><br><span class="line">     new Thread(myThread).start();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果你不想专门再定义一个类去实现Runnable接口，也可以使用匿名类的方式</p><ul><li>&#96;&#96;&#96;java<br>new Thread(new Runnable() {<br>@Override<br>public void run() {<br>    &#x2F;&#x2F;处理具体的逻辑<br>}<br>}).start();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 10.2.2 在子线程中更新UI</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 和许多其他的GUI库一样，Android的UI也是线程不安全的</span><br><span class="line"></span><br><span class="line">2. 也就是说，如果想要更新应用程序里的UI元素，则必须在主线程中进行，否则就会出现异常</span><br><span class="line"></span><br><span class="line">   - `android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.`</span><br><span class="line"></span><br><span class="line">3. Android提供了一套异步消息处理机制，完美地解决了在子线程中进行UI操作的问题</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      private Handler handler = new Handler() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void handleMessage(Message msg) &#123;</span><br><span class="line">              switch (msg.what) &#123;</span><br><span class="line">                  case UPDATE_TEXT:</span><br><span class="line">                      //在这里进行UI操作</span><br><span class="line">                      text.setText(&quot;Nice to meet you!&quot;);</span><br><span class="line">                      break;</span><br><span class="line">                  default:</span><br><span class="line">                      break;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure><ul><li>新增一个Handler对象，并重写父类的handleMessage()方法，在这里对具体的Message进行处理</li></ul></li></ul><ol start="2"><li>&#96;&#96;&#96;java<br>Message message &#x3D; new Message();<br>message.what &#x3D; UPDATE_TEXT;<br>&#x2F;&#x2F;将Message对象发送出去<br>handler.sendMessage(message);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      - 创建了一个Message（android.os.Message）对象，并将它的what字段的值指定为UPDATE_TEXT，然后调用Handler的sendMessage()方法将这条Message发送出去</span><br><span class="line">      - 很快，Handler就会收到这条Message，并在handleMessage()方法中对它进行处理。==注意==此时handleMessage()方法中的代码就是在主线程当中运行的了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 10.2.3 解析异步消息处理机制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. Android中的异步消息处理主要由4个部分组成：Message、Handler、MessageQueue和Looper</span><br><span class="line">2. Message</span><br><span class="line">   1. Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间交换数据</span><br><span class="line">   2. Message的what字段，除此之外还可以使用arg1和arg2字段来携带一些整型数据，使用obj字段携带一个Object对象</span><br><span class="line">3. Handler</span><br><span class="line">   1. Handler顾名思义也就是处理者的意思，它主要是用于发送和处理消息的</span><br><span class="line">   2. 发送消息一般是使用Handler的sendMessage()方法，而发出的消息经过一系列地辗转处理后，最终会传递到Handler的handleMessage()方法中</span><br><span class="line">4. MessageQueue</span><br><span class="line">   1. MessageQueue是消息队列的意思，它主要用于存放所有通过Handler发送的消息。这部分消息会一直存在于消息队列中，等待被处理</span><br><span class="line">   2. 每个线程中只会有一个MessageQueue对象</span><br><span class="line">5. Looper</span><br><span class="line">   1. Looper是每个线程中的MessageQueue的管家</span><br><span class="line">   2. 调用Looper的loop()方法后，就会进入到一个无限循环当中，然后每当发现MessageQueue中存在一条消息，就会将它取出，并传递到Handler的handleMessage()方法中</span><br><span class="line">   3. 每个线程中也只会有一个Looper对象</span><br><span class="line">6. 异步消息处理的整个流程</span><br><span class="line">   1. 首先需要在主线程当中创建一个Handler对象，并重写handleMessage()方法</span><br><span class="line">   2. 当子线程中需要进行UI操作时，就创建一个Message对象，并通过Handler将这条消息发送出去</span><br><span class="line">   3. 之后这条消息会被添加到MessageQueue的队列中等待被处理，而Looper则会一直尝试从MessageQueue中取出待处理消息，最后分发回Handler的handleMessage()方法中</span><br><span class="line">   4. ![image-20220805123955872](第一行代码Android.assets/image-20220805123955872.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 10.2.4 使用AsyncTask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AsyncTask简介</span><br><span class="line"></span><br><span class="line">1. 为了更加方便我们在子线程中对UI进行操作，Android还提供了另外一些好用的工具，比如AsyncTask</span><br><span class="line">2. 借助AsyncTask，即使你对异步消息处理机制完全不了解，也可以十分简单地从子线程切换到主线程</span><br><span class="line">3. AsyncTask背后的实现原理也是基于异步消息处理机制的，只是Android帮我们做了很好的封装</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AsyncTask的基本用法</span><br><span class="line"></span><br><span class="line">1. AsyncTask是一个抽象类，如果我们想使用它，就必须要创建一个子类去继承它</span><br><span class="line"></span><br><span class="line">2. 在继承时我们可以为AsyncTask类指定3个泛型参数</span><br><span class="line"></span><br><span class="line">   1. **Params**。在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。</span><br><span class="line"></span><br><span class="line">   2. **Progress**。后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。</span><br><span class="line"></span><br><span class="line">   3. **Result**。当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。</span><br><span class="line"></span><br><span class="line">   4. ```java</span><br><span class="line">      //一个最简单的自定义AsyncTask</span><br><span class="line">      class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; &#123;</span><br><span class="line">          //...</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><ol><li>第一个泛型参数指定为Void，表示在执行AsyncTask的时候不需要传入参数给后台任务</li><li>第二个泛型参数指定为Integer，表示使用整型数据来作为进度显示单位</li><li>第三个泛型参数指定为Boolean，则表示使用布尔型数据来反馈执行结果</li></ol></li></ol></li><li><p>经常需要去重写的方法有4个</p><ol><li><p>onPreExecute()这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。</p></li><li><p>doInBackground(Params…)这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过return语句来将任务的执行结果返回，如果AsyncTask的第三个泛型参数指定的是Void，就可以不返回任务执行结果。</p><ul><li>&#x3D;&#x3D;注意&#x3D;&#x3D;，在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用publishProgress (Progress…)方法来完成。</li></ul></li><li><p>onProgressUpdate(Progress…)当在后台任务中调用了publishProgress(Progress…)方法后，onProgressUpdate (Progress…)方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。<strong>这个方法是在主线程中运行的。</strong></p></li><li><p>onPostExecute(Result)当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。<strong>这个方法也是在主线程中运行的。</strong></p></li><li><p>&#96;&#96;&#96;java<br>public class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; {</p><pre><code>@Overrideprotected void onPreExecute() &#123;    //显示进度对话框    progressDialog.show();&#125;@Overrideprotected Boolean doInBackground(Void... params) &#123;    try &#123;        while (true) &#123;            //这是一个虚构的方法            int downloadPercent = doDownload();            publishProgress(downloadPercent);            if (downloadPercent &gt;= 100) &#123;                break;            &#125;        &#125;    &#125;    catch (Exception e) &#123;        return false;    &#125;    return true;&#125;@Overrideprotected void onProgressUpdate(Integer... values) &#123;    //在这里更新下载进度    progressDialog.setMessage(&quot;Downloaded&quot; + values[0] + &quot;%&quot;);&#125;@Overrideprotected void onPostExecute(Boolean result) &#123;    //关闭进度对话框    progressDialog.dismiss();    //在这里提示下载结果    if (result) &#123;        Toast.makeText(context, &quot;Download succeeded&quot;, Toast.LENGTH_SHORT).show();    &#125;    else &#123;        Toast.makeText(context, &quot;Download failed&quot;, Toast.LENGTH_SHORT).show();    &#125;&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 使用AsyncTask的诀窍</span><br><span class="line"></span><br><span class="line">   1. 在doInBackground()方法中执行具体的耗时任务</span><br><span class="line">   2. 在onProgressUpdate()方法中进行UI操作</span><br><span class="line">   3. 在onPostExecute()方法中执行一些任务的收尾工作</span><br><span class="line"></span><br><span class="line">5. 启动</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     new DownloadTask().execute();</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="10-3-服务的基本用法"><a href="#10-3-服务的基本用法" class="headerlink" title="10.3 服务的基本用法"></a>10.3 服务的基本用法</h3><h4 id="10-3-1-定义一个服务"><a href="#10-3-1-定义一个服务" class="headerlink" title="10.3.1 定义一个服务"></a>10.3.1 定义一个服务</h4><ol><li>右击com.example.servicetest→New→Service→Service<ol><li>Exported属性表示是否允许除了当前程序之外的其他程序访问这个服务</li><li>Enabled属性表示是否启用这个服务</li><li>将两个属性都勾中</li></ol></li><li>MyService是继承自Service类</li><li>重写onCreate()、onStartCommand()和onDestroy()这3个方法，它们是每个服务中最常用到的3个方法<ol><li>onCreate()方法会在服务<strong>第一次</strong>创建的时候调用</li><li>onStartCommand()方法会在<strong>每次</strong>服务启动的时候调用</li><li>onDestroy()方法会在服务<strong>销毁</strong>的时候调用</li></ol></li><li>&#x3D;&#x3D;注意&#x3D;&#x3D;，每一个服务都需要在AndroidManifest.xml文件中进行注册才能生效<ul><li>Android Studio自动完成</li></ul></li></ol><h4 id="10-3-2-启动和停止服务"><a href="#10-3-2-启动和停止服务" class="headerlink" title="10.3.2 启动和停止服务"></a>10.3.2 启动和停止服务</h4><ol><li><p>主要是借助Intent来实现的</p><ul><li>&#96;&#96;&#96;java<br>Intent intent &#x3D; new Intent(this, MyService.class);<br>startService(intent);   &#x2F;&#x2F;启动服务<br>stopService(intent);    &#x2F;&#x2F;停止服务<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - startService()和stopService()方法都是定义在Context类中的，所以我们在活动里可以直接调用这两个方法</span><br><span class="line"></span><br><span class="line">   - ==注意==，这里完全是由活动来决定服务何时停止的</span><br><span class="line"></span><br><span class="line">2. **服务有没有什么办法让自已停止下来呢？**</span><br><span class="line"></span><br><span class="line">   - 只需要在MyService的任何一个位置调用**stopSelf()**方法就能让这个服务停止下来</span><br><span class="line"></span><br><span class="line">3. `销毁服务后下次启动会调用onCreate()方法`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 10.3.3 活动和服务进行通信</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 新建了一个DownloadBinder类，并让它继承自Binder，然后在它的内部提供了开始下载以及查看下载进度的方法。当然这只是两个模拟方法，并没有实现真正的功能，我们在这两个方法中分别打印了一行日志。</span><br><span class="line"></span><br><span class="line">2. 在MyService中创建了DownloadBinder的实例，然后在onBind()方法里返回了这个实例</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     public class MyService extends Service &#123;</span><br><span class="line">         </span><br><span class="line">         private DownloadBinder mBinder = new DownloadBinder();</span><br><span class="line">         </span><br><span class="line">         class DownloadBinder extends Binder &#123;</span><br><span class="line">             public void startDownload() &#123;</span><br><span class="line">                 Log.d(&quot;TAG&quot;, &quot;startDownload executed&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">             public int getProgress() &#123;</span><br><span class="line">                 Log.d(&quot;TAG&quot;, &quot;getProgress executed&quot;);</span><br><span class="line">                 return 0;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         @Override</span><br><span class="line">         public IBinder onBind(Intent intent) &#123;</span><br><span class="line">             return mBinder;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在活动中去调用服务里的方法</p><ol><li>&#96;&#96;&#96;java<br>private MyService.DownloadBinder downloadBinder;<br>private ServiceConnection connection &#x3D; new ServiceConnection() {<br>@Override<br>public void onServiceConnected(ComponentName componentName, IBinder iBinder) {<br>    &#x2F;&#x2F;向下转型得到DownloadBinder的实例<br>    downloadBinder &#x3D; (MyService.DownloadBinder) iBinder;<br>    downloadBinder.startDownload();<br>    downloadBinder.getProgress();<br>}<br><br>@Override<br>public void onServiceDisconnected(ComponentName componentName) {<br><br>}<br>};<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      1. 首先创建了一个ServiceConnection的匿名类，在里面重写了onService-Connected()方法和onServiceDisconnected()方法</span><br><span class="line">      2. 这两个方法分别会在活动与服务成功绑定以及活动与服务的连接断开的时候调用</span><br><span class="line">      3. 在onServiceConnected()方法中，我们又通过向下转型得到了DownloadBinder的实例，有了这个实例，我们可以在活动中根据具体的场景来调用DownloadBinder中的任何public方法</span><br><span class="line"></span><br><span class="line">4. 绑定和解绑</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      Intent intent = new Intent(this, MyService.class);</span><br><span class="line">      //绑定服务</span><br><span class="line">      bindService(intent, connection, BIND_AUTO_CREATE);</span><br><span class="line">      //解绑服务</span><br><span class="line">      unbindService(connection);</span><br></pre></td></tr></table></figure><ol><li>首先构建出了一个Intent对象</li><li>然后调用bindService()方法将MainActivity和MyService进行绑定</li><li>bindService()方法接收3个参数，第一个参数就是刚刚构建出的Intent对象</li><li>第二个参数是前面创建出的ServiceConnection的实例</li><li>第三个参数则是一个标志位，这里传入BIND_AUTO_CREATE表示在活动和服务进行绑定后自动创建服务<ul><li><strong>这会使得MyService中的onCreate()方法得到执行，但onStartCommand()方法不会执行</strong></li></ul></li><li>解除活动和服务之间的绑定调用一下unbindService()方法就可以了</li></ol></li></ol></li><li><p>&#x3D;&#x3D;注意&#x3D;&#x3D;，任何一个服务在整个应用程序范围内都是通用的，即MyService不仅可以和MainActivity绑定，还可以和任何一个其他的活动进行绑定</p></li></ol><h3 id="10-4-服务的生命周期"><a href="#10-4-服务的生命周期" class="headerlink" title="10.4 服务的生命周期"></a>10.4 服务的生命周期</h3><ol><li>&#x3D;&#x3D;注意&#x3D;&#x3D;，虽然每调用一次startService()方法，onStartCommand()就会执行一次，但实际上每个服务都只会存在一个实例。所以不管你调用了多少次startService()方法，只需调用一次stopService()或stopSelf()方法，服务就会停止下来</li><li>还可以调用Context的bindService()来获取一个服务的持久连接，这时就会回调服务中的onBind()方法，如果这个服务之前还没有创建过，onCreate()方法会先于onBind()方法执行。之后，调用方可以获取到onBind()方法里返回的IBinder对象的实例</li><li>当调用了bindService()方法后，又去调用unbindService()方法，onDestroy()方法会执行</li><li>对一个服务既调用了startService()方法，又调用了bindService()方法，这种情况下该如何才能让服务销毁掉呢？<ul><li>根据Android系统的机制，一个服务只要被启动或者被绑定了之后，就会一直处于运行状态，必须要让以上两种条件同时不满足，服务才能被销毁</li><li>所以，这种情况下要同时调用stopService()和unbindService()方法，onDestroy()方法才会执行</li></ul></li></ol><h3 id="10-5-服务的更多技巧"><a href="#10-5-服务的更多技巧" class="headerlink" title="10.5 服务的更多技巧"></a>10.5 服务的更多技巧</h3><h4 id="10-5-1-使用前台服务"><a href="#10-5-1-使用前台服务" class="headerlink" title="10.5.1 使用前台服务"></a>10.5.1 使用前台服务</h4><p>简介</p><ol><li>服务几乎都是在后台运行的</li><li>服务的系统优先级还是比较低的，当系统出现内存不足的情况时，就有可能会回收掉正在后台运行的服务</li><li>如果你希望服务可以一直保持运行状态，而不会由于系统内存不足的原因导致被回收，就可以考虑使用前台服务</li><li>有时候你也可能不仅仅是为了防止服务被回收掉才使用前台服务的，有些项目由于特殊的需求会要求必须使用前台服务<ul><li>比如说彩云天气这款天气预报应用，它的服务在后台更新天气数据的同时，还会在系统状态栏一直显示当前的天气信息</li></ul></li></ol><p>前台服务和普通服务的区别</p><ol><li>最大的区别在于前台服务会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果</li></ol><p>创建一个前台服务</p><ol><li><pre><code class="java">public class MyService extends Service &#123;        @Override    public void onCreate() &#123;        super.onCreate();                Intent intent = new Intent(this, MainActivity.class);        PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);        Notification notification = new NotificationCompat.Builder(this)                .setContentTitle(&quot;This is content title&quot;)                .setContentText(&quot;This is content text&quot;)                .setWhen(System.currentTimeMillis())                .setSmallIcon(R.mipmap.ic_launcher)                .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))                .setContentIntent(pi)                .build();        startForeground(1, notification);            &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   1. 这是创建通知的方法</span><br><span class="line">   2. 只不过这次在构建出Notification对象后并没有使用NotificationManager来将通知显示出来，而是调用了startForeground()方法</span><br><span class="line">   3. startForeground()方法接收两个参数，第一个参数是通知的id，类似于notify()方法的第一个参数，第二个参数则是构建出的Notification对象</span><br><span class="line">   4. 调用startForeground()方法后就会让MyService变成一个前台服务，并在系统状态栏显示出来</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 10.5.2 使用IntentService</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">为何使用IntentService</span><br><span class="line"></span><br><span class="line">1. 服务中的代码都是默认运行在主线程当中的，如果直接在服务里去处理一些耗时的逻辑，就很容易出现ANR（Application Not Responding）的情况</span><br><span class="line"></span><br><span class="line">   - 解决办法:Android多线程编程</span><br><span class="line">   - 在服务的每个具体的方法里开启一个子线程，然后在这里去处理那些耗时的逻辑</span><br><span class="line"></span><br><span class="line">2. 一个标准的服务</span><br><span class="line"></span><br><span class="line">   1. ```java</span><br><span class="line">      public class MyService extends Service &#123;</span><br><span class="line">          </span><br><span class="line">          //...</span><br><span class="line">          @Override</span><br><span class="line">          public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">              new Thread(new Runnable() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public void run() &#123;</span><br><span class="line">                      //处理具体的逻辑</span><br><span class="line">                      //如果想要实现让一个服务在执行完毕后自动停止</span><br><span class="line">                      stopSelf();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;).start();</span><br><span class="line">              return super.onStartCommand(intent, flags, startId);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>为了可以简单地创建一个<strong>异步的、会自动停止的</strong>服务，Android专门提供了一个IntentService类</p></li></ol><p>IntentService用法</p><ol><li><p>新建一个MyIntentService类继承自IntentService</p><ul><li><p>&#96;&#96;&#96;java<br>public class MyIntentService extends IntentService {</p><pre><code>public MyIntentService() &#123;    //调用父类的有参构造函数    super(&quot;MyIntentService&quot;);    Log.d(&quot;MyIntentService&quot;, &quot;create&quot;);&#125;@Overrideprotected void onHandleIntent(@Nullable Intent intent) &#123;    //打印当前线程的id    Log.d(&quot;MyIntentService&quot;, &quot;Thread id is &quot; + Thread.currentThread().getId());&#125;@Overridepublic void onDestroy() &#123;    super.onDestroy();    Log.d(&quot;MyIntentService&quot;, &quot;onDestroy executed&quot;);&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - 首先要提供一个无参的构造函数，并且必须在其内部调用父类的有参构造函数</span><br><span class="line"></span><br><span class="line">   - 然后要在子类中去实现onHandleIntent()这个抽象方法，在这个方法中可以去处理一些具体的逻辑，而且不用担心**ANR**的问题(这个方法是在子线程中运行的)</span><br><span class="line"></span><br><span class="line">   - 这个服务在运行结束后应该会自动停止的，所以又重写了onDestroy()方法</span><br><span class="line"></span><br><span class="line">2. 启动</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     Intent intentService = new Intent(this, MyIntentService.class);</span><br><span class="line">     startService(intentService);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>服务都是需要在AndroidManifest.xml里注册的</p><ul><li>&#96;&#96;&#96;xml<service android:name=".MyIntentService"/><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 也可以使用Android Studio提供的快捷方式来创建IntentService，不过这样会自动生成一些我们用不到的代码</span><br><span class="line"></span><br><span class="line">5. `集开启线程和自动停止于一身`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 10.6 服务的最佳实践——完整版的下载示例</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">`ServiceBestPractice项目`</span><br><span class="line"></span><br><span class="line">1. 添加OkHttp的依赖</span><br><span class="line"></span><br><span class="line">   - ```json</span><br><span class="line">     dependencies &#123;</span><br><span class="line">     implementation &#x27;com.squareup.okhttp3:okhttp:4.9.0&#x27;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>定义回调接口</p><ul><li>&#96;&#96;&#96;java<br>public interface DownloadListener {<br>&#x2F;&#x2F;通知当前的下载进度<br>void onProgress(int progress);<br>&#x2F;&#x2F;通知下载成功事件<br>void onSuccess();<br>&#x2F;&#x2F;通知下载失败事件<br>void onFailed();<br>&#x2F;&#x2F;通知下载暂停事件<br>void onPaused();<br>&#x2F;&#x2F;通知下载取消事件<br>void onCanceled();<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 为了保证DownloadTask可以一直在后台运行，我们还需要创建一个下载的服务。右击com.example.servicebestpractice→New→Service→Service，新建DownloadService</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 10.7 小结与点评</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 第11章 Android特色开发——基于位置的服务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 第12章 最佳的UI体验——Material Design实战</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; Android平台的界面风格长期难以得到统一。为了解决这个问题，谷歌也是祭出了杀手锏，在2014年Google I/O大会上重磅推出了一套全新的界面设计语言——Material Design</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 12.1 什么是Material Design</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; `Material Design`</span><br><span class="line">&gt;</span><br><span class="line">&gt; - 界面设计语言</span><br><span class="line">&gt; - 包含了视觉、运动、互动效果等特性</span><br><span class="line">&gt;</span><br><span class="line">&gt; Android中却几乎没有提供相应的API支持，一切都要靠开发者自己从零写起</span><br><span class="line">&gt;</span><br><span class="line">&gt; 谷歌当然也意识到了这个问题，于是在2015年的Google I/O大会上推出了一个Design Support库，这个库将Material Design中最具代表性的一些控件和效果进行了封装，使得开发者在即使不了解Material Design的情况下也能非常轻松地将自己的应用Material化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 12.2 Toolbar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ActionBar</span><br><span class="line"></span><br><span class="line">- ActionBar由于其设计的原因，被限定只能位于活动的顶部，从而不能实现一些Material Design的效果，因此官方现在已经不再建议使用ActionBar了</span><br><span class="line"></span><br><span class="line">- 任何一个新建的项目，默认都是会显示ActionBar的</span><br><span class="line"></span><br><span class="line">  - ```python</span><br><span class="line">    &lt;!--ActionBar--&gt;</span><br><span class="line">    &lt;!--AndroidManifest.xml--&gt;</span><br><span class="line">    &lt;application android:theme=&quot;@style/Theme.MaterialTest&quot;&gt;&lt;/application&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><pre><code class="python">&lt;!--res/values/themes.xml--&gt;&lt;style name=&quot;Theme.MaterialTest&quot; parent=&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;&gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Toolbar</span><br><span class="line"></span><br><span class="line">- 它不仅继承了ActionBar的所有功能，而且灵活性很高，可以配合其他控件来完成一些Material Design的效果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用Toolbar来替代ActionBar</span><br><span class="line"></span><br><span class="line">- 需要指定一个不带ActionBar的主题</span><br><span class="line"></span><br><span class="line">  1. Theme.AppCompat.NoActionBar表示深色主题，它会将界面的主体颜色设成深色，陪衬颜色设成淡色</span><br><span class="line">  2. Theme.AppCompat.Light.NoActionBar表示淡色主题，它会将界面的主体颜色设成淡色，陪衬颜色设成深色</span><br><span class="line"></span><br><span class="line">- 属性</span><br><span class="line"></span><br><span class="line">  - &lt;img src=&quot;第一行代码Android.assets/image-20220827151114314.png&quot; alt=&quot;image-20220827151114314&quot; style=&quot;zoom: 50%;&quot; /&gt;</span><br><span class="line">  - colorAccent这个属性比较难理解，它不只是用来指定这样一个按钮的颜色，而是更多表达了一个强调的意思，比如一些控件的选中状态也会使用colorAccent的颜色</span><br><span class="line"></span><br><span class="line">- ```xml</span><br><span class="line">  &lt;androidx.appcompat.widget.Toolbar</span><br><span class="line">          android:id=&quot;@+id/toolbar&quot;</span><br><span class="line">          android:layout_width=&quot;match_parent&quot;</span><br><span class="line">          android:layout_height=&quot;?attr/actionBarSize&quot;</span><br><span class="line">          android:background=&quot;?attr/colorPrimary&quot;</span><br><span class="line">          android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span><br><span class="line">          app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>定义了一个Toolbar控件，这个控件是由appcompat-v7库提供的</p></li><li><p>高度设置为actionBar的高度</p></li><li><p>为了能让Toolbar单独使用深色主题，这里我们使用android:theme属性，将Toolbar的主题指定成了ThemeOverlay.AppCompat.Dark.ActionBar</p></li><li><p>使用app:popupTheme属性单独将弹出的菜单项指定成了淡色主题</p><ul><li>这个属性是在Android 5.0系统中新增的</li><li>可以兼容Android 5.0以下的系统</li></ul></li><li><pre><code class="java">import androidx.appcompat.widget.Toolbar;//onCreateToolbar toolbar = findViewById(R.id.toolbar);setSupportActionBar(toolbar);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 首先通过findViewById()得到Toolbar的实例</span><br><span class="line">  - 然后调用setSupportActionBar()方法并将Toolbar的实例传入</span><br><span class="line">  - 这样我们就做到既使用了Toolbar，又让它的外观与功能都和ActionBar一致</span><br><span class="line"></span><br><span class="line">- Toolbar比较常用的功能</span><br><span class="line"></span><br><span class="line">  - 修改标题栏上显示的文字内容</span><br><span class="line"></span><br><span class="line">    - ```xml</span><br><span class="line">      &lt;!--AndroidManifest.xml--&gt;</span><br><span class="line">      &lt;application android:label=&quot;@string/app_name&quot;&gt;&lt;/application&gt;</span><br></pre></td></tr></table></figure>  - 用于指定在Toolbar中显示的文字内容  - 如果没有指定的话，会默认使用application中指定的label内容，也就是我们的应用名称- 添加一些action按钮  - 准备图片---放在drawable-xxhdpi目录下  - 右击res目录→New→Directory，创建一个menu文件夹  - 右击menu文件夹→New→Menu resource file，创建一个toolbar.xml文件  - ```xml    &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;        xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;        &lt;item            android:id=&quot;@+id/backup&quot;            android:icon=&quot;@drawable/ic_launcher_background&quot;            android:title=&quot;Backup&quot;            app:showAsAction=&quot;always&quot;/&gt;    &lt;/menu&gt;    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 使用app:showAsAction来指定按钮的显示位置</span><br><span class="line"></span><br><span class="line">    - always表示永远显示在Toolbar中，如果屏幕空间不够则不显示</span><br><span class="line">    - ifRoom表示屏幕空间足够的情况下显示在Toolbar中，不够的话就显示在菜单当中</span><br><span class="line">    - never则表示永远显示在菜单当中</span><br><span class="line">    - 注意，Toolbar中的action按钮只会显示图标，菜单中的action按钮只会显示文字</span><br><span class="line"></span><br><span class="line">- 设置监听器</span><br><span class="line"></span><br><span class="line">  - onCreateOptionsMenu()方法中加载了toolbar.xml这个菜单文件</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      @Override</span><br><span class="line">      public boolean onCreateOptionsMenu(Menu menu) &#123;</span><br><span class="line">          getMenuInflater().inflate(R.menu.toolbar, menu);</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>  - 在onOptionsItemSelected()方法中处理各个按钮的点击事件    - ```java      @Override      public boolean onOptionsItemSelected(@NonNull MenuItem item) &#123;          switch (item.getItemId()) &#123;              case R.id.backup:                  Toast.makeText(this, &quot;backup&quot;, Toast.LENGTH_SHORT).show();                  break;          &#125;          return true;      &#125;      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 12.3 滑动菜单</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 12.3.1 DrawerLayout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">滑动菜单</span><br><span class="line"></span><br><span class="line">- 将一些菜单选项隐藏起来，而不是放置在主屏幕上，然后可以通过滑动的方式将菜单显示出来</span><br><span class="line">- 既节省了屏幕空间，又实现了非常好的动画效果</span><br><span class="line">- 谷歌提供了一个DrawerLayout控件，借助这个控件，实现滑动菜单简单又方便</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DrawerLayout</span><br><span class="line"></span><br><span class="line">- 它是一个布局，在布局中允许放入两个直接子控件，第一个子控件是主屏幕中显示的内容，第二个子控件是滑动菜单中显示的内容</span><br><span class="line"></span><br><span class="line">- ```xml</span><br><span class="line">  &lt;androidx.drawerlayout.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">      xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">      android:id=&quot;@+id/drawer_layout&quot;</span><br><span class="line">      android:layout_width=&quot;match_parent&quot;</span><br><span class="line">      android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">  </span><br><span class="line">      &lt;FrameLayout</span><br><span class="line">          android:layout_width=&quot;match_parent&quot;</span><br><span class="line">          android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">          </span><br><span class="line">      &lt;/FrameLayout&gt;</span><br><span class="line">      &lt;TextView</span><br><span class="line">          android:layout_width=&quot;match_parent&quot;</span><br><span class="line">          android:layout_height=&quot;match_parent&quot;</span><br><span class="line">          android:layout_gravity=&quot;start&quot;</span><br><span class="line">          android:text=&quot;This is menu&quot;</span><br><span class="line">          android:textSize=&quot;30sp&quot;</span><br><span class="line">          android:background=&quot;#FFF&quot;/&gt;</span><br><span class="line">  &lt;/androidx.drawerlayout.widget.DrawerLayout&gt;</span><br></pre></td></tr></table></figure>- 第一个子控件是FrameLayout，用于作为主屏幕中显示的内容- 第二个子控件这里使用了一个TextView，用于作为滑动菜单中显示的内容，其实使用什么都可以，DrawerLayout并没有限制只能使用固定的控件- 关于第二个子控件有一点需要注意，layout_gravity这个属性是必须指定的，因为我们需要告诉DrawerLayout滑动菜单是在屏幕的左边还是右边- 这里我指定了start，表示会根据系统语言进行判断，如果系统语言是从左往右的，比如英语、汉语，滑动菜单就在左边，如果系统语言是从右往左的，比如阿拉伯语，滑动菜单就在右边</code></pre></li><li><p>提示用户—添加导航按钮</p><ul><li><pre><code class="java">//onCreate//图片放在drawable-xxhdpi目录下drawerLayout = findViewById(R.id.drawer_layout);ActionBar actionBar = getSupportActionBar();if (actionBar != null) &#123;    actionBar.setDisplayHomeAsUpEnabled(true);    actionBar.setHomeAsUpIndicator(R.drawable.ic_launcher_background);&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 调用getSupportActionBar()方法得到了ActionBar的实例，虽然这个ActionBar的具体实现是由Toolbar来完成的</span><br><span class="line">  - 调用ActionBar的setDisplayHomeAsUpEnabled()方法让导航按钮显示出来</span><br><span class="line">  - 调用setHomeAsUpIndicator()方法来设置一个导航按钮图标</span><br><span class="line">  - 实际上，Toolbar最左侧的这个按钮就叫作HomeAsUp按钮，它默认的图标是一个返回的箭头，含义是返回上一个活动</span><br><span class="line"></span><br><span class="line">- 在onOptionsItemSelected()方法中对HomeAsUp按钮的点击事件进行处理</span><br><span class="line"></span><br><span class="line">  - HomeAsUp按钮的id永远都是android.R.id.home</span><br><span class="line"></span><br><span class="line">  - 调用DrawerLayout的openDrawer()方法将滑动菜单展示出来</span><br><span class="line"></span><br><span class="line">  - 注意openDrawer()方法要求传入一个Gravity参数，为了保证这里的行为和XML中定义的一致，我们传入了GravityCompat.START</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    //onOptionsItemSelected</span><br><span class="line">    case android.R.id.home:</span><br><span class="line">    drawerLayout.openDrawer(GravityCompat.START);</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure></code></pre></li><li></li></ul></li></ul>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2022/08/30/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81Android/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hello World</title>
      <link>http://example.com/2022/08/29/hello-world/</link>
      <guid>http://example.com/2022/08/29/hello-world/</guid>
      <pubDate>Mon, 29 Aug 2022 14:10:23 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</description>
        
      
      
      
      <content:encoded><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2022/08/29/hello-world/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
