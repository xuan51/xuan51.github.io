<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>剑阁</title>
    <link>https://xuan51.github.io/</link>
    
    <atom:link href="https://xuan51.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>不患无位，患所以立；不患莫己知，求为可知也。</description>
    <pubDate>Fri, 16 Sep 2022 11:46:34 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>python基础</title>
      <link>https://xuan51.github.io/2022/09/16/Python%E5%9F%BA%E7%A1%80/</link>
      <guid>https://xuan51.github.io/2022/09/16/Python%E5%9F%BA%E7%A1%80/</guid>
      <pubDate>Fri, 16 Sep 2022 11:24:06 GMT</pubDate>
      
      <description>&lt;p&gt;python基础&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>python基础</p><span id="more"></span><h1>Python基础</h1><h2 id="第三章-Python的基本数据类型">第三章 Python的基本数据类型</h2><p>python的基本数据类型</p><ul class="lvl-0"><li class="lvl-2"><p>数值数据类型</p><ul class="lvl-2"><li class="lvl-4">整数(int)</li><li class="lvl-4">浮点数(float)</li></ul></li><li class="lvl-2"><p>布尔值数据类型(Boolean)</p></li><li class="lvl-2"><p>字符串数据类型(string)</p></li></ul><h3 id="3-1-type-函数">3.1 type()函数</h3><p>type()函数</p><ul class="lvl-0"><li class="lvl-2"><p>这个函数可以列出变量的数据类型类别</p></li></ul><h3 id="3-2-数值数据类型">3.2 数值数据类型</h3><h4 id="3-2-1-整数与浮点数的运算">3.2.1 整数与浮点数的运算</h4><p>python是根据运算结果来决定变量的数据类型</p><h4 id="3-2-2-2进位整数与函数bin">3.2.2 2进位整数与函数bin()</h4><p>2进位整数</p><ul class="lvl-0"><li class="lvl-2"><p>可以用2进位方式代表整数(0b开头)</p></li><li class="lvl-2"><p>显示时仍为一般数字</p></li></ul><p>bin()</p><ul class="lvl-0"><li class="lvl-2"><p>可以将一般数字转换为2进位</p></li></ul><h4 id="3-2-3-8进位整数">3.2.3 8进位整数</h4><p>8进位整数</p><ul class="lvl-0"><li class="lvl-2"><p>可以用8进位方式代表整数(0o开头)</p></li></ul><p>oct()</p><ul class="lvl-0"><li class="lvl-2"><p>可以将一般数字转换为8进位</p></li></ul><h4 id="3-2-4-16进位整数">3.2.4 16进位整数</h4><p>16进位整数</p><ul class="lvl-0"><li class="lvl-2"><p>可以用16进位方式代表整数(0x开头)</p></li></ul><p>hex()</p><ul class="lvl-0"><li class="lvl-2"><p>可以将一般数字转换为16进位</p></li></ul><h4 id="3-2-5-强制数据类型的转换">3.2.5 强制数据类型的转换</h4><p>强转函数</p><ul class="lvl-0"><li class="lvl-2"><p>int()</p></li><li class="lvl-2"><p>float()</p><ul class="lvl-2"><li class="lvl-4">不会改变原本变量的数据类型</li><li class="lvl-4">也可以强转特定的字符串</li></ul></li></ul><h4 id="3-2-6-数值运算常用的函数">3.2.6 数值运算常用的函数</h4><p>数值运算时常用的函数</p><ul class="lvl-0"><li class="lvl-2"><p>abs():计算绝对值</p><ul class="lvl-2"><li class="lvl-4">不改变原值</li></ul></li><li class="lvl-2"><p>pow(x,y):返回x的y次方(int/float均可)</p></li><li class="lvl-2"><p>round():返回<strong>五舍六入</strong>(不是四舍五入)</p><ul class="lvl-2"><li class="lvl-4">不改变原值</li></ul></li></ul><h3 id="3-3-布尔值数据类型">3.3 布尔值数据类型</h3><p>bool</p><ul class="lvl-0"><li class="lvl-2"><p>True</p></li><li class="lvl-2"><p>False</p></li></ul><p>强转为整数(也可强转为浮点数)</p><ul class="lvl-0"><li class="lvl-2"><p>True—&gt;1</p></li><li class="lvl-2"><p>False—&gt;0</p></li></ul><h3 id="3-4-字符串数据类型">3.4 字符串数据类型</h3><p>str</p><ul class="lvl-0"><li class="lvl-2"><p>‘’</p></li><li class="lvl-2"><p>“”</p></li></ul><p><mark>字符串中有单引号可以用双引号解决或者使用转义字符,如果字符串中既有单引号又有双引号可以用三个单(双)引号解决或使用转义字符</mark></p><h4 id="3-4-1-字符串的连接">3.4.1 字符串的连接</h4><p>字符串的链接</p><ul class="lvl-0"><li class="lvl-2"><p>‘+’</p></li><li class="lvl-2"><p>无法字符串直接加数值</p></li></ul><h4 id="3-4-2-处理多于一行的字符串">3.4.2 处理多于一行的字符串</h4><p>处理多于一行的字符串</p><ul class="lvl-0"><li class="lvl-2"><p>使用三个单(双)引号</p></li></ul><h4 id="3-4-3-逸出字符">3.4.3 逸出字符</h4><p><strong>逸出字符</strong></p><table><thead><tr><th style="text-align:center">逸出字符</th><th style="text-align:center">Hex值</th><th style="text-align:center">意义</th><th style="text-align:center">逸出字符</th><th style="text-align:center">Hex值</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center"><code>\'</code></td><td style="text-align:center">27</td><td style="text-align:center">单引号</td><td style="text-align:center"><code>\n</code></td><td style="text-align:center">0A</td><td style="text-align:center">换行</td></tr><tr><td style="text-align:center"><code>\&quot;</code></td><td style="text-align:center">22</td><td style="text-align:center">双引号</td><td style="text-align:center"><code>\o</code></td><td style="text-align:center"></td><td style="text-align:center">八进位表示</td></tr><tr><td style="text-align:center"><code>\\</code></td><td style="text-align:center">5C</td><td style="text-align:center">反斜杠</td><td style="text-align:center"><code>\r</code></td><td style="text-align:center">0D</td><td style="text-align:center">光标移至最左位置</td></tr><tr><td style="text-align:center"><code>\a</code></td><td style="text-align:center">07</td><td style="text-align:center">响铃</td><td style="text-align:center"><code>\x</code></td><td style="text-align:center"></td><td style="text-align:center">十六进位表示</td></tr><tr><td style="text-align:center"><code>\b</code></td><td style="text-align:center">08</td><td style="text-align:center">BackSpace建</td><td style="text-align:center"><code>\t</code></td><td style="text-align:center">09</td><td style="text-align:center">Tab建效果</td></tr><tr><td style="text-align:center"><code>\f</code></td><td style="text-align:center">0C</td><td style="text-align:center">换页</td><td style="text-align:center"><code>\v</code></td><td style="text-align:center">0B</td><td style="text-align:center">垂直定位</td></tr></tbody></table><h4 id="3-4-4-强制转换为字符串">3.4.4 强制转换为字符串</h4><p>强转</p><ul class="lvl-0"><li class="lvl-2"><p>str()</p></li></ul><h4 id="3-4-5-将字符串转换为整数">3.4.5 将字符串转换为整数</h4><p>将字符串转换为整数</p><ul class="lvl-0"><li class="lvl-2"><p>int</p></li><li class="lvl-2"><p>float</p><ul class="lvl-2"><li class="lvl-4">特定的字符串</li></ul></li></ul><h4 id="3-4-6-字符串数据的转换">3.4.6 字符串数据的转换</h4><p>如果字符串含一个字符或一个文字时</p><ul class="lvl-0"><li class="lvl-2"><p>char(x):返回x的字符</p><ul class="lvl-2"><li class="lvl-4">x是整数(ADCII码值或Unicode码值)</li></ul></li><li class="lvl-2"><p>ord(x):将单个字符或文字转换为Unicode码值</p><ul class="lvl-2"><li class="lvl-4">如果是英文字符,Unicode码值与ASCII码值一样</li></ul></li></ul><h4 id="3-4-7-字符串与整数相乘产生字符串复制效果">3.4.7 字符串与整数相乘产生字符串复制效果</h4><h4 id="3-4-8-聪明地使用字符串加法和换行字符-n">3.4.8 聪明地使用字符串加法和换行字符\n</h4><blockquote><p>str = str1 + “\n” + str2 + “\n” + str3</p></blockquote><h4 id="3-4-9-字符串前加r">3.4.9 字符串前加r</h4><p>字符串前加r</p><p>可以防止逸出字符被转译(相当于取消逸出字符的功能)</p><h2 id="第四章-基本输入与输出">第四章 基本输入与输出</h2><h3 id="4-1-Python的辅助说明help">4.1 Python的辅助说明help()</h3><p>help()</p><ul class="lvl-0"><li class="lvl-2"><p>可以列出某一个Python的指令或函数的使用说明</p></li></ul><h3 id="4-2-格式化输出数据使用print">4.2 格式化输出数据使用print()</h3><h4 id="4-2-1-函数print-的基本用法">4.2.1 函数print()的基本用法</h4><p><code>print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)</code></p><ul class="lvl-0"><li class="lvl-2"><p>value表示输出的数据,多条输出时用逗号隔开</p></li><li class="lvl-2"><p>sep表示多条输出时的分割字符</p></li><li class="lvl-2"><p>end输出结束时插入的字符</p></li><li class="lvl-2"><p>file数据输出位置</p></li><li class="lvl-2"><p>flush是否清楚数据流的缓冲区</p></li></ul><h4 id="4-2-2-格式化print-输出">4.2.2 格式化print()输出</h4><p><code>print(&quot;...输出格式区...&quot; % (变量系列区, ... ))</code></p><ul class="lvl-0"><li class="lvl-2"><p>输出格式区中可放置变量系列区所对应的格式化字符</p><ul class="lvl-2"><li class="lvl-4">%d:整数</li><li class="lvl-4">%f:浮点数</li><li class="lvl-4">%x:16进位整数</li><li class="lvl-4">%o:8进位整数</li><li class="lvl-4">%s:字符串</li></ul></li><li class="lvl-2"><p>注意</p><ul class="lvl-2"><li class="lvl-4">‘,&quot;,’‘’,“”&quot;均可</li><li class="lvl-4">一个变量时可不加()</li><li class="lvl-4">可以多条输出</li><li class="lvl-4">输出格式区可以用一个字符串变量取代</li><li class="lvl-4">整数与浮点数可以分别以%d、%f、%s格式化</li><li class="lvl-4">浮点数以整数%d格式化后,小数数据将被舍去</li></ul></li></ul><h4 id="4-2-3-精准控制格式化的输出">4.2.3 精准控制格式化的输出</h4><p>精准控制格式化的输出</p><ul class="lvl-0"><li class="lvl-2"><p>%(+|-)nd:格式化整数输出</p></li><li class="lvl-2"><p>%(+|-)<a href="http://m.nf">m.nf</a>:格式化浮点数输出</p></li><li class="lvl-3"><p>%(+|-)nx:格式化16进位整数输出</p></li><li class="lvl-2"><p>%(+|-)no:格式化8进位整数输出</p></li><li class="lvl-2"><p>%(-)ns:格式化字符串输出</p></li><li class="lvl-2"><p>注意</p><ul class="lvl-2"><li class="lvl-4">浮点数:m代表保留多少格数供输出(包含小数点),n是小数数据保留格数(四舍五入)</li><li class="lvl-4">其他数据格式:n是保留多少格数空间,如果保留格数空间不足将完整输出数据,如果保留格数空间太多则数据靠右对齐</li><li class="lvl-4">加负号表示保留格数空间有多时,靠左输出</li><li class="lvl-4">加正号表示输出数据是正值时,加上正值符号</li></ul></li></ul><h4 id="4-2-4-format-函数">4.2.4 format()函数</h4><p><code>print(&quot;...输出格式区...&quot;.format(变量系列区,...))</code></p><ul class="lvl-0"><li class="lvl-2"><p>输出格式区内的字符串变量使用<code>&#123; &#125;</code>表示</p></li></ul><h4 id="4-2-5-字符串输出与基本排版的应用">4.2.5 字符串输出与基本排版的应用</h4><h4 id="4-2-6-一个无聊的操作">4.2.6 一个无聊的操作</h4><h3 id="4-3-输出数据到文件">4.3 输出数据到文件</h3><h4 id="4-3-1-打开一个文件open">4.3.1 打开一个文件open()</h4><p><code>file_obj = open(file, mode=&quot;r&quot;)</code></p><ul class="lvl-0"><li class="lvl-2"><p>返回文件对象</p></li><li class="lvl-2"><p>file:欲打开的文件</p></li><li class="lvl-2"><p>mode:打开文件的方式</p><ul class="lvl-2"><li class="lvl-4">可以省略mode=</li><li class="lvl-4">r:读取(默认)</li><li class="lvl-4">w:写入(有内容将被覆盖)</li><li class="lvl-4">a:追加</li><li class="lvl-4"><strong>r模式时,文件不存在则报错,w,a模式时,文件不存在则创建</strong></li><li class="lvl-4">x:打开一个新的文件供写入,如果所打开的文件存在则报错</li><li class="lvl-4">b:打开二进制文件模式</li><li class="lvl-4">t:打开文本(txt)文件模式(默认)</li><li class="lvl-4"><strong>注意大小写</strong></li><li class="lvl-4">+:打开文件供更新用</li><li class="lvl-4">多项模式<ul class="lvl-4"><li class="lvl-6">wb等</li></ul></li></ul></li></ul><p>close()</p><ul class="lvl-0"><li class="lvl-2"><p>关闭文件</p></li></ul><h4 id="4-3-2-使用print-函数输出数据到文件">4.3.2 使用print()函数输出数据到文件</h4><blockquote><p>print(“output text”, file=file_obj)</p></blockquote><h3 id="4-4-数据输入input">4.4 数据输入input()</h3><p><code>value = input(&quot;prompt: &quot;)</code></p><ul class="lvl-0"><li class="lvl-2"><p>无论输入的数据是字符串或是数值数据,value一律是字符串数据</p></li></ul><h3 id="4-5-列出所有内置函数dir">4.5 列出所有内置函数dir()</h3><p>列出Python所有内置函数</p><ul class="lvl-0"><li class="lvl-2"><p><code>dir(__builtins__)</code></p></li></ul><h2 id="第五章-程序流程控制使用if语句">第五章 程序流程控制使用if语句</h2><h3 id="5-1-关系运算符">5.1 关系运算符</h3><p>关系运算符</p><ul class="lvl-0"><li class="lvl-2"><p><code>&gt;</code></p></li><li class="lvl-2"><p><code>&gt;=</code></p></li><li class="lvl-2"><p><code>&lt;</code></p></li><li class="lvl-2"><p><code>&lt;=</code></p></li><li class="lvl-2"><p><code>==</code></p></li><li class="lvl-2"><p><code>!=</code></p></li></ul><h3 id="5-2-逻辑运算符">5.2 逻辑运算符</h3><p>逻辑运算符</p><ul class="lvl-0"><li class="lvl-2"><p><code>and</code></p></li><li class="lvl-2"><p><code>or</code></p></li><li class="lvl-2"><p><code>not</code></p></li></ul><h3 id="5-3-if语句">5.3 if语句</h3><p>if语句</p><ul class="lvl-0"><li class="lvl-2"><blockquote><p>if (条件判断):</p><p>​程序代码区块</p></blockquote></li><li class="lvl-2"><p>如果只有一道命令(多条命令时可以用<code>;</code>隔开)</p><ul class="lvl-2"><li class="lvl-4"><blockquote><p>if (条件判断):程序代码区块</p></blockquote></li></ul></li></ul><p><mark>注意</mark></p><ul class="lvl-0"><li class="lvl-2"><p><strong>Python内是使用内缩方式区隔if语句的程序代码区块，编辑程序时可以用Tab键内缩或是直接内缩4个字符空间</strong></p></li><li class="lvl-2"><p><strong>也可以内缩5个字符空间，但是相同程序区块必须有相同的内缩空间</strong></p></li></ul><h3 id="if…else语句">if…else语句</h3><p>if…else语句</p><ul class="lvl-0"><li class="lvl-2"><blockquote><p>if (条件判断):</p><p>​程序代码区块一</p><p>else:</p><p>​程序代码区块二</p></blockquote></li></ul><h3 id="5-5-if…elif…else语句">5.5 if…elif…else语句</h3><p>if…elif…else语句</p><ul class="lvl-0"><li class="lvl-2"><blockquote><p>if (条件判断一):</p><p>​程序代码区块一</p><p>elif (条件判断二):</p><p>​程序代码区块二</p><p>…</p><p>else:</p><p>​程序代码区块n</p></blockquote></li></ul><h3 id="5-6-嵌套的if语句">5.6 嵌套的if语句</h3><h3 id="5-7-尚未设定的变量值None">5.7 尚未设定的变量值None</h3><p>None</p><ul class="lvl-0"><li class="lvl-2"><p><strong>变量值</strong></p></li><li class="lvl-2"><p><code>&lt;class 'NoneType'&gt;</code></p></li></ul><h2 id="第六章-列表-List">第六章 列表(List)</h2><h3 id="6-1-认识列表">6.1 认识列表</h3><h4 id="6-1-1-列表的基本定义">6.1.1 列表的基本定义</h4><p>列表</p><ul class="lvl-0"><li class="lvl-2"><blockquote><p>list = [元素1, … , 元素n]</p></blockquote></li></ul><h4 id="6-1-2-读取列表元素">6.1.2 读取列表元素</h4><p>读取列表元素</p><ul class="lvl-0"><li class="lvl-2"><p>通过索引(从0开始)</p></li><li class="lvl-2"><p>等号多重指定观念应用在列表</p><ul class="lvl-2"><li class="lvl-4"><blockquote><p>value1, …, valuen = list</p></blockquote></li><li class="lvl-4"><p><strong>多重指定变数的数量必须与列表元素的个数相同</strong></p></li></ul></li></ul><h4 id="6-1-3-列表切片-list-slices">6.1.3 列表切片(list slices)</h4><p>列表切片</p><ul class="lvl-0"><li class="lvl-2"><p>list[start:end]—&gt;[start, end-1]</p></li><li class="lvl-2"><p>list[:n]—&gt;[0, n-1]</p></li><li class="lvl-2"><p>list[n:]—&gt;[n, end]</p></li><li class="lvl-2"><p>list[-n:]—&gt;列表后n名</p></li><li class="lvl-2"><p>list[:-n]—&gt;列表前<code>len-n</code>名</p></li><li class="lvl-2"><p>list[:]—&gt;取得所有元素</p></li><li class="lvl-2"><p>list[start : end : step]</p><ul class="lvl-2"><li class="lvl-4">step表示步距,为负时相当于先逆向再操作</li></ul></li></ul><h4 id="6-1-4-列表索引值是-1">6.1.4 列表索引值是-1</h4><p>索引值是-1</p><ul class="lvl-0"><li class="lvl-2"><p>表示是最后一个列表元素</p></li><li class="lvl-2"><p><strong>-n…</strong></p></li></ul><h4 id="6-1-5-列表统计资料-最大值max-最小值min-总和sum">6.1.5 列表统计资料,最大值max(),最小值min(),总和sum()</h4><p>最大值max(),最小值min(),总和sum()</p><ul class="lvl-0"><li class="lvl-2"><p>列表内容全部是数值$\rightarrow$max,min,sum</p></li><li class="lvl-2"><p>全部是字符或字符串$\rightarrow$max()函数获得列表unicode码值的最大值,min()获得最小值,sum()不可使用</p></li><li class="lvl-2"><p>可以结合列表切片一起使用</p></li></ul><h4 id="6-1-6-列表个数len">6.1.6 列表个数len()</h4><p>len()</p><ul class="lvl-0"><li class="lvl-2"><blockquote><p>len(list)</p></blockquote></li></ul><h4 id="6-1-7-更改列表元素的内容">6.1.7 更改列表元素的内容</h4><p>更改列表元素的内容</p><ul class="lvl-0"><li class="lvl-2"><p>通过索引更改</p></li></ul><h4 id="6-1-8-列表的相加">6.1.8 列表的相加</h4><p>列表的相加</p><ul class="lvl-0"><li class="lvl-2"><p><code>+</code></p></li></ul><h4 id="6-1-9-列表乘以一个数字">6.1.9 列表乘以一个数字</h4><p>列表乘以一个数字</p><ul class="lvl-0"><li class="lvl-2"><p>将列表乘以一个数字，这个数字相当于是列表元素重复次数</p></li></ul><h4 id="6-1-10-列表元素的加法运作">6.1.10 列表元素的加法运作</h4><blockquote><p>value = list[0] + list[1]</p></blockquote><h4 id="6-1-11-删除列表元素">6.1.11 删除列表元素</h4><p>删除列表元素</p><ul class="lvl-0"><li class="lvl-2"><p>del list[i]</p></li><li class="lvl-2"><p>del list[start: end]—&gt;[start, end-1]</p></li><li class="lvl-2"><p>del list[start: end: step]</p><ul class="lvl-2"><li class="lvl-4">step可以为负数</li></ul></li><li class="lvl-2"><p>该方法缺点是:元素删除后我们无法得知删除的是什么内容</p></li></ul><h4 id="6-1-12-列表为空列表的判断">6.1.12 列表为空列表的判断</h4><blockquote><p>list = []</p><p>len(list)# 0</p></blockquote><h4 id="6-1-13-删除列表">6.1.13 删除列表</h4><blockquote><p>del list</p></blockquote><h3 id="6-2-Python简单的面向对象观念">6.2 Python简单的面向对象观念</h3><p>面向对象</p><ul class="lvl-0"><li class="lvl-2"><p>所有数据皆算是一个对象</p></li><li class="lvl-2"><p>整数、浮点数、字符串或列表等皆是</p></li></ul><h4 id="6-2-1-字符串的方法">6.2.1 字符串的方法</h4><p>几个常用的方法</p><ul class="lvl-0"><li class="lvl-3"><p>lower( )：将字符串转成小写字</p></li><li class="lvl-2"><p>upper( )：将字符串转成大写字</p></li><li class="lvl-2"><p>title( )：将字符串转成<strong>第一个</strong>字母大写，其他是小写</p></li><li class="lvl-2"><p>rstrip( )：删除字符串尾端多余的空白</p></li><li class="lvl-2"><p>lstrip( )：删除字符串开始端多余的空白</p></li><li class="lvl-2"><p>strip( )：删除字符串头尾两边多余的空白</p></li><li class="lvl-2"><p><mark>均不改变原值</mark></p></li></ul><h4 id="6-2-2-改变字符串大小写">6.2.2 改变字符串大小写</h4><h4 id="6-2-3-dir-获得系统内部对象的方法">6.2.3 dir()获得系统内部对象的方法</h4><blockquote><p>str = “abc”</p><p>dir(str)</p><p>help(对象.方法名称)</p></blockquote><h3 id="6-3-获得列表的方法">6.3 获得列表的方法</h3><h3 id="6-4-增加与删除列表元素">6.4 增加与删除列表元素</h3><h4 id="6-4-1-在列表末端增加元素append">6.4.1 在列表末端增加元素append()</h4><blockquote><p>list.append(新增元素)</p></blockquote><h4 id="6-4-2-插入列表元素insert">6.4.2 插入列表元素insert()</h4><blockquote><p>list.insert(索引, 元素内容)# 索引是插入位置</p></blockquote><h4 id="6-4-3-删除列表元素pop">6.4.3 删除列表元素pop()</h4><blockquote><p>value = list.pop()# 默认删除末端元素</p><p>value = list.pop(i)# 删除指定索引值的列表元素</p></blockquote><h4 id="6-4-4-删除指定的元素remove">6.4.4 删除指定的元素remove()</h4><blockquote><p>list.remove(想删除的元素内容)# 若多个则删除第一个,未找到则报错</p></blockquote><h3 id="6-5-列表的排序">6.5 列表的排序</h3><h4 id="6-5-1-颠倒排序reverse">6.5.1 颠倒排序reverse()</h4><blockquote><p>list.reverse()# 颠倒原列表</p></blockquote><h4 id="6-5-2-sort-排序">6.5.2 sort()排序</h4><p>sort()</p><ul class="lvl-0"><li class="lvl-2"><p><strong>针对纯数值元素与纯英文字符串</strong></p></li><li class="lvl-2"><p><code>list.sort()    # 排序原列表</code></p></li><li class="lvl-2"><p>默认从小到大排列,增加参数<code>reverse=True</code>可以实现从大到小</p></li></ul><h4 id="6-5-3-sorted-排序">6.5.3 sorted()排序</h4><p>sorted()</p><ul class="lvl-0"><li class="lvl-2"><p>原列表的顺序不更改</p></li><li class="lvl-2"><p><code>new_list = sorted(list)</code></p></li><li class="lvl-2"><p>从大到小,则增加<code>reverse=True</code>参数</p></li></ul><h3 id="6-6-进阶列表操作">6.6 进阶列表操作</h3><h4 id="6-6-1-index">6.6.1 index()</h4><p>index()</p><ul class="lvl-0"><li class="lvl-2"><p><code>索引值 = list.index(搜寻的元素)</code></p></li><li class="lvl-2"><p>如果搜寻的元素不在列表会出现错误</p></li></ul><h4 id="6-6-2-count">6.6.2 count()</h4><p>count()</p><ul class="lvl-0"><li class="lvl-2"><p><code>次数 = list.count(搜寻元素)</code></p></li><li class="lvl-2"><p><s>如果搜寻的元素不在列表会出现错误(验证得并不会)</s></p></li></ul><h4 id="6-6-3-列表元素的组合join">6.6.3 列表元素的组合join()</h4><p>join()</p><ul class="lvl-0"><li class="lvl-2"><p><code>char.join(seq)# seq必须是列表,元组等序列数据</code></p></li><li class="lvl-2"><p>char是各元素间的分割字符,可以是单一字符,也可以是字符串</p></li><li class="lvl-2"><p>seq只能由纯字符串组成</p></li></ul><h3 id="6-7-列表内含列表">6.7 列表内含列表</h3><blockquote><p>num = [1, 2, 3, 4, 5, [6, 7, 8]]</p><p>num[索引1] [索引2]</p></blockquote><h4 id="6-7-1-再谈append">6.7.1 再谈append()</h4><blockquote><p>append()也可以将某一列表插入另一列表的末端</p></blockquote><h4 id="6-7-2-extend">6.7.2 extend()</h4><blockquote><p>相当于两个列表连接</p></blockquote><h3 id="6-8-列表的复制">6.8 列表的复制</h3><h4 id="6-8-1-列表的深复制-deep-copy">6.8.1 列表的深复制-deep copy</h4><p>深复制</p><ul class="lvl-0"><li class="lvl-2"><p>只要有一个列表更改元素会影响到另一个列表同步更改的复制</p></li><li class="lvl-2"><p>说到底还是指向相同</p></li><li class="lvl-2"><p><code>copy = list</code></p></li></ul><h4 id="6-8-2-地址的观念">6.8.2 地址的观念</h4><p>id()</p><ul class="lvl-0"><li class="lvl-2"><p>获得变量的地址</p></li><li class="lvl-2"><p><code>id(x)</code></p></li><li class="lvl-2"><p><strong>整数,浮点数,字符串,布尔值相同的值在内存中只有一个实例</strong></p></li><li class="lvl-2"><p><strong>字符串可看成多个字符,验证得地址并不一定连续,每个字符只有一个实例</strong></p></li></ul><h4 id="6-8-3-列表的浅复制-shallow-copy">6.8.3 列表的浅复制-shallow copy</h4><p>浅复制</p><ul class="lvl-0"><li class="lvl-2"><p>执行复制后当一个列表改变后，不会影响另一个列表的内容</p></li><li class="lvl-2"><p><code>copy = list[:]</code></p></li><li class="lvl-2"><p><strong>如果包含子列表,只会拷贝子列表的地址</strong></p></li></ul><h3 id="6-9-再谈字符串">6.9 再谈字符串</h3><p>字符串</p><ul class="lvl-0"><li class="lvl-2"><p>可以将单一字符串当作是一个序列</p></li><li class="lvl-2"><p>序列由字符组成</p></li><li class="lvl-2"><p><strong>但字符串内的单一元素内容是不可更改的</strong></p></li></ul><h4 id="6-9-1-字符串的索引">6.9.1 字符串的索引</h4><blockquote><p>value = string[0]</p><p>value = string[-1]</p></blockquote><h4 id="6-9-2-字符串切片">6.9.2 字符串切片</h4><p>字符串切片</p><ul class="lvl-0"><li class="lvl-2"><p>string[start: end]</p></li><li class="lvl-2"><p>string[: end]</p></li><li class="lvl-2"><p>string[start: ]</p></li><li class="lvl-2"><p>string[start: end: step]</p></li><li class="lvl-2"><p><strong>可正可负</strong></p></li></ul><h4 id="6-9-3-函数或方法">6.9.3 函数或方法</h4><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>len(string)</code></td><td style="text-align:center">计算字符串长度</td></tr><tr><td style="text-align:center"><code>max(string)</code></td><td style="text-align:center">最大值(字符串不可为空)</td></tr><tr><td style="text-align:center"><code>min(string)</code></td><td style="text-align:center">最小值(字符串不可为空)</td></tr></tbody></table><h4 id="6-9-4-将字符串转成列表">6.9.4 将字符串转成列表</h4><blockquote><p>value = list(string)</p></blockquote><h4 id="6-9-5-切片赋值的应用">6.9.5 切片赋值的应用</h4><blockquote><p># 将字符串改为列表后,就可以使用切片更改列表内容了</p><p>value = list(‘python-大蟒蛇’)</p><p>value[-3:] = “蒙提派森的飞行马戏团”</p><p>&gt;&gt;&gt; value</p><p>[‘p’, ‘y’, ‘t’, ‘h’, ‘o’, ‘n’, ‘-’, ‘蒙’, ‘提’, ‘派’, ‘森’, ‘的’, ‘飞’, ‘行’, ‘马’, ‘戏’, ‘团’]</p></blockquote><h4 id="6-9-6-使用split-处理字符串">6.9.6 使用split()处理字符串</h4><p>split()</p><ul class="lvl-0"><li class="lvl-2"><p><code>string.split()</code></p></li><li class="lvl-2"><p>将字符串以空格为分隔符，将字符串拆开，变成一个列表</p></li><li class="lvl-2"><p><strong>字符串可以为空</strong></p></li></ul><h3 id="6-10-in和not-in表达式">6.10 in和not in表达式</h3><p>in和not in</p><ul class="lvl-0"><li class="lvl-2"><p>用于判断一个对象是否属于另一个对象，对象可以是字符串(string)、列表(list)、元组(Tuple)、字典(Dict)</p></li><li class="lvl-2"><blockquote><p>boolean_value = obj1 in obj2</p><p>boolean_value = obj1 not in obj2</p></blockquote></li></ul><h3 id="6-11-is或is-not表达式">6.11 is或is not表达式</h3><p>is或is not</p><ul class="lvl-0"><li class="lvl-2"><p>用于比较两个对象是否相同，在此所谓相同并不只是内容相同，而是指对象变量指向相同的内存</p></li><li class="lvl-2"><p>对象可以是变量、字符串、列表、元组(Tuple)、字典(Dict)</p></li><li class="lvl-2"><blockquote><p>boolean_value = obj1 is obj2</p><p>boolean_value = obj1 is not obj2</p></blockquote></li></ul><h4 id="6-11-1-整数变量在内存地址的考察">6.11.1 整数变量在内存地址的考察</h4><blockquote><p><strong>如果两个整数（或浮点数）变量内容相同，它们会使用相同的内存地址存储此变量</strong></p></blockquote><h4 id="6-11-2-将is和is-not表达式应用在整数变量">6.11.2 将is和is not表达式应用在整数变量</h4><blockquote><p>x = 1</p><p>y = x/y = 1</p></blockquote><h4 id="6-11-3-将is和is-not表达式应用在列表变量">6.11.3 将is和is not表达式应用在列表变量</h4><blockquote><p>list = []</p><p>copy = list/copy = list[:]</p></blockquote><h3 id="6-12-enumerate对象">6.12 enumerate对象</h3><p>enumerate()</p><ul class="lvl-0"><li class="lvl-2"><p>可以将iterable类数值的元素用计数值与元素配对方式传回，返回的数据称enumerate对象</p></li><li class="lvl-2"><p>iterable类数值可以是列表(list)、元组(tuple)、集合(set)等</p><ul class="lvl-2"><li class="lvl-4">验证的字符串也可以</li></ul></li><li class="lvl-2"><p><code> obj = enumerate(iterable[, start = 0])# 如果省略start = 设定，默认值是0</code></p></li><li class="lvl-2"><p>可以使用list( )将enumerate对象转成列表，使用tuple( )将enumerate对象转成元组</p></li></ul><h2 id="第七章-循环设计">第七章 循环设计</h2><h3 id="7-1-基本for循环">7.1 基本for循环</h3><p>for</p><ul class="lvl-0"><li class="lvl-2"><blockquote><p>for var in 可迭代对象:# iterable object</p><p>​程序代码区块</p></blockquote></li><li class="lvl-2"><p>可迭代对象(iterable object)可以是列表、元组、字典与集合或range( )</p><ul class="lvl-2"><li class="lvl-4">经验证,字符串也可以</li></ul></li></ul><h4 id="7-1-1-for循环基本运作">7.1.1 for循环基本运作</h4><h4 id="7-1-2-如果程序代码区块只有一行">7.1.2 如果程序代码区块只有一行</h4><blockquote><p>for var in 可迭代对象:程序代码区块</p><p># 如果有多行,可以用<code>;</code>分割</p></blockquote><h4 id="7-1-3-有多行的程序代码区块">7.1.3 有多行的程序代码区块</h4><p><mark>注意缩排处理</mark></p><h4 id="7-1-4-将for循环应用在列表区间元素">7.1.4 将for循环应用在列表区间元素</h4><blockquote><p>for var in list[: -1]:</p><p>​print(var)</p></blockquote><p>补充概念</p><ul class="lvl-0"><li class="lvl-2"><p><strong>升幂</strong>是指由小到大排列</p></li><li class="lvl-2"><p><strong>降幂</strong>是指由大到小排列</p></li></ul><h4 id="7-1-5-将for循环应用在数据类别的判断">7.1.5 将for循环应用在数据类别的判断</h4><p><code>str.endswith(suffix[, start[, end]])</code></p><ul class="lvl-0"><li class="lvl-2"><p>用于判断字符串是否以指定后缀结尾</p></li><li class="lvl-2"><p>可选参数</p><ul class="lvl-2"><li class="lvl-4">start$\rightarrow$开始位置</li><li class="lvl-4">end$\rightarrow$结束位置</li><li class="lvl-4">[start, end-1]</li></ul></li><li class="lvl-2"><p>与之对应的还有<code>startswith</code></p></li></ul><h4 id="7-1-6-删除列表内所有元素">7.1.6 删除列表内所有元素</h4><h3 id="7-2-range-函数">7.2 range()函数</h3><p>range()</p><ul class="lvl-0"><li class="lvl-2"><p>产生一个等差序列</p></li><li class="lvl-2"><p>又称这等差序列为可迭代对象(iterable object)，也可以称是range对象</p></li><li class="lvl-2"><blockquote><p>range(n)—&gt;(0, n-1)</p><p>range(start, stop)—&gt;(start, stop-1)</p><p>range(start, stop, step)</p></blockquote><ul class="lvl-2"><li class="lvl-4">step可以为负数,相当于<code>range(stop-1, start+1, |step|)</code></li><li class="lvl-4">条件不满足则产生空range对象(空序列)</li></ul></li></ul><h4 id="7-2-1-只有一个参数的range-函数的应用">7.2.1 只有一个参数的range()函数的应用</h4><h4 id="7-2-2-有2个参数的range-函数">7.2.2 有2个参数的range()函数</h4><h4 id="7-2-3-有3个参数的range-函数">7.2.3 有3个参数的range()函数</h4><h4 id="7-2-4-活用range-应用">7.2.4 活用range()应用</h4><blockquote><p>total = sum(range(n + 1))</p></blockquote><p><strong>可迭代对象的内置函数sum</strong></p><ul class="lvl-0"><li class="lvl-2"><p>并不是一次预留储存1, 2, … 10的内存空间</p></li><li class="lvl-2"><p>是只有一个内存空间，每次将迭代的指针放在此空间，然后执行sum( )运算</p></li><li class="lvl-2"><p>可以增加工作效率并节省内存空间</p></li></ul><h4 id="7-2-5-列表生成-list-generator-的应用">7.2.5 列表生成(list generator)的应用</h4><blockquote><p>新列表 = [表达式 for var in 可迭代对象]</p><p># 类似</p><p>for var in 可迭代对象:</p><p>​list.append(表达式)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span> = [[a, b, c] <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>) <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(a, <span class="number">20</span>) <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(b, <span class="number">20</span>) <span class="keyword">if</span> a ** <span class="number">2</span> + b ** <span class="number">2</span> == c ** <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span></span><br><span class="line">[[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">5</span>, <span class="number">12</span>, <span class="number">13</span>], [<span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>], [<span class="number">8</span>, <span class="number">15</span>, <span class="number">17</span>], [<span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>]]</span><br></pre></td></tr></table></figure><h4 id="7-2-6-打印含列表元素的列表">7.2.6 打印含列表元素的列表</h4><blockquote><p>for color, shape in result:</p><p>​…</p></blockquote><h4 id="7-2-7-生成含有条件的列表">7.2.7 生成含有条件的列表</h4><blockquote><p>新列表 = [表达式 for var in 可迭代对象 if 条件式]</p></blockquote><h3 id="7-3-进阶的for循环应用">7.3 进阶的for循环应用</h3><h4 id="7-3-1-嵌套for循环">7.3.1 嵌套for循环</h4><h4 id="7-3-2-强制离开for循环-break指令">7.3.2 强制离开for循环-break指令</h4><h4 id="7-3-3-for循环暂时停止不往下执行-continue指令">7.3.3 for循环暂时停止不往下执行-continue指令</h4><h4 id="7-3-4-for…else循环">7.3.4 for…else循环</h4><blockquote><p>for循环最后一次必定False,此时执行else后的语句块</p></blockquote><h3 id="7-4-while循环">7.4 while循环</h3><blockquote><p>按<strong>Ctrl+C</strong>键，中断程序的执行离开无限循环的陷阱</p></blockquote><h4 id="7-4-1-基本while循环">7.4.1 基本while循环</h4><h4 id="7-4-2-嵌套while循环">7.4.2 嵌套while循环</h4><h4 id="7-4-3-强制离开while循环-break指令">7.4.3 强制离开while循环-break指令</h4><h4 id="7-4-4-while循环暂时停止不往下执行-continue指令">7.4.4 while循环暂时停止不往下执行-continue指令</h4><h4 id="7-4-5-while循环条件表达式与对象">7.4.5 while循环条件表达式与对象</h4><blockquote><p>while fruit in fruits:</p><p>while 对象:</p></blockquote><p><mark>空字符串,空列表,空元组,空字典,0等—&gt;False</mark></p><h4 id="7-4-6-pass">7.4.6 pass</h4><blockquote><p>pass指令是什么事也不做，相当于占位</p></blockquote><h3 id="7-5-enumerate对象使用for循环解析">7.5 enumerate对象使用for循环解析</h3><blockquote><p>计数值    元素值</p><blockquote><p>for list in enumerate(lists)</p><p>for index list in enumerate(lists)</p></blockquote></blockquote><h2 id="第八章-元组-Tuple">第八章 元组(Tuple)</h2><blockquote><p>又称不可改变的列表</p><p>它的元素值与元素个数不可更改</p></blockquote><h3 id="8-1-元组的定义">8.1 元组的定义</h3><blockquote><p>tuple = (元素1, …, 元素n)</p><p># 如果元组内的元素只有一个，在定义时需在元素右边加上逗号<code>,</code></p></blockquote><h3 id="8-2-读取元组元素">8.2 读取元组元素</h3><blockquote><p>value = tuple[i]</p></blockquote><h3 id="8-3-遍历所有元组元素">8.3 遍历所有元组元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br></pre></td></tr></table></figure><h3 id="8-4-修改元组内容产生错误的实例">8.4 修改元组内容产生错误的实例</h3><blockquote><p>tuple对象不支持赋值</p></blockquote><h3 id="8-5-可以使用全新定义方式修改元组元素">8.5 可以使用全新定义方式修改元组元素</h3><blockquote><p># 如果我们想修改元组元素，可以使用重新定义元组方式处理</p><p>tuple = (元素1, …, 元素n)</p></blockquote><h3 id="8-6-元组切片">8.6 元组切片</h3><blockquote><p>tuple[start, end]</p><p>tuple[: n]</p><p>tuple[n: ]</p><p>tuple[start: end: step]</p></blockquote><h3 id="8-7-方法与函数">8.7 方法与函数</h3><blockquote><p>len(tuple)</p></blockquote><h3 id="8-8-列表与元组数据互换">8.8 列表与元组数据互换</h3><blockquote><p>list(): 元组—&gt;列表</p><p>tuple(): 列表—&gt;元组</p></blockquote><h3 id="8-9-其他常用的元组方法">8.9 其他常用的元组方法</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>max(tuple)</code></td><td style="text-align:center">获得元组内容最大值</td></tr><tr><td style="text-align:center"><code>min(tuple)</code></td><td style="text-align:center">获得元组内容最小值</td></tr></tbody></table><h3 id="8-10-enumerate对象使用在元组">8.10 enumerate对象使用在元组</h3><blockquote><p>&gt;&gt;&gt; tuple(enumerate)</p><p>((0, 0), (1, 1))</p></blockquote><p><mark>tuple(enumerate)或list(enumerate)后,enumerate对象值&quot;消失&quot;</mark></p><h3 id="8-11-zip">8.11 zip()</h3><p>zip()</p><ul class="lvl-0"><li class="lvl-2"><p>参数内容主要是可迭代(iterable)的对象</p></li><li class="lvl-2"><p>将相对应的元素打包成元组(tuple)，最后传给zip对象</p></li><li class="lvl-2"><blockquote><p>zip对象 = zip(obj1, …, objn)</p></blockquote><ul class="lvl-2"><li class="lvl-4"><strong>可迭代对象可以有多个,每个可迭代对象长度可以不等,以最短为标准</strong></li></ul></li><li class="lvl-2"><blockquote><p># 如果在zip( )函数内增加“*”符号，相当于可以unzip( )列表</p><p>tuple1, …, tuplen = zip(*zip对象)</p></blockquote></li></ul><h3 id="8-12-元组的功能">8.12 元组的功能</h3><p><strong>优点</strong></p><ol><li class="lvl-3"><p>可以更安全地保护数据</p><ul class="lvl-2"><li class="lvl-5">程序设计中有些数据是永远不会改变的</li></ul></li><li class="lvl-3"><p>增加程序执行速度</p><ul class="lvl-2"><li class="lvl-5">元组结构比列表更简单,占用较少的系统资源</li></ul></li></ol><h2 id="第九章-字典-Dict">第九章 字典(Dict)</h2><blockquote><p>非序列数据结构</p></blockquote><h3 id="9-1-字典基本操作">9.1 字典基本操作</h3><h4 id="9-1-1-定义字典">9.1.1 定义字典</h4><blockquote><p># 键的类型: 字典/列表不可以,其他都可以</p><p>dict = {key1: value1, …}</p></blockquote><h4 id="9-1-2-列出字典元素的值">9.1.2 列出字典元素的值</h4><blockquote><p>dict[key1]</p></blockquote><h4 id="9-1-3-增加字典元素">9.1.3 增加字典元素</h4><blockquote><p>dict[key] = value</p></blockquote><h4 id="9-1-4-更改字典元素内容">9.1.4 更改字典元素内容</h4><blockquote><p>dict[key] = value</p></blockquote><h4 id="9-1-5-删除字典特定元素">9.1.5 删除字典特定元素</h4><blockquote><p>del dict[key]</p></blockquote><h4 id="9-1-6-删除字典所有元素">9.1.6 删除字典所有元素</h4><blockquote><p># clear( )可以将字典的所有元素删除，此时字典仍然存在，不过将变成空的字典</p><p>dict.clear()</p></blockquote><h4 id="9-1-7-删除字典">9.1.7 删除字典</h4><blockquote><p>del dict</p></blockquote><h4 id="9-1-8-建立一个空字典">9.1.8 建立一个空字典</h4><blockquote><p>dict = {}</p></blockquote><h4 id="9-1-9-字典的复制">9.1.9 字典的复制</h4><blockquote><p>new_dict = dict.copy()</p></blockquote><h4 id="9-1-10-取得字典元素数量">9.1.10 取得字典元素数量</h4><blockquote><p>len(dict)</p></blockquote><h4 id="9-1-11-验证元素是否存在">9.1.11 验证元素是否存在</h4><blockquote><p>键 in dict</p></blockquote><h4 id="9-1-12-设计字典的可读性技巧">9.1.12 设计字典的可读性技巧</h4><blockquote><p>设计大型程序时，字典的元素内容很可能是由长字符串所组成，碰上这类情况建议从新的一行开始安置每一个元素</p></blockquote><h3 id="9-2-遍历字典">9.2 遍历字典</h3><h4 id="9-2-1-遍历字典的键-值">9.2.1 遍历字典的键-值</h4><p>items()</p><ul class="lvl-0"><li class="lvl-2"><blockquote><p>for key, value in dict.items():</p></blockquote></li><li class="lvl-2"><p>字典(dict)是一个无序的数据结构，Python只会保持键-值，不会关注元素的排列顺序</p></li></ul><h4 id="9-2-2-遍历字典的键">9.2.2 遍历字典的键</h4><p>keys()</p><ul class="lvl-0"><li class="lvl-2"><blockquote><p>for key in dict.keys():</p><p>for key in dict:</p></blockquote></li></ul><h4 id="9-2-3-排序与遍历字典">9.2.3 排序与遍历字典</h4><p>sorted()</p><ul class="lvl-0"><li class="lvl-2"><p>默认键值,从小打到,同一种数据类型</p></li><li class="lvl-2"><p><code>sorted(dict.values())</code></p></li></ul><h4 id="9-2-4-遍历字典的值">9.2.4 遍历字典的值</h4><p>values()</p><ul class="lvl-0"><li class="lvl-2"><p><code>dict.values()</code></p></li><li class="lvl-2"><p>键不可重复,值可以重复</p></li><li class="lvl-2"><p>如果不想重复,可以使用集合(set)观念使用<code>set(dict.values())</code>函数</p></li></ul><h3 id="9-3-建立字典列表">9.3 建立字典列表</h3><h3 id="9-4-字典内含列表元素">9.4 字典内含列表元素</h3><h3 id="9-5-字典内含字典">9.5 字典内含字典</h3><h3 id="9-6-while循环在字典的应用">9.6 while循环在字典的应用</h3><h3 id="9-7-字典常用的函数和方法">9.7 字典常用的函数和方法</h3><h4 id="9-7-1-len">9.7.1 len()</h4><blockquote><p>列出字典元素的个数</p></blockquote><h4 id="9-7-2-fromkeys">9.7.2 fromkeys()</h4><blockquote><p># <strong>建立字典的一种方法,使用seq序列建立字典,如果没有设定value则用None当字典键的值</strong></p><p>name_dict = dict.fromkeys(seq[, value])</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>.fromkeys([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">&#123;<span class="number">1</span>: [<span class="number">4</span>, <span class="number">5</span>], <span class="number">2</span>: [<span class="number">4</span>, <span class="number">5</span>], <span class="number">3</span>: [<span class="number">4</span>, <span class="number">5</span>]&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="9-7-3-get">9.7.3 get()</h4><p>get()</p><ul class="lvl-0"><li class="lvl-2"><p>搜寻字典的键，如果键存在则传回该键的值，如果不存在则传回默认值</p></li><li class="lvl-2"><pre><code class="language-python"># dict是欲搜寻的字典value = dict.get(key[, default=None])<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 9.7.4 setdefault()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setdefault()</span><br><span class="line"></span><br><span class="line">- 与`get()`基本相同</span><br><span class="line"></span><br><span class="line">- 使用`setdefault()`方法时若所搜寻的键不在,会将键-值加入字典,没有设定默认值则默认为`None`</span><br><span class="line"></span><br><span class="line">- ```python</span><br><span class="line">  # dict是欲搜寻的字典</span><br><span class="line">  value = dict.setdefault(key[, default=None])</span><br></pre></td></tr></table></figure></code></pre></li></ul><h4 id="9-7-5-pop">9.7.5 pop()</h4><p>pop()</p><ul class="lvl-0"><li class="lvl-2"><pre><code class="language-python"># dict是欲删除元素的字典value = dict.pop(key[, default])<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 找到时就将该元素从字典内删除,同时将删除键的值回传</span><br><span class="line"></span><br><span class="line">- 没找到则传回default设定的内容,没有设定则传回`KeyError`即异常</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 第十章 集合(Set)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">集合(Set)</span><br><span class="line"></span><br><span class="line">- 无序且每个元素唯一</span><br><span class="line">- **&quot;内容&quot;**不可变</span><br><span class="line">- 元素</span><br><span class="line">  - 整数(intger)、浮点数(float)、字符串(string)、元组(tuple)等</span><br><span class="line">  - 可变(mutable)内容列表(list)、字典(dict)、集合(set)等不可以是集合元素</span><br><span class="line">- 集合本身是可变的(mutable)，可以增加或删除集合的元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 10.1 建立集合</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 使用大括号`&#123; &#125;`或`set( )`函数建立集合</span><br><span class="line">&gt;</span><br><span class="line">&gt; 空集合只能用`set()`建立</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 10.1.1 使用大括号建立集合</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; \# 集合的特色是元素是唯一的，所以如果设定集合时有重复元素情形，**多的部分将被舍去**</span><br><span class="line">&gt;</span><br><span class="line">&gt; langs = &#123;&#x27;Python&#x27;, &#x27;C&#x27;, &#x27;Java&#x27;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 10.1.2 使用set()函数定义集合</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 1. 内置函数set()</span><br><span class="line">&gt; 2. set( )函数参数的内容可以是字符串(string)、列表(list)、元组(tuple)等</span><br><span class="line">&gt; 3. 原先字符串(string)、列表(list)、元组(tuple)的元素将被转成集合元素</span><br><span class="line">&gt; 4. 可以通过set()建立空集合</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 10.1.3 大数据与集合的应用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">列表中存在大量重复的数据如何解决?</span><br><span class="line"></span><br><span class="line">- `set()`---&gt;`list()`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 10.2 集合的操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| Python符号 |   说明   |</span><br><span class="line">| :--------: | :------: |</span><br><span class="line">|     &amp;      |   交集   |</span><br><span class="line">|     \|     |   并集   |</span><br><span class="line">|     -      |   差集   |</span><br><span class="line">|     ^      | 对称差集 |</span><br><span class="line">|     ==     |   等于   |</span><br><span class="line">|     !=     |  不等于  |</span><br><span class="line">|     in     |  是成员  |</span><br><span class="line">|   not in   | 不是成员 |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 10.2.1 交集(intersection)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; both = math &amp; physics</span><br><span class="line">&gt;</span><br><span class="line">&gt; AB = A.intersection(B)</span><br><span class="line">&gt;</span><br><span class="line">&gt; BA = B.intersection(A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 10.2.2 并集(union)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; allmember = math | physics</span><br><span class="line">&gt;</span><br><span class="line">&gt; AorB = A.union(B)</span><br><span class="line">&gt;</span><br><span class="line">&gt; BorA = B.union(A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 10.2.3 差集(difference)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; math_only = math - physics</span><br><span class="line">&gt;</span><br><span class="line">&gt; physics_only = physics - math</span><br><span class="line">&gt;</span><br><span class="line">&gt; A_B = A.difference(B)</span><br><span class="line">&gt;</span><br><span class="line">&gt; B_A = B.difference(A)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 10.2.4 对称差集(symmetric difference)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对称差集</span><br><span class="line"></span><br><span class="line">- A ^ B = A + B - AB</span><br><span class="line">- 使用`^`或者`symmetric_difference()`方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 10.2.5 等于</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; `==`可以得知两个集合是否相等</span><br><span class="line">&gt;</span><br><span class="line">&gt; ```python</span><br><span class="line">&gt; &gt;&gt;&gt; a = &#123;1&#125;</span><br><span class="line">&gt; &gt;&gt;&gt; b = &#123;1&#125;</span><br><span class="line">&gt; &gt;&gt;&gt; c = a</span><br><span class="line">&gt; &gt;&gt;&gt; a == b</span><br><span class="line">&gt; True</span><br><span class="line">&gt; &gt;&gt;&gt; a == c</span><br><span class="line">&gt; True</span><br></pre></td></tr></table></figure></code></pre></li></ul><h4 id="10-2-6-不等于">10.2.6 不等于</h4><blockquote><p><code>!=</code>可以得知2个集合是否不相等</p></blockquote><h4 id="10-2-7-是成员in">10.2.7 是成员in</h4><blockquote><p><code>in</code></p></blockquote><h4 id="10-2-8-不是成员not-in">10.2.8 不是成员not in</h4><blockquote><p><code>not in</code></p></blockquote><h3 id="10-3-适合集合的方法">10.3 适合集合的方法</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">add()</td><td style="text-align:center">增加一个元素到集合</td></tr><tr><td style="text-align:center">clear()</td><td style="text-align:center">删除集合所有元素</td></tr><tr><td style="text-align:center">copy()</td><td style="text-align:center">浅复制(shallow copy)方式复制集合</td></tr><tr><td style="text-align:center">difference_update()</td><td style="text-align:center">删除集合内与另一集合重复的元素</td></tr><tr><td style="text-align:center">discard()</td><td style="text-align:center">如果是集合成员则删除</td></tr><tr><td style="text-align:center">intersection_update()</td><td style="text-align:center">可以使用交集更新集合内容</td></tr><tr><td style="text-align:center">isdisjoint()</td><td style="text-align:center">如果两个集合没有交集返回True</td></tr><tr><td style="text-align:center">issubset()</td><td style="text-align:center">如果另一个集合包含这个集合返回True</td></tr><tr><td style="text-align:center">issuperset()</td><td style="text-align:center">如果这个集合包含另一个集合返回True</td></tr><tr><td style="text-align:center">pop()</td><td style="text-align:center">传回<strong>随机移除</strong>的元素,如果是空集合返回False</td></tr><tr><td style="text-align:center">remove()</td><td style="text-align:center">删除指定元素,如果不存在则返回<code>KeyError</code>异常</td></tr><tr><td style="text-align:center">symmetric_difference_update()</td><td style="text-align:center">使用对称差集更新集合内容</td></tr><tr><td style="text-align:center">update()</td><td style="text-align:center">使用并集更新集合内容</td></tr></tbody></table><h4 id="10-3-1-add">10.3.1 add()</h4><blockquote><p>A.add(新增元素)</p></blockquote><h4 id="10-3-2-copy">10.3.2 copy()</h4><blockquote><p>新集合 = 旧集合.copy()</p></blockquote><h4 id="10-3-3-remove">10.3.3 remove()</h4><blockquote><p># 不存在则<code>KeyError</code></p><p>A.remove(欲删除的元素)</p></blockquote><h4 id="10-3-4-discard">10.3.4 discard()</h4><blockquote><p># <strong>元素不存在也不会有错误产生,不管删除结果如何,这个方法会传回None</strong></p><p>value = A.discard(欲删除的元素)</p></blockquote><h4 id="10-3-5-pop">10.3.5 pop()</h4><blockquote><p># 随机移除,空集合则会产生<code>TypeError</code>错误</p><p>value = A.pop()</p></blockquote><h4 id="10-3-6-clear">10.3.6 clear()</h4><blockquote><p>clear()可以删除集合内的所有元素，传回值是None</p></blockquote><h4 id="10-3-7-isdisjoint">10.3.7 isdisjoint()</h4><blockquote><p># 如果两个集合没有共同的元素会传回True</p><p>ret_boolean = A.isdisjoint(B)</p></blockquote><h4 id="10-3-8-issubset">10.3.8 issubset()</h4><blockquote><p>如果另一个集合包含这个集合返回True</p></blockquote><h4 id="10-3-9-issuperset">10.3.9 issuperset()</h4><blockquote><p>如果另一个集合包含这个集合返回True</p></blockquote><h4 id="10-3-10-intersection-update">10.3.10 intersection_update()</h4><blockquote><p># A会更新,*B代表可以有一到多个集合,该方法会传回None</p><p>A.intersection_update(*B)</p></blockquote><h4 id="10-3-11-update">10.3.11 update()</h4><blockquote><p># 可以将一个集合的元素加到调用此方法的集合内</p><p>A.update(B)</p></blockquote><h4 id="10-3-12-difference-update">10.3.12 difference_update()</h4><blockquote><p># 删除集合内与另一集合重复的元素</p><p>A.difference_update(B)</p></blockquote><h4 id="10-3-13-symmetric-difference-update">10.3.13 symmetric_difference_update()</h4><blockquote><p># 使用对称差集更新集合内容</p><p>A.symmetric_difference_update(B)</p></blockquote><h3 id="10-4-适合集合的基本函数操作">10.4 适合集合的基本函数操作</h3><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">enumerate()</td><td style="text-align:center">传回连续整数配对的enumerate对象</td></tr><tr><td style="text-align:center">len()</td><td style="text-align:center">元素数量</td></tr><tr><td style="text-align:center">max()</td><td style="text-align:center">最大值</td></tr><tr><td style="text-align:center">min()</td><td style="text-align:center">最小值</td></tr><tr><td style="text-align:center">sorted()</td><td style="text-align:center">传回已经排序的列表,集合本身不变</td></tr><tr><td style="text-align:center">sum()</td><td style="text-align:center">总和</td></tr></tbody></table><h4 id="10-4-1-max-min-sum">10.4.1 max()/min()/sum()</h4><p>max()/min()/sum()</p><ul class="lvl-0"><li class="lvl-2"><p><strong>前提是元素内容是数值</strong></p></li><li class="lvl-2"><p>如果是字符或字符串，可以使用max( )列出unicode码的最大值、min( )列出unicode码的最小值，sum( )则不可用在字符或字符串元素</p></li></ul><h4 id="10-4-2-len">10.4.2 len()</h4><blockquote><p>len(set)</p></blockquote><h4 id="10-4-3-sorted">10.4.3 sorted()</h4><blockquote><p># 排序结果存储在新列表对象中，集合本身是不会更改的(因为无序)</p><p>list = sorted(set)</p></blockquote><h4 id="10-4-4-enumerate">10.4.4 enumerate()</h4><blockquote><p># 可以传回连续整数配对的enumerate对象</p><p>enumerate(set)</p><p>enumerate(set, start)</p></blockquote><h3 id="10-5-冻结集合frozenset">10.5 冻结集合frozenset</h3><p>frozenset</p><ul class="lvl-0"><li class="lvl-2"><p>不可变集合(immutable set),也可直译为冻结集合</p></li><li class="lvl-2"><p>新的类别(class)</p></li><li class="lvl-2"><p>设定后就不可更改</p></li><li class="lvl-2"><p>冻结集合的建立方式</p><ul class="lvl-2"><li class="lvl-4">使用frozenset( )函数</li></ul></li><li class="lvl-2"><p>不可变特性的优点</p><ul class="lvl-2"><li class="lvl-4">可以用它作字典的键(key)，也可以作为其他集合的元素</li></ul></li><li class="lvl-2"><p>函数</p><ul class="lvl-2"><li class="lvl-4">不可使用add( )或remove( )更改冻结集合的内容</li><li class="lvl-4">可以执行intersection( )、union()、difference( )、symmetric_difference( )、copy( )、issubset( )、issuperset( )、isdisjoint( )等方法</li></ul></li></ul><h2 id="第十一章-函数设计">第十一章 函数设计</h2><p>函数(function)的目的</p><ol><li class="lvl-3"><p>功能分割</p></li><li class="lvl-3"><p>避免重复代码</p></li></ol><h3 id="11-1-Python函数基本观念">11.1 Python函数基本观念</h3><h4 id="11-1-1-函数的定义">11.1.1 函数的定义</h4><p>函数的定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名称</span> (参数值<span class="number">1</span>[, 参数值<span class="number">2</span>, ...]):</span><br><span class="line"><span class="string">&quot;&quot;&quot;函数批注(docstring)&quot;&quot;&quot;</span></span><br><span class="line">程序代码区块</span><br><span class="line">    <span class="keyword">return</span> [返回值<span class="number">1</span>, 返回值<span class="number">2</span>, ...]</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>函数名称必须唯一</p></li><li class="lvl-2"><p>参数值可有可无</p></li><li class="lvl-2"><p>函数批注可有可无，3个双引号（或单引号）</p></li><li class="lvl-2"><p>不论是return或接续右边的返回值皆是可有可无</p></li></ul><h4 id="11-1-2-无参数无返回值的函数">11.1.2 无参数无返回值的函数</h4><h4 id="11-1-3-在Python-Shell执行函数">11.1.3 在Python Shell执行函数</h4><h3 id="11-2-函数的参数设计">11.2 函数的参数设计</h3><p><mark>两种参数传递方式可以混用</mark></p><h4 id="11-2-1-传递一个参数">11.2.1 传递一个参数</h4><h4 id="11-2-2-多个参数传递">11.2.2 多个参数传递</h4><h4 id="11-2-3-关键词参数-参数名称-值">11.2.3 关键词参数 参数名称=值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subtract</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>subtract(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ubtract(y = <span class="number">2</span>, x = <span class="number">3</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="10-2-4-参数默认值的处理">10.2.4 参数默认值的处理</h4><blockquote><p>函数设计时含有默认值的参数，必须放置在参数列的最右边</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">subtract</span>(<span class="params">x, y = <span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">return</span> x - y</span><br></pre></td></tr></table></figure></blockquote><h3 id="11-3-函数返回值">11.3 函数返回值</h3><h4 id="11-3-1-返回None">11.3.1 返回None</h4><blockquote><p>在一些程序语言，例如，C语言这个None就是NULL，None在Python中独立成为一个数据类型NoneType</p></blockquote><h4 id="11-3-2-简单返回数值数据">11.3.2 简单返回数值数据</h4><h4 id="11-3-3-返回多个数据的应用">11.3.3 返回多个数据的应用</h4><h4 id="11-3-4-简单返回字符串数据">11.3.4 简单返回字符串数据</h4><h4 id="11-3-5-再谈参数默认值">11.3.5 再谈参数默认值</h4><h4 id="11-3-6-函数返回字典数据">11.3.6 函数返回字典数据</h4><h4 id="11-3-7-将循环应用在建立VIP会员字典">11.3.7 将循环应用在建立VIP会员字典</h4><h3 id="11-4-调用函数时参数是列表">11.4 调用函数时参数是列表</h3><h4 id="11-4-1-基本传递列表参数的应用">11.4.1 基本传递列表参数的应用</h4><h4 id="11-4-2-在函数内修订列表的内容">11.4.2 在函数内修订列表的内容</h4><h4 id="11-4-3-使用副本传递列表">11.4.3 使用副本传递列表</h4><blockquote><p># 传递副本列表</p><p>fun(list[:])</p></blockquote><h3 id="11-传递任意数量的参数">11.传递任意数量的参数</h3><h4 id="11-5-1-基本传递处理任意数量的参数">11.5.1 基本传递处理任意数量的参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># “*”符号的参数代表可以有一到多个参数将传递到这个函数内</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">*values</span>):</span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">        s += value</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h4 id="11-5-2-设计含有一般参数与任意参数的函数">11.5.2 设计含有一般参数与任意参数的函数</h4><blockquote><p>任意数量的参数必须放在最右边</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">initial, *values</span>):</span><br><span class="line">    s = initial</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">        s += value</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="11-5-3-设计含有一般参数与任意数量的关键词参数">11.5.3 设计含有一般参数与任意数量的关键词参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">name, **values</span>):</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> values.items():</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>info(<span class="string">&#x27;xuan&#x27;</span>, age = <span class="number">20</span>, sex = <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">xuan</span><br><span class="line">(<span class="string">&#x27;age&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">(<span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;男&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="11-6-递归式函数设计recursive">11.6 递归式函数设计recursive</h3><p>递归式</p><ul class="lvl-0"><li class="lvl-2"><p>每次调用自己时,都会使范围越来越小</p></li><li class="lvl-2"><p>必须有出口</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factorial</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (n * factorial(n-<span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>factorial(<span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="11-7-局部变量与全局变量">11.7 局部变量与全局变量</h3><blockquote><p>Python程序在调用函数时会建立一个内存工作区间，在这个内存工作区间可以处理属于这个函数的变量，当函数工作结束，返回原先调用程序时，这个内存工作区间就被收回，原先存在的变量也将被销毁</p></blockquote><h4 id="11-7-1-全局变量可以在所有函数使用">11.7.1 全局变量可以在所有函数使用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python并不会检查函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">output</span>():</span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>meg = <span class="string">&quot;python&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>output()</span><br><span class="line">python</span><br></pre></td></tr></table></figure><h4 id="11-7-2-局部变量与全局变量使用相同的名称">11.7.2 局部变量与全局变量使用相同的名称</h4><blockquote><p>在局部变量所在的函数是使用局部变量内容，其他区域则是使用全局变量的内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">msg = <span class="string">&quot;B&quot;</span></span><br><span class="line"><span class="built_in">print</span>(msg)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg = <span class="string">&quot;A&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a()</span><br><span class="line">B</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg</span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="11-7-3-程序设计需要注意事项">11.7.3 程序设计需要注意事项</h4><p>有关局部变量的注意事项</p><ol><li class="lvl-3"><p>局部变量内容无法在其他函数引用</p></li><li class="lvl-3"><p>局部变量内容无法在主程序引用</p></li></ol><h3 id="11-8-匿名函数lambda">11.8 匿名函数lambda</h3><p>匿名函数</p><ul class="lvl-0"><li class="lvl-2"><p>一个没有名称的函数</p></li><li class="lvl-2"><p>也称lambda表达式</p></li><li class="lvl-2"><p>使用lambda来定义</p></li><li class="lvl-2"><p>通常会将匿名函数与Python的内置函数filter( )、map( )等共同使用，此时匿名函数将只是这些函数的参数</p></li></ul><h4 id="11-8-1-匿名函数lambda的语法">11.8.1 匿名函数lambda的语法</h4><blockquote><p>匿名函数最大特色是可以有许多的参数,但只能有一个程序码表达式,然后可以将执行结果返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arg1是参数，可以有多个参数，也可以没有参数</span></span><br><span class="line"><span class="keyword">lambda</span> arg1[, arg2, …, argn]:expression</span><br></pre></td></tr></table></figure></blockquote><h4 id="11-8-2-匿名函数使用与filter">11.8.2 匿名函数使用与filter()</h4><blockquote><p>匿名函数一般是用在不需要函数名称的场合</p><p>一些高阶函数(higher-order function)的参数可能是函数，这时就很适合使用匿名函数，同时让程序变得更简洁</p><p><strong>例如</strong>: <code>filter(function, iterable)</code></p><ul class="lvl-1"><li class="lvl-2"><p>将iterable每个元素item执行function(item),为True则组成新的筛选对象(filter object)返回</p></li><li class="lvl-2"><p>iterable(可以重复执行，例如，字符串string、列表list、集合set或元组tuple)</p></li></ul><p><mark>补充</mark></p><ul class="lvl-1"><li class="lvl-2"><p><code>表达式 if 条件判断 else 表达式</code></p></li></ul></blockquote><h4 id="11-8-3-匿名函数使用与map">11.8.3 匿名函数使用与map()</h4><p>map()</p><ul class="lvl-0"><li class="lvl-2"><p><code>map(function, iterable)</code></p></li><li class="lvl-2"><p>将iterable每个元素item执行function(item),然后将函数执行结果组成新的筛选对象(filter object)返回</p></li><li class="lvl-2"><p><strong>只有在转换为其他数据类型(如列表)时才会将数据和函数关联产生输出,同时数据将被清空</strong></p></li></ul><h3 id="11-9-pass与函数">11.9 pass与函数</h3><blockquote><p>先规划各个函数功能,然后逐一完成各个函数设计,在程序完成前可以将尚未完成的函数内容加上pass</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="11-10-type关键字应用在函数">11.10 type关键字应用在函数</h3><blockquote><p>输出函数的数据类型—&gt;<code>&lt;class 'function'&gt;</code></p><p>匿名函数的数据类型—&gt;<code>&lt;class 'function'&gt;</code></p><p>内置函数的数据类型—&gt;<code>&lt;class 'builtin_function_or_method'&gt;</code></p></blockquote><h2 id="第十二章-类-面向对象的程序设计">第十二章 类-面向对象的程序设计</h2><p>面向对象</p><ul class="lvl-0"><li class="lvl-2"><p>Python是一种面向对象的编程(Object Oriented Programming)</p></li><li class="lvl-2"><p>在Python中其实所有的数据类型皆是对象</p></li><li class="lvl-2"><p>Python允许程序设计师自创数据类型-类(class)</p></li><li class="lvl-2"><p>设计程序时可以将世间万物分组归类，然后使用类(class)定义你的分类</p></li></ul><h3 id="12-1-类的定义与使用">12.1 类的定义与使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类名第一个字母大写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>():</span><br><span class="line">    <span class="comment"># 定义属性</span></span><br><span class="line">    <span class="comment"># 定义方法</span></span><br></pre></td></tr></table></figure><h4 id="12-1-1-定义类">12.1.1 定义类</h4><h4 id="12-1-2-操作类的属性与方法">12.1.2 操作类的属性与方法</h4><blockquote><p>object = ClassName()</p><p>object.类的属性</p><p>object.类的方法()</p></blockquote><h4 id="12-1-3-类的构造函数">12.1.3 类的构造函数</h4><p>初始化方法</p><ul class="lvl-0"><li class="lvl-2"><p><code>__init__</code></p></li><li class="lvl-2"><p>又称构造方法</p></li><li class="lvl-2"><p><strong>所有方法都要加一个self参数</strong></p></li><li class="lvl-2"><p>默认创建无参构造方法</p></li></ul><h4 id="12-1-4-属性初始值的设定">12.1.4 属性初始值的设定</h4><blockquote><p>初始值一般在<code>__init__()</code>方法内设定</p></blockquote><h3 id="12-2-类的访问权限——封装-encapsulation">12.2 类的访问权限——封装(encapsulation)</h3><p>访问权限</p><ul class="lvl-0"><li class="lvl-2"><p>公有(public)</p></li><li class="lvl-2"><p>私有(private)</p></li></ul><h4 id="12-2-1-私有属性">12.2.1 私有属性</h4><blockquote><p>定义时在属性名称前面增加__(2个底线)</p></blockquote><h4 id="12-2-2-私有方法">12.2.2 私有方法</h4><blockquote><p>定义方式与私有属性相同，只要在方法前面加上__(2个底线)符号即可</p></blockquote><h3 id="12-3-类的继承">12.3 类的继承</h3><p>类的继承</p><ul class="lvl-0"><li class="lvl-2"><p>在面向对象程序设计中类是可以继承的，其中被继承的类称父类(parent class)或基类(base class)，继承的类称子类(child class)或衍生类(derived class)</p></li><li class="lvl-2"><p>类继承的最大优点是许多父类的公有方法或属性，在子类中不用重新设计，可以直接引用</p></li><li class="lvl-2"><p><strong>衍生类 = 基类公有属性和方法 + 自有的属性和方法</strong></p></li><li class="lvl-2"><p><strong>在程序设计时，基类(base class)必须在衍生类(derived class)前面</strong></p></li><li class="lvl-2"><p>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClassName</span>():</span><br><span class="line">    <span class="comment"># Base Class的内容</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClassName</span>(<span class="title class_ inherited__">BaseClassName</span>):</span><br><span class="line">    <span class="comment"># Derived Class的内容</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="12-3-1-衍生类继承基类的实例应用">12.3.1 衍生类继承基类的实例应用</h4><h4 id="12-3-2-如何取得基类的私有属性">12.3.2 如何取得基类的私有属性</h4><blockquote><p>定义一个公有方法返回私有属性的值</p></blockquote><h4 id="12-3-3-衍生类与基类有相同名称的属性">12.3.3 衍生类与基类有相同名称的属性</h4><blockquote><p>有可能衍生类的属性与方法名称和基类重复，碰上这个状况Python会先找寻衍生类是否有这个名称，如果有则先使用，如果没有则使用基类的名称内容</p></blockquote><h4 id="12-3-4-衍生类与基类有相同名称的方法">12.3.4 衍生类与基类有相同名称的方法</h4><blockquote><p>有可能衍生类的属性与方法名称和基类重复，碰上这个状况Python会先找寻衍生类是否有这个名称，如果有则先使用，如果没有则使用基类的名称内容</p></blockquote><p>多型(polymorphism)</p><ul class="lvl-0"><li class="lvl-2"><p>多型不一定需要是有父子关系的类</p></li><li class="lvl-2"><p>类似于<strong>方法多功能化</strong>，相同的函数名称，放入不同类型的对象可以产生不同的结果</p></li></ul><h4 id="12-3-5-衍生类引用基类的方法">12.3.5 衍生类引用基类的方法</h4><blockquote><p>衍生类引用基类的方法时需使用<code>super()</code></p></blockquote><h4 id="12-3-6-三代同堂的类与取得基类的属性super">12.3.6 三代同堂的类与取得基类的属性super()</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将父类的属性复制</span></span><br><span class="line"><span class="built_in">super</span>().__init__()</span><br></pre></td></tr></table></figure><p><strong>继承关系:</strong></p><p>Grandfather类</p><p>​|</p><p>Father类</p><p>​|</p><p>Ivan类</p></blockquote><h4 id="12-3-7-兄弟类属性的取得">12.3.7 兄弟类属性的取得</h4><blockquote><p>假设有一个父亲(Father)类，这个父亲类有2个儿子，分别是Ivan类和Ira类，如果Ivan类想取得Ira类的属性iramoney，可以使用下列方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ivan取得Ira的属性iramoney</span></span><br><span class="line">Ira().iramoney</span><br></pre></td></tr></table></figure><p><strong>继承关系:</strong></p><p>​Father类</p><p>​||</p><p>Ivan类 Ira类</p></blockquote><h3 id="12-4-多型-polymorphism">12.4 多型(polymorphism)</h3><p>多型</p><ul class="lvl-0"><li class="lvl-2"><p>不局限在必须有父子关系的类中的</p></li><li class="lvl-2"><p>也发生在不同类间的相同方法中</p></li></ul><h3 id="12-5-多重继承">12.5 多重继承</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名称</span>(父类<span class="number">1</span>, 父类<span class="number">2</span>, ... , 父类n):</span><br><span class="line">    类内容</span><br></pre></td></tr></table></figure><h3 id="12-6-type与isinstance">12.6 type与isinstance</h3><blockquote><p>用于了解某个对象变量的数据类型，或是所属类关系</p></blockquote><h4 id="12-6-1-type">12.6.1 type()</h4><blockquote><p>可以用于输出类对象与对象内方法的数据类型</p></blockquote><h4 id="12-6-2-isinstance">12.6.2 isinstance()</h4><blockquote><p>isinstance()函数可以传回对象的类是否属于某一类，它包含2个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可传回True或False</span></span><br><span class="line"><span class="built_in">isinstance</span>(对象, 类)</span><br></pre></td></tr></table></figure></blockquote><h3 id="12-7-特殊属性">12.7 特殊属性</h3><blockquote><p>当设计或是看到别人设计的Python程序时，若是遇到__xx__类的字符串就要特别留意了，这些大多数是特殊属性或方法</p></blockquote><h4 id="12-7-1-文档字符串-doc">12.7.1 文档字符串__doc__</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;无操作&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(fun.__doc__)</span><br><span class="line">无操作</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c</span>():</span><br><span class="line">    <span class="string">&#x27;类&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;init&#x27;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;public&#x27;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__fun</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;private&#x27;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 也可以使用实例,如c().__doc__</span></span><br><span class="line"><span class="built_in">print</span>(c.__doc__)</span><br><span class="line"><span class="built_in">print</span>(c.__init__.__doc__)</span><br><span class="line"><span class="built_in">print</span>(c.fun.__doc__)</span><br><span class="line"><span class="comment"># 不可输出类内私有方法的__doc__</span></span><br><span class="line"><span class="comment"># print(c.__fun.__doc__)</span></span><br></pre></td></tr></table></figure><h4 id="12-7-2-name-属性">12.7.2 __name__属性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># doSomething()</span></span><br></pre></td></tr></table></figure><p><code>__name__</code></p><ul class="lvl-0"><li class="lvl-2"><p>如果程序是自己执行，<code>__name__</code>就是<code>__main__</code></p></li><li class="lvl-2"><p>如果是被import到另一个程序，则<code>__name__</code>是本身的文件名</p></li><li class="lvl-2"><p><code>__name__</code>可以判别这个程序是自己执行或是被其他程序import导入当成模块使用</p></li></ul><h3 id="12-8-类的特殊方法">12.8 类的特殊方法</h3><h4 id="12-8-1-str-方法">12.8.1 __str__()方法</h4><blockquote><p>这是类的特殊方法，可以协助返回易读取的字符串，类似于toString()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = Name()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n</span><br><span class="line">&lt;__main__.Name <span class="built_in">object</span> at <span class="number">0x0000028A6E427880</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(n)</span><br><span class="line">name</span><br></pre></td></tr></table></figure></blockquote><h4 id="12-8-2-repr-方法">12.8.2 __repr__()方法</h4><blockquote><p>如果只是在Python Shell窗口输入类变量n，系统是调用<code>__repr__()</code>方法做响应</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n = Name()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n</span><br><span class="line">name</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(n)</span><br><span class="line">name</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p>如果<code>__ str __ </code>方法方法没定义, <code>__ repr __ </code>方法定义了，则<code> __ str _</code>=<code> __ repr __</code></p></li><li class="lvl-3"><p><code>__ str__</code>是面向用户的，在调用<code>str()</code>和使用<code>print()</code>输出时调用</p></li><li class="lvl-2"><p><code>__repr__</code>面向程序员，用于交互模式下提示回应以及<code>repr</code>函数</p></li><li class="lvl-2"><p>等号取代</p><ul class="lvl-3"><li class="lvl-4"><pre><code class="language-python">class Name:    def __str__(self):        return 'name'    __repr__ = __str__<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 12.8.3 \_\_iter\_\_()方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">建立类的时候也可以将类定义成一个迭代对象，类似list或tuple，供for … in循环内使用</span><br><span class="line"></span><br><span class="line">这时类需设计next()方法，取得下一个值，直到达到结束条件，可以使用raise StopIteration终止继续</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">class C():</span><br><span class="line">    def __init__(self, max):</span><br><span class="line">        self.max = max</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        self.i = 0</span><br><span class="line">        return self</span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.i += 1</span><br><span class="line">        if self.i &gt; self.max:</span><br><span class="line">            raise StopIteration</span><br><span class="line">        return self.i</span><br><span class="line">for i in C(5):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></blockquote><h2 id="第十三章-设计与应用模块">第十三章 设计与应用模块</h2><blockquote><p>模块(module)和套件(package)，意义是一样的</p></blockquote><h3 id="13-1-将自建的函数存储在模块中">13.1 将自建的函数存储在模块中</h3><h4 id="13-1-1-先前准备工作">13.1.1 先前准备工作</h4><h4 id="13-1-2-建立函数内容的模块">13.1.2 建立函数内容的模块</h4><blockquote><p>模块的扩展名与Python程序文件一样，是py</p></blockquote><h3 id="13-2-应用自己建立的函数模块">13.2 应用自己建立的函数模块</h3><h4 id="13-2-1-import模块名称">13.2.1 import模块名称</h4><blockquote><p>导入模块</p><ul class="lvl-1"><li class="lvl-2"><code>import 模块名称</code></li></ul><p>引用模块的函数语法</p><ul class="lvl-1"><li class="lvl-2"><p><code>模块名称.函数名称</code></p></li></ul></blockquote><h4 id="13-2-2-导入模块内特定单一函数">13.2.2 导入模块内特定单一函数</h4><blockquote><p><code>from 模块名称 import 函数名称</code></p><p><strong>未来程序引用所导入的函数时可以省略模块名称</strong></p></blockquote><h4 id="13-2-3-导入模块内多个函数">13.2.3 导入模块内多个函数</h4><blockquote><p><code>from 模块名称 import 函数名称1, 函数名称2, ... , 函数名称n</code></p><p><strong>如果想导入模块内多个函数，函数名称间需以逗号隔开，并且引用所导入的函数时可以省略模块名称</strong></p></blockquote><h4 id="13-2-4-导入模块所有函数">13.2.4 导入模块所有函数</h4><blockquote><p><code>from 模块名称 import *</code></p><p><strong>未来程序引用所导入的函数时可以省略模块名称</strong></p></blockquote><h4 id="13-2-5-使用as给函数指定替代名称">13.2.5 使用as给函数指定替代名称</h4><blockquote><p><code>from 模块名称 import 函数名称 as 替代名称</code></p><p><strong>引入替代名称后就无法使用原函数名称</strong></p><p><strong>也可以给多个函数指定替代名称，函数名称间需以逗号隔开</strong></p></blockquote><h4 id="13-2-6-使用as给模块指定替代名称">13.2.6 使用as给模块指定替代名称</h4><blockquote><p><code>import 模块名称 as 替代名称</code></p><p><strong>引入替代名称后就无法使用原模块名称</strong></p></blockquote><h3 id="13-3-将自建的类存储在模块内">13.3 将自建的类存储在模块内</h3><h4 id="13-3-1-先前准备工作">13.3.1 先前准备工作</h4><h4 id="13-3-2-建立类内容的模块">13.3.2 建立类内容的模块</h4><blockquote><p>模块的扩展名与Python程序文件一样，是py</p></blockquote><h3 id="13-4-应用自己建立的类模块">13.4 应用自己建立的类模块</h3><blockquote><p>导入模块内的类与导入模块内的函数观念是一致的</p></blockquote><h4 id="13-4-1-导入模块的单一类">13.4.1 导入模块的单一类</h4><blockquote><p><code>from 模块名称 import 类名称</code></p></blockquote><h4 id="13-4-2-导入模块的多个类">13.4.2 导入模块的多个类</h4><blockquote><p><code>from 模块名称 import 类别名称1, 类别名称2, ... , 类别名称n</code></p></blockquote><h4 id="13-4-3-导入模块内所有类">13.4.3 导入模块内所有类</h4><blockquote><p><code>from 模块名称 import *</code></p></blockquote><h4 id="13-4-4-import模块名称">13.4.4 import模块名称</h4><blockquote><p>导入模块</p><p><code>import 模块名称</code></p><p>引用模块的类别</p><p><code>模块名称.类别名称</code></p></blockquote><p><mark>另外,也可使用替代名称</mark></p><h4 id="13-4-5-模块内导入另一个模块的类">13.4.5 模块内导入另一个模块的类</h4><h3 id="13-5-随机数random模块">13.5 随机数random模块</h3><h4 id="13-5-1-randint">13.5.1 randint()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以产生min与max之间的整数值----&gt;[min, max]</span></span><br><span class="line">random.randint(<span class="built_in">min</span>, <span class="built_in">max</span>)</span><br></pre></td></tr></table></figure><h4 id="13-5-2-choice">13.5.2 choice()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个方法可以让我们在一个列表(list)中随机传回一个元素</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">value = random.choice(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure><h4 id="13-5-3-shuffle">13.5.3 shuffle()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个方法可以将列表元素重新排列，可以使用这个方法来洗牌</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">random.shuffle(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure><h3 id="13-6-时间time模块">13.6 时间time模块</h3><h4 id="13-6-1-time">13.6.1 time()</h4><blockquote><p><code>time()</code>方法可以传回自1970年1月1日00:00:00AM以来的秒数</p></blockquote><h4 id="13-6-2-sleep">13.6.2 sleep()</h4><blockquote><p>sleep( )方法可以让工作暂停，这个方法的参数单位是秒</p></blockquote><h4 id="13-6-3-asctime">13.6.3 asctime()</h4><blockquote><p>这个方法会以可以阅读方式列出目前系统时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line">value = time.asctime()</span><br><span class="line"><span class="built_in">print</span>(value)</span><br><span class="line"><span class="comment"># Tue Aug 23 18:01:50 2022</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="13-6-4-localtime">13.6.4 localtime()</h4><blockquote><p>这个方法可以返回目前时间的结构数据，所返回的结构可以用索引方式获得个别内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &lt;class &#x27;time.struct_time&#x27;&gt;</span></span><br><span class="line">t = time.localtime()</span><br><span class="line"><span class="built_in">print</span>(t)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;年&#x27;</span>, t[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;月&#x27;</span>, t[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;日&#x27;</span>, t[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;时&#x27;</span>, t[<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;分&#x27;</span>, t[<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;秒&#x27;</span>, t[<span class="number">5</span>])</span><br><span class="line"><span class="comment"># 0---&gt;星期一...</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;星期几&#x27;</span>, t[<span class="number">6</span>])</span><br><span class="line"><span class="comment"># 一年中的第几天</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;第几天&#x27;</span>, t[<span class="number">7</span>])</span><br><span class="line"><span class="comment"># 是夏令时间的设定 0代表不是 1代表是</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;夏令时间&#x27;</span>, t[<span class="number">8</span>])</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">time.struct_time(tm_year=<span class="number">2022</span>, tm_mon=<span class="number">8</span>, tm_mday=<span class="number">23</span>, tm_hour=<span class="number">18</span>, tm_min=<span class="number">9</span>, tm_sec=<span class="number">19</span>, tm_wday=<span class="number">1</span>, tm_yday=<span class="number">235</span>, tm_isdst=<span class="number">0</span>)</span><br><span class="line">年 <span class="number">2022</span></span><br><span class="line">月 <span class="number">8</span>   </span><br><span class="line">日 <span class="number">23</span>  </span><br><span class="line">时 <span class="number">18</span>  </span><br><span class="line">分 <span class="number">9</span>   </span><br><span class="line">秒 <span class="number">19</span>  </span><br><span class="line">星期几 <span class="number">1</span></span><br><span class="line">第几天 <span class="number">235</span></span><br><span class="line">夏令时间 <span class="number">0</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="13-7-系统sys模块">13.7 系统sys模块</h3><blockquote><p>这个模块可以控制Python Shell窗口信息</p></blockquote><h4 id="13-7-1-version属性">13.7.1 version属性</h4><blockquote><p>这个属性可以列出目前所使用Python的版本信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(sys.version)</span><br><span class="line"><span class="comment"># 3.8.3 (default, Jul  2 2020, 17:30:36) [MSC v.1916 64 bit (AMD64)]</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="13-7-2-stdin对象">13.7.2 stdin对象</h4><blockquote><p>这是一个对象，stdin是standard input的缩写，是指从屏幕输入（可想成Python Shell窗口），这个对象可以搭配readline( )方法，然后可以读取屏幕输入直到按下Enter键的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg = sys.stdin.readline()</span><br></pre></td></tr></table></figure><p>在readline( )方法内可以加上正整数参数，例如：readline(n)，这个n代表所读取的字符数，其中一个中文字或空格也算一个字符数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg = sys.stdin.readline(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></blockquote><h4 id="13-7-3-stdout对象">13.7.3 stdout对象</h4><blockquote><p>这是一个对象，stdout是standard ouput的缩写，是指从屏幕输出（可想成Python Shell窗口），这个对象可以搭配write( )方法，然后可以从屏幕输出数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回输出的字符数</span></span><br><span class="line">value = sys.stdout.write(<span class="string">&#x27;I like you!&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这个对象若是使用Python Shell窗口，最后会同时列出输出的字符数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout.write(<span class="string">&#x27;I like you!&#x27;</span>)</span><br><span class="line">I like you!<span class="number">11</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="13-8-keyword模块">13.8 keyword模块</h3><blockquote><p>这个模块有一些Python关键词的功能</p></blockquote><h4 id="13-8-1-kwlist属性">13.8.1 kwlist属性</h4><blockquote><p>这个属性含所有Python的关键词</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(keyword.kwlist)</span><br><span class="line"><span class="comment"># [&#x27;False&#x27;, &#x27;None&#x27;, &#x27;True&#x27;, &#x27;and&#x27;, &#x27;as&#x27;, &#x27;assert&#x27;, &#x27;async&#x27;, &#x27;await&#x27;, &#x27;break&#x27;, &#x27;class&#x27;, &#x27;continue&#x27;, &#x27;def&#x27;, &#x27;del&#x27;, &#x27;elif&#x27;, &#x27;else&#x27;, &#x27;except&#x27;, &#x27;finally&#x27;, </span></span><br><span class="line"><span class="string">&#x27;for&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;global&#x27;</span>, <span class="string">&#x27;if&#x27;</span>, <span class="string">&#x27;import&#x27;</span>, <span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;lambda&#x27;</span>, <span class="string">&#x27;nonlocal&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;pass&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;return&#x27;</span>, <span class="string">&#x27;try&#x27;</span>, <span class="string">&#x27;while&#x27;</span>, <span class="string">&#x27;with&#x27;</span>, <span class="string">&#x27;yield&#x27;</span>]</span><br></pre></td></tr></table></figure></blockquote><h4 id="13-8-2-iskeyword">13.8.2 iskeyword()</h4><blockquote><p>这个方法可以检查传回参数(字符串)是否是关键词，如果是传回True，如果不是传回False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>keyword.iskeyword(<span class="string">&#x27;while&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="第十四章-文件的读取与写入">第十四章 文件的读取与写入</h2><h3 id="14-1-文件夹与文件路径">14.1 文件夹与文件路径</h3><blockquote><p>对于ch14_1.py而言，它的文件路径名称是：</p><p><code>D:\Python\ch14\ch14_1.py</code></p><p>对于ch14_1.py而言，它的当前工作目录(也可称文件夹)名称是：<code>D:\Python\ch14</code></p></blockquote><p><mark>该节的方法许多都跟执行脚本的路径有关</mark></p><h4 id="14-1-1-绝对路径与相对路径">14.1.1 绝对路径与相对路径</h4><blockquote><ol><li class="lvl-3"><p>绝对路径：路径从根目录开始表达</p></li><li class="lvl-3"><p>相对路径：是指相对于当前工作目录的路径</p></li></ol><p>在操作系统处理文件夹的观念中会使用2个特殊符号<code>.</code>和<code>..</code>，<code>.</code>指的是当前文件夹，<code>..</code>指的是上一层文件夹。但是在使用上，当指当前文件夹时也可以省略<code>.\</code>。所以使用<code>.\ch14_1.py</code>与<code>ch14_1.py</code>意义相同</p></blockquote><h4 id="14-1-2-os模块与os-path模块">14.1.2 os模块与os.path模块</h4><blockquote><p>在Python内有关文件路径的模块是os</p><p>在os模块内有另一个常用模块os.path，由于os.path是在os模块内，所以导入os模块后不用再导入os.path模块</p></blockquote><h4 id="14-1-3-取得当前工作目录os-getcwd">14.1.3 取得当前工作目录os.getcwd()</h4><blockquote><p>os模块内的getcwd( )可以取得当前工作目录</p><p><strong>在python中获取当前路径使用os.getcwd()并不总是有效的，实际上这个方法显示的是执行脚本的路径</strong></p><p>使用<code>print(os.path.dirname(os.path.realpath(__file__)))</code>来代替</p></blockquote><h4 id="14-1-4-取得绝对路径os-path-abspath">14.1.4 取得绝对路径os.path.abspath</h4><blockquote><p><code>os.path</code>模块的<code>abspath(path)</code>会传回<code>path</code>的绝对路径，通常我们可以使用这个方法将文件或文件夹的相对路径转成绝对路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(os.path.abspath(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(os.path.abspath(<span class="string">&#x27;..&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(os.path.abspath(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(os.path.abspath(<span class="string">&#x27;text.py&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(os.path.abspath(<span class="string">&#x27;.\\text.py&#x27;</span>))</span><br></pre></td></tr></table></figure><p>此方法显示的仍然是执行脚本的路径</p></blockquote><h4 id="14-1-5-传回特定路段相对路径os-path-relpath">14.1.5 传回特定路段相对路径os.path.relpath()</h4><blockquote><p><code>os.path</code>模块的<code>relpath(path, start)</code>会传回从<code>start</code>到<code>path</code>的相对路径，如果省略<code>start</code>，则传回当前工作目录至<code>path</code>的相对路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(os.path.relpath(<span class="string">&#x27;C:\\&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(os.path.relpath(<span class="string">&#x27;C:\\Users\\21906\\python&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(os.path.relpath(<span class="string">&#x27;C:\\&#x27;</span>, <span class="string">&#x27;text.py&#x27;</span>))</span><br></pre></td></tr></table></figure></blockquote><h4 id="14-1-6-检查路径方法exist-isabs-isdir-isfile">14.1.6 检查路径方法exist/isabs/isdir/isfile</h4><blockquote><p>常用的os.path模块方法</p><ol><li class="lvl-3">exist(path)：如果path的文件或文件夹存在传回True，否则传回False</li><li class="lvl-3">isabs(path)：如果path的文件或文件夹是绝对路径传回True，否则传回False<ul class="lvl-3"><li class="lvl-5"><strong>不会判断path的文件或文件夹是否存在</strong></li></ul></li><li class="lvl-3">isdir(path)：如果path是文件夹且存在传回True，否则传回False</li><li class="lvl-3">isfile(path)：如果path是文件且存在传回True，否则传回False</li></ol><p><strong>path绝对路径或相对路径均可</strong></p></blockquote><h4 id="14-1-7-文件与目录的操作mkdir-rmdir-remove-chdir">14.1.7 文件与目录的操作mkdir/rmdir/remove/chdir</h4><blockquote><p>下列方法是在os模块内，建议执行下列操作前先用os.path.exists( )检查是否存在</p><ol><li class="lvl-3">mkdir(path)：建立path目录</li><li class="lvl-3">rmdir(path)：删除path目录，限制只能是空的目录</li><li class="lvl-3">remove(path)：删除path文件</li><li class="lvl-3">chdir(path)：将当前工作文件夹改至path</li></ol></blockquote><h4 id="14-1-8-传回文件路径os-path-join">14.1.8 传回文件路径os.path.join()</h4><blockquote><p>这个方法可以将os.path.join( )参数内的字符串结合为一个文件路径，参数可以有2个到多个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(os.path.join(<span class="string">&#x27;D:\\&#x27;</span>, <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;text.py&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(os.path.join(<span class="string">&#x27;D:\\python&#x27;</span>, <span class="string">&#x27;text.py&#x27;</span>))</span><br></pre></td></tr></table></figure></blockquote><h4 id="14-1-9-获得特定文件的大小-os-path-getsize">14.1.9 获得特定文件的大小 os.path.getsize()</h4><blockquote><p>这个方法可以获得特定文件的大小</p><p><code>os.path.getsize(path)</code></p><ul class="lvl-1"><li class="lvl-2"><p>绝对路径或相对路径均可</p></li></ul></blockquote><h4 id="14-1-10-获得特定工作目录的内容os-listdir">14.1.10 获得特定工作目录的内容os.listdir()</h4><blockquote><p>这个方法将以列表方式列出特定工作目录的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(os.listdir(<span class="string">&#x27;E:\\&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(os.listdir(<span class="string">&#x27;.&#x27;</span>))</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p>绝对路径或相对路径均可</p></li></ul></blockquote><h4 id="14-1-11-获得特定工作目录内容glob">14.1.11 获得特定工作目录内容glob</h4><blockquote><p>Python内还有一个模块可用于列出特定工作目录内容glob，当导入这个模块后可以使用glob方法获得特定工作目录的内容，这个方法最大特色是可以使用通配符<code>*</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="built_in">print</span>(glob.glob(<span class="string">&#x27;D:\\*.txt&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(glob.glob(<span class="string">&#x27;.\\*&#x27;</span>))</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p>绝对路径或相对路径均可</p></li></ul></blockquote><h4 id="14-1-12-遍历目录树os-walk">14.1.12 遍历目录树os.walk()</h4><blockquote><p>在os模块内有提供一个os.walk( )方法可以让我们遍历目录树，这个方法每次执行循环时将传回3个值：</p><ol><li class="lvl-3">当前工作目录名称(dirName)</li><li class="lvl-3">当前工作目录底下的子目录列表(sub_dirNames)</li><li class="lvl-3">当前工作目录底下的文件列表(fileNames)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dirName, sub_dirNames,fileNames <span class="keyword">in</span> os.walk(目录路径):</span><br><span class="line">    程序区块</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p>目录路径可以使用绝对地址或相对地址，如果不注明则代表当前工作目录下</p></li><li class="lvl-2"><p>遍历方式类似于<strong>先序遍历</strong></p></li></ul></blockquote><h3 id="14-2-读取文件">14.2 读取文件</h3><blockquote><p>读取或写入文件首先需将文件打开，Python可以使用<code>open()</code>函数打开文件，文件打开后会传回文件对象</p><p>可以一次读取所有文件内容或是一行一行读取文件内容</p><p>最后使用<code>close()</code>关闭文件对象，若是没有关闭也许未来文件内容会有不可预期的损害</p></blockquote><h4 id="14-2-1-读取整个文件read">14.2.1 读取整个文件read()</h4><blockquote><p>使用<code>read()</code>读取时，所有的文件内容将以一个字符串方式被读取然后存入字符串变量内</p></blockquote><h4 id="14-2-2-with关键词">14.2.2 with关键词</h4><blockquote><p>Python提供一个关键词with应用在打开文件与建立文件对象时，使用方式如下：</p><ul class="lvl-1"><li class="lvl-2"><p>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(欲打开的文件) <span class="keyword">as</span> 文件对象:</span><br><span class="line">    相关系列指令</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p>使用这种方式打开文件，最大特色是可以不必在程序中关闭文件，with指令会在结束不需要此文件时自动将它关闭</p></li><li class="lvl-2"><p>使用with关键词配合<code>open()</code>时，所打开的文件对象当前只在with区块内使用</p></li></ul></blockquote><h4 id="14-2-3-逐行读取文件内容">14.2.3 逐行读取文件内容</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># line和file_obj可以自行取名，file_obj是文件对象 </span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file_obj:</span><br><span class="line">循环相关系列指令</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">读取一行,连回车</li></ul></blockquote><h4 id="14-2-4-逐行读取使用readlines">14.2.4 逐行读取使用readlines()</h4><blockquote><p>Python另外有一个方法readlines( )可以逐行读取，同时以列表方式储存，另一个特色是读取时每行的换行字符皆会储存在列表内</p><p>重要的是我们可以在with区块外遍历原先文件对象内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;D:\\1.txt&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>) <span class="keyword">as</span> file_obj:</span><br><span class="line">    obj_list = file_obj.readlines()</span><br><span class="line"><span class="built_in">print</span>(obj_list)</span><br></pre></td></tr></table></figure></blockquote><h4 id="14-2-5-数据组合">14.2.5 数据组合</h4><blockquote><p>可以利用得到的<code>obj_list</code>列表拼接数据</p></blockquote><h4 id="14-2-6-字符串的替换">14.2.6 字符串的替换</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在字符串对象内，新字符串将取代旧字符串</span></span><br><span class="line">data = 字符串对象.replace(旧字符串, 新字符串)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">不改变原字符串</li></ul></blockquote><h4 id="14-2-7-数据的搜寻">14.2.7 数据的搜寻</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&#x27;搜寻的字符串&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;文件字符串&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;在该文件中&quot;</span>)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><strong>注意换行符</strong></li></ul></blockquote><h4 id="14-2-8-数据搜寻使用find">14.2.8 数据搜寻使用find()</h4><blockquote><p>这个方法除了可以执行数据搜寻以外，如果搜寻到数据还会传回数据的索引位置，如果没有找到则传回<code>-1</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># S代表被搜寻的字符串，sub是欲搜寻字符串，start和end代表可以被搜寻字符串的区间，若是省略表示全部搜寻---&gt;[start, end)</span></span><br><span class="line">index = S.find(sub[, start[, end]])</span><br></pre></td></tr></table></figure></blockquote><h3 id="14-3-写入文件">14.3 写入文件</h3><h4 id="14-3-1-将执行结果写入空的文件内">14.3.1 将执行结果写入空的文件内</h4><blockquote><p><code>open()</code>函数默认是<code>mode=‘r’</code>读取模式，如果仅供读取可以省略<code>mode=‘r’</code></p><p>若是要供写入，就要设定写入模式<code>mode=‘w’</code>，程序设计时可以省略<code>mode=</code></p><p>需要读取和写入可以使用<code>‘r+’</code></p><p><code>r/r+</code>模式文件必须存在，<code>w</code>模式文件不存在会自动创建，<code>w</code>模式会清空原文件内容</p><p>输出到文件可以使用<code>write()</code>方法</p><ul class="lvl-1"><li class="lvl-2"><p>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可将数据输出到文件对象</span></span><br><span class="line">文件对象.write(欲输出数据)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p>利用的是文件指针定位</p></li><li class="lvl-2"><p><code>write()</code>只能输出字符串</p></li></ul></blockquote><h4 id="14-3-2-写入数值资料">14.3.2 写入数值资料</h4><blockquote><p>使用<code>write()</code>将数值数据输出，必须使用<code>str()</code>将数值数据转成字符串数据</p></blockquote><h4 id="14-3-3-输出多行数据的实例">14.3.3 输出多行数据的实例</h4><blockquote><p>如果多行数据输出到文件，设计程序时需留意各行间的换行符号问题，<code>write()</code>不会主动在行的末端加上换行符号</p><p>增加换行符号<code>\n</code></p></blockquote><h4 id="14-3-4-建立附加文件">14.3.4 建立附加文件</h4><blockquote><p>可以将文件输出到所打开的文件末端，增加参数<code>mode=‘a’</code>或<code>‘a’</code></p><p><strong>如果所打开的文件不存在，则创建</strong></p></blockquote><h3 id="14-4-shutil模块">14.4 shutil模块</h3><blockquote><p>这个模块有提供一些方法可以让我们在Python程序内执行文件或目录的复制、删除、更改位置和更改名称</p></blockquote><h4 id="14-4-1-文件的复制copy">14.4.1 文件的复制copy()</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shutil.copy(source, destination)</span><br><span class="line">shutil.copy(<span class="string">&#x27;D:\\1.txt&#x27;</span>, <span class="string">&#x27;D:\\xuan\\copy.py&#x27;</span>)</span><br><span class="line">shutil.copy(<span class="string">&#x27;D:\\1.txt&#x27;</span>, <span class="string">&#x27;D:\\xuan&#x27;</span>)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">可将source文件复制到destination目的位置</li><li class="lvl-2">执行前source文件一定要存在否则会产生错误</li><li class="lvl-2">destination可以是文件夹也可以是文件(文件可以不存在,相当于重命名)</li><li class="lvl-2">相对路径绝对路径均可</li></ul></blockquote><h4 id="14-4-2-目录的复制copytree">14.4.2 目录的复制copytree()</h4><blockquote><p><code>copytree()</code>的语法格式与<code>copy()</code>相同，只不过这是复制目录，<strong>复制时目录底下的子目录或文件也将被复制</strong></p><p>执行前目录一定要存在否则会产生错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二个参数目录叶文件夹必须不存在</span></span><br><span class="line">shutil.copytree(<span class="string">&#x27;D:\\xuan&#x27;</span>, <span class="string">&#x27;D:\\copy\\xuan&#x27;</span>)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p>相对路径绝对路径均可</p></li></ul></blockquote><h4 id="14-4-3-文件的移动move">14.4.3 文件的移动move()</h4><blockquote><p><code>shutil.move(source, destination)</code></p><ul class="lvl-1"><li class="lvl-2">可将source文件移动到destination目的位置</li><li class="lvl-2">执行前source文件一定要存在否则会产生错误</li><li class="lvl-2">执行后source文件将不再存在</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutil.move(<span class="string">&#x27;D:\\one.txt&#x27;</span>, <span class="string">&#x27;D:\\copy\\one.txt&#x27;</span>)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p>第二个参数可以是存在的文件夹或文件</p></li><li class="lvl-2"><p>第二个参数也可以是存在的文件夹路径加上不存在的文件名</p></li><li class="lvl-2"><p>相对路径绝对路径均可</p></li></ul></blockquote><h4 id="14-4-4-文件名的更改move">14.4.4 文件名的更改move()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutil.move(<span class="string">&#x27;D:\\one.txt&#x27;</span>, <span class="string">&#x27;D:\\name.txt&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="14-4-5-目录的移动move">14.4.5 目录的移动move()</h4><blockquote><p><code>move()</code>也可以执行目录的移动，在移动时子目录也将随着移动</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutil.move(<span class="string">&#x27;D:\\xuan&#x27;</span>, <span class="string">&#x27;D:\\yuan&#x27;</span>)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p>当第二个参数路径存在时,将第一个参数路径下的内容随子目录一起移动至该路径下(同时需要保证第二个参数路径下不存在该文件夹)</p></li><li class="lvl-2"><p>当第二个参数路径不存在时,创建路径,同时把第一个参数路径下的内容移动至该路径下(不包含子目录)</p></li><li class="lvl-2"><p>相对路径绝对路径均可</p></li></ul></blockquote><h4 id="14-4-6-目录的更改名称move">14.4.6 目录的更改名称move()</h4><blockquote><p>如果在移动过程destination的目录不存在，此时就可以达到目录更改名称的目的了，甚至路径名称也可能更改</p></blockquote><h4 id="14-4-7-删除底下有数据的目录rmtree">14.4.7 删除底下有数据的目录rmtree()</h4><blockquote><p><code>o</code>s模块的<code>rmdir()</code>只能删除空的目录，如果要删除含数据文件的目录须使用<code>rmtree()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 路径必须存在</span></span><br><span class="line">shutil.rmtree(<span class="string">&#x27;D:\\xuan&#x27;</span>)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p>相对路径绝对路径均可</p></li></ul></blockquote><h4 id="14-4-8-安全删除文件或目录send2trash">14.4.8 安全删除文件或目录send2trash()</h4><blockquote><p>Python内置的<code>shutil</code>模块在删除文件后就无法复原了</p><p>有一个第三方的模块<code>send2trash</code>，执行删除文件或文件夹后是将被删除的文件放在回收站</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Anaconda Prompt</span></span><br><span class="line">conda install send2trash</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入send2trash模块</span></span><br><span class="line"><span class="keyword">import</span> send2trash</span><br><span class="line"><span class="comment"># 语法格式</span></span><br><span class="line">send2trash.send2trash(文件或文件夹)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p>相对路径绝对路径均可</p></li></ul></blockquote><h3 id="14-5-文件压缩与解压缩zipfile">14.5 文件压缩与解压缩zipfile</h3><blockquote><p>Windows操作系统有提供功能将一般文件或目录压缩，压缩后的扩展名是zip</p><p>Python内有zipFile模块也可以将文件或目录压缩以及解压缩</p><p><code>import zipfile</code></p></blockquote><h4 id="14-5-1-执行文件或目录的压缩">14.5.1 执行文件或目录的压缩</h4><blockquote><p>执行文件压缩前首先要使用<code>ZipFile()</code>方法建立一份压缩后的档名，在这个方法中另外要加上<code>'w'</code>参数，注明未来是供<code>write()</code>方法写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># out.zip是未来储存压缩结果</span></span><br><span class="line">fileZip = zipfile.ZipFile(<span class="string">&#x27;out.zip&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p><code>fileZip</code>是压缩文件对象,代表的是<code>out.zip</code></p></li><li class="lvl-2"><p><code>ZipFile()</code>无法执行整个目录的压缩，不过可用循环方式将目录底下的文件压缩</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> glob, os</span><br><span class="line">fileZip = zipfile.ZipFile(<span class="string">&#x27;D:\\out.zip&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> glob.glob(<span class="string">&#x27;D:\\xuan\\*&#x27;</span>):</span><br><span class="line">    fileZip.write(name, os.path.basename(name), zipfile.ZIP_DEFLATED)</span><br><span class="line">fileZip.close()</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p><code>zipfile.ZIP_DEFLATED</code>为压缩方式</p></li><li class="lvl-2"><p>目录下包含文件夹,文件夹可以被添加进去,但是其中文件并不会</p></li><li class="lvl-2"><p>相对路径绝对路径均可</p></li></ul></blockquote><h4 id="14-5-2-读取zip文件">14.5.2 读取zip文件</h4><blockquote><p><code>ZipFile</code>对象有<code>namelist()</code>方法可以传回<code>zip</code>文件内所有被压缩的文件或目录名称，同时以列表方式传回此对象</p><p>这个传回的对象可以使用<code>infolist()</code>方法传回各元素的属性，如文件名<code>filename</code>、文件大小<code>file_size</code>、压缩结果大小<code>compress_size</code>、文件时间<code>data_time</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listZipInfo = zipfile.ZipFile(<span class="string">&#x27;D:\\out.zip&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(listZipInfo.namelist())</span><br><span class="line"><span class="keyword">for</span> info <span class="keyword">in</span> listZipInfo.infolist():</span><br><span class="line">    <span class="built_in">print</span>(info.filename, info.file_size, info.compress_size, info.date_time)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p>相对路径绝对路径均可</p></li></ul></blockquote><h4 id="14-5-3-解压缩zip文件">14.5.3 解压缩zip文件</h4><blockquote><p>解压缩<code>zip</code>文件可以使用<code>extractall()</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fileUnZip = zipfile.ZipFile(<span class="string">&#x27;D:\\out.zip&#x27;</span>)</span><br><span class="line">fileUnZip.extractall(<span class="string">&#x27;D:\\out&#x27;</span>)</span><br><span class="line">fileUnZip.close()</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p>相对路径绝对路径均可</p></li></ul></blockquote><h3 id="14-6-认识编码格式encode">14.6 认识编码格式encode</h3><blockquote><p>文本模式下常用的编码方式有<code>utf-8</code>和<code>cp950</code></p><p>使用<code>open()</code>打开文件时，可以增加另一个常用的参数<code>encoding</code></p><ul class="lvl-1"><li class="lvl-2"><p><code>file_Obj = open(file, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;)</code></p></li></ul></blockquote><p><strong>Unicode和UTF-8，UTF-16，UTF-32</strong></p><ul class="lvl-0"><li class="lvl-2"><p>Unicode 为世界上所有字符都分配了一个唯一的数字编号，这个编号范围从 0x000000 到 0x10FFFF，这个编号一般写成 16 进制，在前面加上 U+</p></li><li class="lvl-2"><p>编号怎么对应到二进制？有多种方案：主要有 UTF-8，UTF-16，UTF-32</p></li><li class="lvl-2"><p>UTF-32</p><ul class="lvl-2"><li class="lvl-4">就是字符所对应编号的整数二进制形式(直接转换)<ul class="lvl-4"><li class="lvl-6">实际起作用的也就Unicode编码的21位</li></ul></li><li class="lvl-4">UTF-32 用四个字节表示，处理单元为四个字节（一次拿到四个字节进行处理）</li><li class="lvl-4">计算机在存储器中排列字节有两种方式：大端法和小端法，所以在编码方式中有 UTF-32BE 和 UTF-32LE，分别对应大端和小端</li></ul></li><li class="lvl-2"><p>UTF-16</p><ul class="lvl-2"><li class="lvl-5">对于编号在 U+0000 到 U+FFFF 的字符（常用字符集），直接用两个字节表示</li><li class="lvl-4">编号在 U+10000 到 U+10FFFF 之间的字符，需要用四个字节表示<ul class="lvl-4"><li class="lvl-6">这 <strong>4</strong> 个字节分成前后两部分，每个部分各两个字节，其中，前面两个字节的前 <strong>6</strong> 位二进制固定为 <strong>110110</strong>，后面两个字节的前 6 位二进制固定为 <strong>110111</strong>, 前后部分各剩余 10 位二进制表示符号的 Unicode 码 减去 <strong>0x10000</strong> 的结果</li><li class="lvl-6">为了配合UTF-16，Unicode中也将这两个区间屏蔽掉，不允许分配任何字符</li></ul></li><li class="lvl-4">UTF-16BE 表示大端，UTF-16LE 表示小端</li></ul></li><li class="lvl-2"><p>UTF-8</p><ul class="lvl-2"><li class="lvl-4"><p>对于单字节的符号，字节的第一位设为 0，后面的7位为这个符号的 Unicode 码，因此对于英文字母，UTF-8 编码和 ASCII 码是相同的</p></li><li class="lvl-4"><p>对于n字节的符号（n&gt;1）,第一个字节的前 n 位都设为 1，第 n+1 位设为 0，后面字节的前两位一律设为 10，剩下的没有提及的二进制位，全部为这个符号的 Unicode 码</p></li><li class="lvl-4"><p>UTF-8 的处理单元为一个字节（也就是一次处理一个字节），所以处理器在处理的时候就不需要考虑这一个字节的存储是在高位还是在低位，直接拿到这个字节进行处理就行了，因为大小端是针对大于一个字节的数的存储问题而言的</p></li><li class="lvl-4"><table><thead><tr><th style="text-align:center">编码范围(编码对应的十进制数)</th><th style="text-align:center">二进制格式</th></tr></thead><tbody><tr><td style="text-align:center">0x00 - 0x7F(0 - 127)</td><td style="text-align:center">0XXXXXXX</td></tr><tr><td style="text-align:center">0x80 - 0x7FF(128 - 2047)</td><td style="text-align:center">110XXXXX 10XXXXXX</td></tr><tr><td style="text-align:center">0x800 - 0xFFFF(2048 - 65535)</td><td style="text-align:center">1110XXXX 10XXXXXX 10XXXXXX</td></tr><tr><td style="text-align:center">0x10000 - 0x10FFFF(65536以上)</td><td style="text-align:center">11110XXX 10XXXXXX 10XXXXXX 10XXXXXX</td></tr></tbody></table></li></ul></li><li class="lvl-2"><p><mark>补充</mark></p><ul class="lvl-2"><li class="lvl-4">计算机只能以2的倍数拓展，如果不这么设计，就没办法解析**???**</li></ul></li></ul><h4 id="14-6-1-中文Windows操作系统记事本默认的编码">14.6.1 中文Windows操作系统记事本默认的编码</h4><blockquote><p>在ANSI编码格式下，在<code>open()</code>内我们可以使用<code>encoding=“cp950”</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用encoding=&quot;cp950&quot;发现中文字符不对应</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;D:\\ansi.txt&#x27;</span>, encoding=<span class="string">&#x27;gb18030&#x27;</span>) <span class="keyword">as</span> obj:</span><br><span class="line">    data = obj.read()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure></blockquote><h4 id="14-6-2-urf-8编码">14.6.2 urf-8编码</h4><blockquote><p><code>utf-8</code>英文全名是<code>8-bit Unicode Transformation Format</code></p><p>这是一种适合多语系的编码规则，主要方法是使用可变长度字节方式储存字符，以节省内存空间</p><ul class="lvl-1"><li class="lvl-2"><p>对于英文字母而言是使用1个字节空间存储字符</p></li><li class="lvl-2"><p>对于含有附加符号的希腊文、拉丁文或阿拉伯文等则用2个字节空间储存字符</p></li><li class="lvl-2"><p>中文则是以3个字节空间储存字符</p></li><li class="lvl-2"><p>只有极少数的平面辅助文字需要4个字节空间储存字符</p></li></ul><p>这种编码规则已经包含了全球所有语言的字符</p><ul class="lvl-1"><li class="lvl-2"><p>采用这种编码方式设计网页时，其他国家的浏览器只要支持<code>utf-8</code>编码皆可显示</p></li><li class="lvl-2"><p>浏览网页发生乱码，主要原因就是对方网页设计师并没有将此属性设为<code>“utf-8”</code></p></li><li class="lvl-2"><p>例如，早期最常见的是，中国大陆简体中文的编码是<code>“gb2312”</code></p></li></ul><p><code>utf-8</code>是国际通用的编码</p></blockquote><h4 id="14-6-3-认识utf-8编码的BOM">14.6.3 认识utf-8编码的BOM</h4><blockquote><p>使用中文Windows操作系统的记事本以<code>utf-8</code>执行编码时，操作系统会在文件前端增加<strong>字节顺序记号</strong><code>(Byte Order Mark, BOM)</code>，俗称文件<strong>前端代码</strong>，主要功能是判断文字以<code>Unicode</code>表示时，字节的排序方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用encoding=&#x27;utf_8_sig&#x27;可以不输出BOM</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;D:\\1.txt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> obj:</span><br><span class="line">    data = obj.readlines()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="comment"># [&#x27;\ufeffPython\n&#x27;, &#x27;王者归来\n&#x27;]</span></span><br></pre></td></tr></table></figure><p>在utf-8的编码中有2种编码格式主张，有一派主张数值较大的byte要放在前面，这种方式称Big Endian(BE)系统。另一派主张数值较小的byte要放在前面，这种方式称Little Endian(LE)系统</p><p>一般用BOM内容是<code>\ufeff</code>代表这是LE的编码系统。这2个字符在Unicode中不占空间，所以许多时候是感觉不到它们的存在的</p><p>UTF-8 不需要 BOM，尽管 Unicode 标准允许在 UTF-8 中使用 BOM</p><p>所以不含 BOM 的 UTF-8 才是标准形式，在 UTF-8 文件中放置 BOM 主要是微软的习惯（顺便提一下：把带有 BOM 的小端序 UTF-16 称作「Unicode」而又不详细说明，这也是微软的习惯）</p><p>BOM（byte order mark）是为 UTF-16 和 UTF-32 准备的，用于标记字节序（byte order）。微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码明确区分开，但这样的文件在 Windows 之外的操作系统里会带来问题</p></blockquote><h3 id="14-7-剪贴板的应用">14.7 剪贴板的应用</h3><blockquote><p>剪贴板的功能是属第三方pyperclip模块内，使用前需使用下列方式安装此模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Anaconda Prompt</span></span><br><span class="line">conda install pyperclip</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pip install pyperclip</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyperclip</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p>copy( )：可将列表数据复制至剪贴板</p></li><li class="lvl-2"><p>paste( )：将剪贴板数据复制回字符串变量</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyperclip</span><br><span class="line">pyperclip.copy(<span class="string">&#x27;剪贴板的应用&#x27;</span>)</span><br><span class="line">string = pyperclip.paste()</span><br><span class="line"><span class="built_in">print</span>(string)</span><br></pre></td></tr></table></figure></blockquote><h2 id="第十五章-程序除错与异常处理">第十五章 程序除错与异常处理</h2><h3 id="15-1-程序异常">15.1 程序异常</h3><blockquote><p>程序错误(error)也叫程序异常(exception)</p><p>Python提供功能可以让我们<strong>捕捉异常</strong>和<strong>撰写异常处理程序</strong></p></blockquote><h4 id="15-1-1-一个除数为0的错误">15.1.1 一个除数为0的错误</h4><blockquote><p><code>ZeroDivisionError: division by zero</code></p></blockquote><h4 id="15-1-2-撰写异常处理程序try-except">15.1.2 撰写异常处理程序try-except</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">5</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;除数不可为0&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行try:下面的指令，如果正常则跳离except部分，如果指令有错误异常，则检查此异常是否是异常对象所指的错误，如果是代表异常被捕捉了，则执行此异常对象下面的异常处理程序</p></blockquote><h4 id="15-1-3-try-except-else">15.1.3 try-except-else</h4><blockquote><p>Python在try - except中又增加了else指令，这个指令存放的主要目的是try内的指令正确时，可以执行else内的指令区块，我们可以将这部分指令区块称正确处理程序，这样可以增加程序的可读性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    value = <span class="number">5</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;除数不可为0&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure></blockquote><h4 id="15-1-4-找不到文件的错误FileNotFoundError">15.1.4 找不到文件的错误FileNotFoundError</h4><blockquote><p>打开文件时找不到文件，这时会产生FileNotFoundError异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn = <span class="string">&#x27;D:\\1.txt&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(fn) <span class="keyword">as</span> obj:</span><br><span class="line">        data = obj.read()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找不到 %s 文件&quot;</span> % fn)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure></blockquote><h4 id="15-1-5-分析单一文件的字数">15.1.5 分析单一文件的字数</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wordsNum</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;&#x27;适合英文文件,计算文章字数&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(fn, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> obj:</span><br><span class="line">            data = obj.read()</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;找不到 %s 文件&quot;</span> % fn)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        wordList = data.split()</span><br><span class="line">        <span class="built_in">print</span>(fn, <span class="string">&#x27;文章的字数是&#x27;</span>, <span class="built_in">len</span>(wordList))</span><br></pre></td></tr></table></figure><p>在Linux平台下，open函数的encoding参数基本上默认都是UTF-8，但在Windows平台下就不一定了。在读取文本文件的时候，如果open()函数没有指定encoding，python3会选取代码所运行的计算机操作系统的默认编码作为open()函数的编码方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用Python查看系统默认charset:</span></span><br><span class="line">C:\Users\<span class="number">21906</span>&gt;python -q</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> locale</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>locale.getpreferredencoding(<span class="literal">False</span>)</span><br><span class="line"><span class="string">&#x27;cp936&#x27;</span></span><br></pre></td></tr></table></figure><p><code>cp936</code></p><ul class="lvl-1"><li class="lvl-2"><p>微软的<code>CP936</code>通常被视为等同<code>GBK</code>，连<code>IANA</code>也以<code>CP936</code>为<code>GBK</code>之别名。事实上比较起来，<code>GBK</code>定义之字符较 <code>CP936</code>多出95字（15个非汉字及80个汉字）-----<code>wikipedia</code>中的说明</p></li></ul></blockquote><h4 id="15-1-6-分析多个文件的字数">15.1.6 分析多个文件的字数</h4><blockquote><p>利用循环</p></blockquote><h3 id="15-2-设计多组异常处理程序">15.2 设计多组异常处理程序</h3><h4 id="15-2-1-常见的异常对象">15.2.1 常见的异常对象</h4><table><thead><tr><th>异常对象名称</th><th>说明</th></tr></thead><tbody><tr><td>AttributeError</td><td>通常是指对象没有这个属性</td></tr><tr><td>Exception</td><td>一般错误皆可使用</td></tr><tr><td>FileNotFoundError</td><td>找不到open()打开的文件</td></tr><tr><td>IOError</td><td>在输入或输出是发生错误</td></tr><tr><td>IndexError</td><td>索引超出范围区间</td></tr><tr><td>KeyError</td><td>在映射中没有这个键</td></tr><tr><td>MemoryError</td><td>需求内存空间超出范围</td></tr><tr><td>NameError</td><td>对象名称未声明</td></tr><tr><td>SyntaxError</td><td>语法错误</td></tr><tr><td>SystemError</td><td>直译器的系统错误</td></tr><tr><td>TypeError</td><td>数据类型错误</td></tr><tr><td>ValueError</td><td>传入无效参数</td></tr><tr><td>ZeroDivisionError</td><td>除数为0</td></tr></tbody></table><blockquote><p>异常发生时如果except设定的异常对象不是发生的异常，相当于except没有捕捉到异常</p><p>Python提供了一个通用型的异常对象Exception，它可以捕捉各式的基础异常</p></blockquote><h4 id="15-2-2-设计捕捉多个异常">15.2.2 设计捕捉多个异常</h4><blockquote><p>在try: - except的使用中，可以设计多个except捕捉多种异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    指令</span><br><span class="line"><span class="keyword">except</span> 异常对象<span class="number">1</span>:</span><br><span class="line">    异常处理程序<span class="number">1</span></span><br><span class="line"><span class="keyword">except</span> 异常对象<span class="number">2</span>:</span><br><span class="line">    异常处理程序<span class="number">2</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="15-2-3-使用一个except捕捉多个异常">15.2.3 使用一个except捕捉多个异常</h4><blockquote><p>Python也允许设计一个except，捕捉多个异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    指令</span><br><span class="line"><span class="keyword">except</span> (异常对象<span class="number">1</span>, 异常对象<span class="number">2</span>, ...):</span><br><span class="line">    异常处理程序</span><br></pre></td></tr></table></figure></blockquote><h4 id="15-2-4-处理异常但是使用Python内置的错误信息">15.2.4 处理异常但是使用Python内置的错误信息</h4><blockquote><p>Python也支持发生异常时使用系统内置的异常处理信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    指令</span><br><span class="line"><span class="keyword">except</span> 异常对象 <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p>e是系统内置的异常处理信息，e可以是任意字符，笔者此处使用e是因为代表error的内涵</p></li><li class="lvl-2"><p>except语法也接受同时处理多个异常对象</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">division</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> x/y</span><br><span class="line">    <span class="keyword">except</span> (ZeroDivisionError, TypeError) <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure></blockquote><h4 id="15-2-5-捕捉所有异常">15.2.5 捕捉所有异常</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    指令</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    异常处理程序</span><br></pre></td></tr></table></figure></blockquote><h3 id="15-3-丢出异常">15.3 丢出异常</h3><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抛出异常</span></span><br><span class="line"><span class="keyword">raise</span> Excption(<span class="string">&#x27;msg&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 捕捉异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    指令</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">    <span class="comment"># 打印错误信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;message&#x27;</span>, <span class="built_in">str</span>(err))</span><br></pre></td></tr></table></figure></blockquote><h3 id="15-4-记录Traceback字符串">15.4 记录Traceback字符串</h3><blockquote><p>每次错误屏幕皆出现Traceback字符串，在这个字符串中指出程序错误的原因</p><p>导入<code>traceback</code>模块，就可以使用<code>traceback.format_exc()</code>记录这个<code>Traceback</code>字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line">...</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    指令</span><br><span class="line"><span class="keyword">except</span> ...:</span><br><span class="line">    <span class="built_in">print</span>(traceback.format_exc())</span><br></pre></td></tr></table></figure></blockquote><h3 id="15-5-finally">15.5 finally</h3><blockquote><p>try之后可以有except或else，这个finally关键词必须放在except和else之后，同时不论是否有异常发生一定会执行这个finally内的程序代码</p></blockquote><h3 id="15-6-程序断言assert">15.6 程序断言assert</h3><h4 id="15-6-1-设计断言">15.6.1 设计断言</h4><blockquote><p>Python的assert关键词主要功能是协助程序设计师在程序设计阶段，对整个程序的执行状态做一个全面性的安全检查，以确保程序不会发生语意上的错误</p><p>断言(assert)主要功能是确保程序执行的某个阶段，必须符合一定的条件，如果不符合这个条件时程序主动抛出异常，让程序终止同时主动打印出异常原因，方便程序设计师侦错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> 条件, <span class="string">&#x27;字符串&#x27;</span></span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p>如果条件响应是<code>True</code>，程序不理会逗号<code>“,”</code>右边的字符串正常往下执行</p></li><li class="lvl-2"><p>如果条件响应是<code>False</code>，程序终止同时将逗号<code>“,”</code>右边的字符串输出到<code>Traceback</code>的字符串内</p></li><li class="lvl-2"><p>类似于抛出异常</p></li></ul></blockquote><h4 id="15-6-2-停用断言">15.6.2 停用断言</h4><blockquote><p>断言assert一般是用在程序开发阶段</p><p>停用断言</p><ul class="lvl-1"><li class="lvl-2"><p>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Windows的命令提示环境</span></span><br><span class="line">~\python.exe -O D:\\<span class="number">1.</span>py</span><br><span class="line"><span class="comment"># python -O D:\\1.py</span></span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><code>“~”</code>代表安装<code>Python</code>的路径</p></li></ul></blockquote><h3 id="程序日志模块logging">程序日志模块logging</h3><blockquote><p>Python有程序日志logging功能，这个功能可以协助我们执行程序的除错，有了这个功能我们可以自行设定关键变量在每一个程序阶段的变化，由这个关键变量的变化可方便我们执行程序的除错，同时未来不想要显示这些关键变量数据时，可以不用删除，只要适度加上指令就可隐藏它们</p></blockquote><h4 id="15-7-1-logging模块">15.7.1 logging模块</h4><blockquote><p>这个模块有提供方法可以让我们使用程序日志logging功能</p><p><code>import logging</code></p></blockquote><h4 id="15-7-2-logging的等级">15.7.2 logging的等级</h4><blockquote><p>logging模块共分5个等级，从最低到最高等级顺序如下：</p><ol><li class="lvl-3">DEBUG等级使用logging.debug( )显示程序日志内容，所显示的内容是程序的小细节，最低层级的内容，感觉程序有问题时可使用它追踪关键变量的变化过程</li><li class="lvl-3"><a href="http://xn--INFOlogging-zd2rv030bt6raprl.info">INFO等级使用logging.info</a>( )显示程序日志内容，所显示的内容是记录程序一般发生的事件</li><li class="lvl-3">WARNING等级使用logging.warning( )显示程序日志内容，所显示的内容虽然不会影响程序的执行，但是未来可能导致问题的发生</li><li class="lvl-3">ERROR等级使用logging.error( )显示程序日志内容，通常显示程序在某些状态将引发错误的缘由</li><li class="lvl-3">CRITICAL等级使用logging.critical( )显示程序日志内容，这是最重要的等级，通常是显示将让整个系统当掉或中断的错误</li></ol><p>程序设计时，可以使用下列函数设定显示信息的等级：</p><ul class="lvl-1"><li class="lvl-2"><p>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设是设定DEBUG等级</span></span><br><span class="line"><span class="comment"># 默认是WARNING等级</span></span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p>当设定logging为某一等级时，未来只有此等级或更高等级的logging会被显示</p></li><li class="lvl-2"><p>每一个输出前方都有各自的前导信息(例如<code>DEBUG:root:</code>)，这是该logging输出模式默认的输出信息注明输出logging模式</p></li></ul><p><strong>程序设计初期阶段会将logging等级设为DEBUG，如果确定程序大致没问题，就将logging等级设为WARNING，最后再设为CRITICAL</strong></p></blockquote><h4 id="15-7-3-格式化logging信息输出format">15.7.3 格式化logging信息输出format</h4><blockquote><p>取消前导信息的输出</p><ul class="lvl-1"><li class="lvl-2"><p>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(level=logging.DEBUG, <span class="built_in">format</span> = <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul></blockquote><h4 id="15-7-4-时间信息asctime">15.7.4 时间信息asctime</h4><blockquote><p>可以在format内配合asctime列出系统时间，这样可以列出每一重要阶段关键变量发生的时间</p><ul class="lvl-1"><li class="lvl-2"><p>例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(level=logging.DEBUG, <span class="built_in">format</span> = <span class="string">&#x27;%(asctime)s&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p><a href="http://xn--formatlogging-gm0vi6yzwb326b194iv2wbk65d.xxx">经过format处理后原先logging.xxx</a>( )内的输出信息没有了，这是因为我们在format内只保留时间字符串信息</p></li></ul></blockquote><h4 id="15-7-5-format内的message">15.7.5 format内的message</h4><blockquote><p><a href="http://xn--logging-4b9ku5ckwhu7uf7ujzt3o2i99sa.xxx">如果想要输出原先logging.xxx</a>( )的输出信息，必须在format内增加message格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(level=logging.DEBUG, <span class="built_in">format</span> = <span class="string">&#x27;%(asctime)s : %(message)s&#x27;</span>)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p>前导信息不输出</p></li></ul></blockquote><h4 id="15-7-6-列出levelname">15.7.6 列出levelname</h4><blockquote><p>levelname属性是记载目前logging的显示层级是哪一个等级</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(level=logging.DEBUG, <span class="built_in">format</span> = <span class="string">&#x27;%(asctime)s - %(levelname)s : %(message)s&#x27;</span>)</span><br></pre></td></tr></table></figure></blockquote><h4 id="15-7-7-使用logging列出变量变化的应用">15.7.7 使用logging列出变量变化的应用</h4><h4 id="15-7-8-正式追踪factorial数值的应用">15.7.8 正式追踪factorial数值的应用</h4><h4 id="15-7-9-将程序日志logging输出到文件">15.7.9 将程序日志logging输出到文件</h4><blockquote><p>在<code>logging.basicConfig()</code>增加<code>filename=“文件名”</code>，这样就可以将<code>logging</code>输出到指定的文件内</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig(filename=<span class="string">&#x27;out.txt&#x27;</span>, level=logging.DEBUG, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s : %(message)s&#x27;</span>)</span><br></pre></td></tr></table></figure></blockquote><h4 id="15-7-10-隐藏程序日志logging的DEBUG等级使用CRITICAL">15.7.10 隐藏程序日志logging的DEBUG等级使用CRITICAL</h4><blockquote><p>如果我们程序设计完成，也确定没有错误，可以将logging等级设为最高等级，所有较低等级的输出将被隐藏</p></blockquote><h4 id="15-7-11-停用程序日志logging">15.7.11 停用程序日志logging</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># level是停用logging的等级</span></span><br><span class="line">logging.disable(level)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><strong>此等级或更低等级的logging将被停用</strong></li><li class="lvl-2">如果想停用全部参数可以使用logging.CRITICAL等级</li><li class="lvl-2">这个方法一般是放在import下方，这样就可以停用所有的logging</li></ul></blockquote><h3 id="15-8-程序除错的典故">15.8 程序除错的典故</h3><blockquote><p>程序除错又称Debug,De是除去的意思,bug是指小虫</p><p>1944年IBM和哈佛大学联合开发了Mark I计算机，此计算机重5吨，有8英尺高，51英尺长，内部线路加总长是500英里，没有中断使用了15年</p><p>在当时有一位女性程序设计师Grace Hopper，发现了第一个计算机虫(bug)，一只死的蛾(moth)的双翅卡在继电器(relay)，促使数据读取失败，下列是当时Grace Hopper记录此事件的数据</p><p>当时Grace Hopper写下了下列两句话</p><ol><li class="lvl-3"><p>Relay #70 Panel F (moth) in relay.</p></li><li class="lvl-3"><p>First actual case of bug being found.</p></li></ol><p>大意是编号70的继电器出问题（因为蛾），这是真实计算机上所发现的第一只虫</p><p>自此，计算机界认定用debug描述“找出及删除程序错误”应归功于Grace Hopper</p><p>图片链接: <a href="http://www.computersciencelab.com">http://www.computersciencelab.com</a></p></blockquote><h2 id="第十六章-正则表达式-Regular-Expression">第十六章 正则表达式(Regular Expression)</h2><blockquote><p>正则表达式(Regular Expression)主要功能是执行模式的比对与搜寻</p></blockquote><h3 id="16-1-使用Python硬功夫搜寻文字">16.1 使用Python硬功夫搜寻文字</h3><blockquote><p>isdecimal() 方法检查字符串是否只包含十进制字符(即判断字符是否是0—9的数字)</p><p>isdecimal() 方法语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.isdecimal()</span><br></pre></td></tr></table></figure><p>返回值</p><ul class="lvl-1"><li class="lvl-2"><p><strong>True</strong> - 如果字符串中的所有字符都是十进制字符</p></li><li class="lvl-2"><p><strong>False</strong> - 至少一个字符不是十进制字符</p></li></ul></blockquote><h3 id="16-2-正则表达式的基础">16.2 正则表达式的基础</h3><blockquote><p>Python有关正则表达式的方法是在re模块内</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入re模块</span></span><br><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure></blockquote><h4 id="16-2-1-建立搜寻字符串模式">16.2.1 建立搜寻字符串模式</h4><blockquote><p>正则表达式是一种文本模式的表达方法，在这个方法中使用<code>\d</code>表示<code>0—9</code>的数字字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 号码xxxx-xxx-xxx ---&gt; &#x27;\d\d\d\d-\d\d\d-\d\d\d&#x27;</span></span><br><span class="line"><span class="comment"># =============================================</span></span><br><span class="line"><span class="string">&#x27;\\d\\d\\d\\d-\\d\\d\\d-\\d\\d\\d&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">r&#x27;\d\d\d\d-\d\d\d-\d\d\d&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="16-2-2-使用re-compile-建立Regex对象">16.2.2 使用re.compile()建立Regex对象</h4><blockquote><p>Regex是Regular expression的简称</p><p>在re模块内有compile( )方法，可以将欲搜寻字符串的正则表达式当作字符串参数放在此方法内，然后会传回一个Regex对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &lt;class &#x27;re.Pattern&#x27;&gt;</span></span><br><span class="line">phoneRule = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d\d\d\d-\d\d\d-\d\d\d&#x27;</span>)</span><br></pre></td></tr></table></figure></blockquote><h4 id="16-2-3-搜寻对象">16.2.3 搜寻对象</h4><blockquote><p>在Regex对象内有search( )方法，可以由Regex对象启用，然后将欲搜寻的字符串放在这个方法内</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># msg是欲搜寻的字符串</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;re.Match&#x27;&gt;</span></span><br><span class="line">phoneNum = phoneRule.search(msg)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p>找不到比对相符的字符串会传回None</p></li><li class="lvl-2"><p>找到比对相符的字符串会将结果传回所设定的phoneNum变量对象，这个对象在Python中称之为MatchObject对象</p></li><li class="lvl-2"><p>处理此对象主要是将搜寻结果传回，我们可以用group( )方法将结果传回，<strong>不过search( )将只传回第一个比对相符的字符串</strong></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parseString</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;解析字符串是否含有号码&#x27;&#x27;&#x27;</span></span><br><span class="line">    phoneRule = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d\d\d\d-\d\d\d-\d\d\d&#x27;</span>)</span><br><span class="line">    phoneNum = phoneRule.search(string)</span><br><span class="line">    <span class="keyword">if</span> phoneNum != <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s - %s&quot;</span> % (string, phoneNum.group()))</span><br></pre></td></tr></table></figure></blockquote><h4 id="16-2-4-findall">16.2.4 findall()</h4><blockquote><p>这个方法可以传回所有找到的字符串。这个方法会将搜寻到的字符串用列表方式传回</p><p>如果没有比对相符的字符串就传回[ ]空列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line">phoneNum = phoneRule.findall(string)</span><br><span class="line"><span class="built_in">print</span>(phoneNum)</span><br></pre></td></tr></table></figure></blockquote><h4 id="16-2-5-再看re模块">16.2.5 再看re模块</h4><blockquote><p>Python语言的re模块对于search( )和findall()有提供更强的功能，可以省略使用re.compile( )直接将比对模式放在各自的参数内</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># re.search(pattern, string, flags)</span></span><br><span class="line"><span class="comment"># re.findall(pattern, string, flags)</span></span><br><span class="line">pattern = <span class="string">r&#x27;\d\d\d\d-\d\d\d-\d\d\d&#x27;</span></span><br><span class="line">phoneNum = re.search(pattern, <span class="string">&#x27;...&#x27;</span>)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p>pattern是欲搜寻的正则表达方式</p></li><li class="lvl-2"><p>string是所搜寻的字符串</p></li><li class="lvl-2"><p>flags可以省略</p></li></ul></blockquote><h4 id="16-2-6-再看正则表达式">16.2.6 再看正则表达式</h4><blockquote><p>对于重复出现的字符串可以用<strong>大括号内部加上重复次数</strong>方式表达</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># r&#x27;\d\d\d\d-\d\d\d-\d\d\d&#x27;</span></span><br><span class="line"><span class="string">r&#x27;\d&#123;4&#125;-\d&#123;3&#125;-\d&#123;3&#125;&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="16-3-更多搜寻对比模式">16.3 更多搜寻对比模式</h3><h4 id="16-3-1-使用小括号分组">16.3.1 使用小括号分组</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># r&#x27;\d\d-\d\d\d\d\d\d\d\d&#x27;</span></span><br><span class="line"><span class="string">r&#x27;(\d\d)-(\d\d\d\d\d\d\d\d&#x27;</span>)</span><br><span class="line"><span class="string">r&#x27;(\d&#123;2&#125;)-(\d&#123;8&#125;)&#x27;</span></span><br></pre></td></tr></table></figure><p>所谓括号分组是以连字符“-”区别，然后用小括号隔开群组</p><p>当使用re.search( )执行比对时，未来可以使用group( )传回比对符合的不同分组</p><ul class="lvl-1"><li class="lvl-2"><p>group( )或group(0)传回第一个比对相符的文字</p></li><li class="lvl-2"><p>group(1)则传回括号的第一组文字</p></li><li class="lvl-2"><p>group(2)则传回括号的第二组文字</p></li></ul><p>若是使用findall( )方法处理，会传回<strong>元组(tuple)的列表(list)</strong>，元组内的每个元素就是搜寻的分组内容</p></blockquote><h4 id="16-3-2-groups">16.3.2 groups()</h4><blockquote><p>若是使用findall( )方法处理，会传回元组(tuple)的列表(list)，元组内的每个元素就是搜寻的分组内容</p><p>这时还可以使用多重指定的观念</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多重指定</span></span><br><span class="line">areaNum, localNum = phoneNum.groups()</span><br><span class="line"><span class="comment"># &#x27;02-26669999&#x27;</span></span><br><span class="line"><span class="comment"># areaNum = 02</span></span><br><span class="line"><span class="comment"># localNum = 26669999</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="16-3-3-区域号码是在小括号内">16.3.3 区域号码是在小括号内</h4><blockquote><p><code>(02)-26669999</code></p><p>处理小括号时，方式是\(和\)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&#x27;(\(\d&#123;2&#125;\))-(\d&#123;8&#125;)&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="16-3-4-使用管道">16.3.4 使用管道|</h4><blockquote><p>|(pipe)在正规表示法称管道，使用管道我们可以同时搜寻比对多个字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意单引号&#x27;或|旁不可留空白</span></span><br><span class="line">pattern = <span class="string">&#x27;Mary|Tom&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="16-3-5-多个分组的管道搜寻">16.3.5 多个分组的管道搜寻</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&#x27;John(son|nason|nathan)&#x27;</span></span><br></pre></td></tr></table></figure><p>若是使用findall( )方法处理，将只传回各分组搜寻到的字符串，如果要列出完整的内容，可以用循环同时为每个分组字符串加上前导字符串John</p></blockquote><h4 id="16-3-6-使用-号做搜寻">16.3.6 使用?号做搜寻</h4><blockquote><p>在正则表达式中若某些括号内的字符串或正则表达式可有可无，执行搜寻时皆算成功</p><ul class="lvl-1"><li class="lvl-2"><p>例如，na字符串可有可无，表达方式是(na)?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&#x27;John((na)?son)&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><h4 id="16-3-7-使用-号做搜寻">16.3.7 使用*号做搜寻</h4><blockquote><p>在正则表达式中若某些字符串或正则表达式可从0到多次，执行搜寻时皆算成功</p><ul class="lvl-1"><li class="lvl-2"><p>例如，na字符串可从0到多次，表达方式是(na)*</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&#x27;John((na)*son)&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><h4 id="16-3-8-使用-号做搜寻">16.3.8 使用+号做搜寻</h4><blockquote><p>在正则表达式中若是某些字符串或正则表达式可从1到多次，执行搜寻时皆算成功</p><ul class="lvl-1"><li class="lvl-2"><p>例如，na字符串可从1到多次，表达方式是(na)+</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&#x27;John((na)*son)&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><h4 id="16-3-9-搜寻时忽略大小写">16.3.9 搜寻时忽略大小写</h4><blockquote><p>搜寻时若是在search( )或findall( )内增加第三个参数re.I或re.IGNORECASE，搜寻时就会忽略大小写，至于打印输出时将以原字符串的格式显示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">txt = re.findall(pattern, msg, re.I)</span><br></pre></td></tr></table></figure></blockquote><h3 id="16-4-贪婪与非贪婪搜寻">16.4 贪婪与非贪婪搜寻</h3><h4 id="16-4-1-搜寻时使用大括号设定比对次数">16.4.1 搜寻时使用大括号设定比对次数</h4><blockquote><p><code>\d&#123;4&#125;</code>代表重复4次，可以将这个观念应用在搜寻一般字符串，例如，<code>(son)&#123;3&#125;</code></p><p>大括号除了可以设定重复次数，也可以设定指定范围，例如，<code>(son)&#123;3,5&#125;</code>$\rightarrow$[3, 5]</p><p>使用大括号时，也可以省略第一或第二个数字，这相当于不设定最小或最大重复次数</p><ul class="lvl-1"><li class="lvl-2"><p><code>1(son)&#123;3,&#125;</code>代表重复3次以上皆符合</p></li><li class="lvl-2"><p><code>(son)&#123;,10&#125;</code>代表重复10次以下皆符合</p></li></ul></blockquote><h4 id="16-4-2-贪婪与非贪婪搜寻">16.4.2 贪婪与非贪婪搜寻</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#x27;(son)&#123;3,5&#125;&#x27;---&gt;&quot;sonsonsonsonson&quot;</span></span><br><span class="line">txt.re.search(pattern, msg)</span><br><span class="line">txt.group()</span><br><span class="line"><span class="comment"># sonsonsonsonson</span></span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2"><p>贪婪模式</p><ul class="lvl-3"><li class="lvl-4">Python执行结果是列出最多重复的字符串，以这个实例而言是重复5次</li><li class="lvl-4">这是Python的默认模式，这种模式又称贪婪(greedy)模式</li></ul></li><li class="lvl-2"><p>非贪婪模式</p><ul class="lvl-3"><li class="lvl-4"><p>另一种是列出最少重复的字符串，以这个实例而言是重复3次，这称非贪婪模式</p></li><li class="lvl-4"><p>方法是在正则表达式的搜寻模式右边增加？符号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非贪婪模式</span></span><br><span class="line">pattern = <span class="string">&#x27;(son)&#123;3,5&#125;?&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></blockquote><h3 id="16-5-正则表达式的特殊字符">16.5 正则表达式的特殊字符</h3><h4 id="16-5-1-特殊字符表">16.5.1 特殊字符表</h4><table><thead><tr><th>字符</th><th>使用说明</th></tr></thead><tbody><tr><td>\d</td><td>0~9的整数字元</td></tr><tr><td>\D</td><td>除了0~9的整数字元以外的其他字符</td></tr><tr><td>\s</td><td>空白,定位,Tab键,换行,换页字符</td></tr><tr><td>\S</td><td>除了空白,定位,Tab键,换行,换页字符以外的其他字符</td></tr><tr><td>\w</td><td>数字,字母和底线 _ 字符, [0-9A-Za-z_]</td></tr><tr><td>\W</td><td>除了数字,字母和底线 _ 字符, [0-9A-Za-z_]以外的其他字符</td></tr></tbody></table><h4 id="16-5-2-字符分类">16.5.2 字符分类</h4><blockquote><p>Python可以使用中括号来设定字符</p><p>示例</p><ul class="lvl-1"><li class="lvl-2"><p>[a-z]：代表a-z的小写字符</p></li><li class="lvl-2"><p>[A-Z]：代表A-Z的大写字符</p></li><li class="lvl-2"><p>[aeiouAEIOU]：代表英文发音的元音字符</p></li><li class="lvl-2"><p>[2-5]：代表2-5的数字</p></li></ul><p>在字符分类中，中括号内可以不用放上正则表示法的反斜杠\执行<code>.</code>、<code>?</code>、<code>*</code>、<code>(</code>、<code>)</code>等字符的转译</p><ul class="lvl-1"><li class="lvl-2"><p><code>[2-5.]</code>不用写成<code>[2-5\.]</code></p></li></ul></blockquote><h4 id="16-5-3-字符分类的-字符">16.5.3 字符分类的^字符</h4><blockquote><p>如果在中括号内的左方加上^字符，意义是搜寻不在这些字符内的所有字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&#x27;[^2-5.]&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="16-5-4-正则表示法的-字符">16.5.4 正则表示法的^字符</h4><blockquote><p>在正规表示法中起始位置加上^字符，表示正则表示法的字符串必须出现在被搜寻字符串的起始位置，这样搜寻成功才算成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&#x27;^John&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="16-5-5-正则表示法的-字符">16.5.5 正则表示法的$字符</h4><blockquote><p>正则表示法的末端放置$字符时，表示正则表示法的字符串必须出现在被搜寻字符串的最后位置，这样搜寻成功才算成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&#x27;\W$&#x27;</span></span><br></pre></td></tr></table></figure><p><code>^</code>字符和<code>$</code>字符混合使用，这时如果既要符合开始字符串也要符合结束字符串，所以被搜寻的句子一定要只有一个字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜寻开始和结尾皆是数字的字符串</span></span><br><span class="line">pattern = <span class="string">&#x27;^\d+$&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="16-5-6-单一字符使用通配符">16.5.6 单一字符使用通配符&quot;.&quot;</h4><blockquote><p>通配符(wildcard)<code>“.”</code>表示可以搜寻除了<strong>换行字符</strong>以外的所有字符，但是只限定一个字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&#x27;.at&#x27;</span></span><br></pre></td></tr></table></figure><p>如果搜寻的是真正的<code>“.”</code>字符，须使用反斜杠<code>“\.”</code></p></blockquote><h4 id="16-5-7-所有字符使用通配符">16.5.7 所有字符使用通配符&quot;.*&quot;</h4><blockquote><p>若是将<code>“.”</code>字符与<code>“*”</code>组合，可以搜寻所有字符，意义是搜寻0到多个通配符（换行字符除外）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&#x27;Name:(.*)&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="16-5-8-换行字符的处理">16.5.8 换行字符的处理</h4><blockquote><p>使用<code>“.*”</code>搜寻时碰上换行字符，搜寻就停止。Python的re模块提供参数<code>re.DOTALL</code>，功能是包括搜寻换行字符，可以将此参数放在search( )、findall( )或compile( )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&#x27;.*&#x27;</span></span><br><span class="line">txt = re.search(pattern, msg, re.DOTALL)</span><br></pre></td></tr></table></figure></blockquote><h3 id="16-6-MatchObject对象">16.6 MatchObject对象</h3><blockquote><p>使用re.search( )搜寻字符串，搜寻成功时可以产生MatchObject对象</p></blockquote><h4 id="16-6-1-re-match">16.6.1 re.match()</h4><blockquote><p>re模块另一个搜寻字符串的方法是re.match( )，这个方法其实和re.search( )相同，差异是re.match( )只搜寻比对字符串开始的字，如果失败就算失败</p><p>re.match( )搜寻成功会传回MatchObject对象，若是搜寻失败会传回None，这部分与re.search( )相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&#x27;John&#x27;</span></span><br><span class="line">msg = <span class="string">&#x27;John...&#x27;</span></span><br><span class="line">txt = re.<span class="keyword">match</span>(pattern, msg)</span><br></pre></td></tr></table></figure></blockquote><h4 id="16-6-2-MatchObject几个重要的方法">16.6.2 MatchObject几个重要的方法</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">&#x27;John&#x27;</span></span><br><span class="line">msg = <span class="string">&#x27;John...&#x27;</span></span><br><span class="line">txt = re.<span class="keyword">match</span>(pattern, msg)</span><br><span class="line"><span class="keyword">if</span>(txt != <span class="literal">None</span>):</span><br><span class="line">    <span class="built_in">print</span>(txt)</span><br><span class="line"><span class="comment"># &lt;re.Match object; span=(0, 4), match=&#x27;John&#x27;&gt;</span></span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">span是注明成功搜寻字符串的起始位置和结束位置，从此处可以知道起始索引位置是0，结束索引位置是4</li><li class="lvl-2">match则是注明成功搜寻的字符串内容</li></ul></blockquote><p><strong>Python提供下列取得MatchObject对象内容的重要方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>group()</td><td>可传回搜寻到的字符串</td></tr><tr><td>end()</td><td>可传回搜寻到的字符串的结束位置</td></tr><tr><td>start()</td><td>可传回搜寻到的字符串的起始位置</td></tr><tr><td>span()</td><td>可传回搜寻到的字符串的(起始, 结束)位置</td></tr></tbody></table><h3 id="16-7-抢救CIA情报员-sub-方法">16.7 抢救CIA情报员-sub()方法</h3><blockquote><p>Python re模块内的sub( )方法可以用新的字符串取代原本字符串的内容</p></blockquote><h4 id="16-7-1-一般应用">16.7.1 一般应用</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># msg是整个欲处理的字符串或句子</span></span><br><span class="line">result = re.sub(pattern, newstr, msg)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">pattern是欲搜寻的字符串，如果搜寻成功则用newstr取代，同时成功取代的结果回传给result变量</li><li class="lvl-2">如果搜寻到多个相同字符串，这些字符串将全部被取代，需留意原先msg内容将不会改变</li><li class="lvl-2">如果搜寻失败则将msg内容回传给result变量，当然msg内容也不会改变</li></ul></blockquote><h4 id="16-7-2-抢救CIA情报员">16.7.2 抢救CIA情报员</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&#x27;CIA (\w)\w*&#x27;</span></span><br><span class="line">newstr = <span class="string">r&#x27;\1***&#x27;</span></span><br><span class="line">txt = re.sub(pattern, newstr, msg)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">整行只有一个括号所以知道这是第一分组</li><li class="lvl-2"><code>\1</code>代表分组1的字符串</li></ul></blockquote><h3 id="16-8-处理比较复杂的正则表示法">16.8 处理比较复杂的正则表示法</h3><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&#x27;((\d&#123;2&#125;|\(\d&#123;2&#125;\))?(\s|-)?\d&#123;8&#125;(\s*(ext|ext.)\s*\d&#123;2,4&#125;)?)&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="16-8-1-将正则表达式拆成多行字符串">16.8.1 将正则表达式拆成多行字符串</h4><blockquote><p>可以使用3个单引号（或是双引号）将过长的字符串拆成多行表达，这个观念也可以应用在正则表达式</p><p>当我们适当地拆解后，可以为每一行加上批注，整个正则表达式就变得简单了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&#x27;&#x27;&#x27;(</span></span><br><span class="line"><span class="string"># 区域号码</span></span><br><span class="line"><span class="string">    (\d&#123;2&#125;|\(\d&#123;2&#125;\))?</span></span><br><span class="line"><span class="string">    # 区域号码与电话号码的分隔符</span></span><br><span class="line"><span class="string">    (\s|-)?</span></span><br><span class="line"><span class="string">    # 电话号码</span></span><br><span class="line"><span class="string">    \d&#123;8&#125;</span></span><br><span class="line"><span class="string">    # 2-4位数的分机号码</span></span><br><span class="line"><span class="string">    (\s*(ext|ext.)\s*\d&#123;2,4&#125;)?</span></span><br><span class="line"><span class="string">    )&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="16-8-2-re-VERBOSE">16.8.2 re.VERBOSE</h4><blockquote><p>使用Python时，如果想在正则表达式中加上批注，必须配合使用re.VERBOSE参数，然后将此参数放在search( )、findall( )或compile( )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&#x27;(02)-26669999, ...&#x27;</span></span><br><span class="line">pattern = <span class="string">r&#x27;&#x27;&#x27;(</span></span><br><span class="line"><span class="string"># 区域号码</span></span><br><span class="line"><span class="string">    (\d&#123;2&#125;|\(\d&#123;2&#125;\))?</span></span><br><span class="line"><span class="string">    # 区域号码与电话号码的分隔符</span></span><br><span class="line"><span class="string">    (\s|-)?</span></span><br><span class="line"><span class="string">    # 电话号码</span></span><br><span class="line"><span class="string">    \d&#123;8&#125;</span></span><br><span class="line"><span class="string">    # 2-4位数的分机号码</span></span><br><span class="line"><span class="string">    (\s*(ext|ext.)\s*\d&#123;2,4&#125;)?</span></span><br><span class="line"><span class="string">    )&#x27;&#x27;&#x27;</span></span><br><span class="line">phoneNum = re.findall(pattern, msg, re.VERBOSE)</span><br><span class="line"><span class="built_in">print</span>(phoneNum)</span><br><span class="line"><span class="comment"># [(&#x27;(02)-26669999&#x27;, &#x27;(02)&#x27;, &#x27;-&#x27;, &#x27;&#x27;, &#x27;&#x27;)]</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="16-8-3-电子邮件地址的搜寻">16.8.3 电子邮件地址的搜寻</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="string">r&#x27;&#x27;&#x27;(</span></span><br><span class="line"><span class="string"># 使用者账号</span></span><br><span class="line"><span class="string">[a-zA-Z0-9_.]+</span></span><br><span class="line"><span class="string"># @符号</span></span><br><span class="line"><span class="string">@</span></span><br><span class="line"><span class="string"># 主机域名domain</span></span><br><span class="line"><span class="string">[a-zA-Z0-9_.]+</span></span><br><span class="line"><span class="string"># .符号</span></span><br><span class="line"><span class="string">[.]</span></span><br><span class="line"><span class="string"># 可能是com或edu或其他</span></span><br><span class="line"><span class="string">[a-zA-Z]&#123;2,4&#125;</span></span><br><span class="line"><span class="string"># .符号,也可能无特别是美国</span></span><br><span class="line"><span class="string">([.])?</span></span><br><span class="line"><span class="string"># 国别</span></span><br><span class="line"><span class="string">([a-zA-Z]&#123;2,4&#125;)?</span></span><br><span class="line"><span class="string">)&#x27;&#x27;&#x27;</span></span><br><span class="line">eMail = re.findall(pattern, msg, re.VERBOSE)</span><br></pre></td></tr></table></figure></blockquote><h4 id="16-8-4-re-IGNORECASE-re-DOTALL-re-VERBOSE">16.8.4 re.IGNORECASE/re.DOTALL/re.VERBOSE</h4><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datastr = re.search(pattern, msg, re.IGNORECASE|re.DOTALL|re.VERBOSE)</span><br></pre></td></tr></table></figure><ul class="lvl-1"><li class="lvl-2">一次放置多个参数特性</li></ul></blockquote>]]></content:encoded>
      
      
      <category domain="https://xuan51.github.io/categories/python/">python</category>
      
      
      
      <comments>https://xuan51.github.io/2022/09/16/Python%E5%9F%BA%E7%A1%80/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>octave基础</title>
      <link>https://xuan51.github.io/2022/09/06/octave%E5%9F%BA%E7%A1%80/</link>
      <guid>https://xuan51.github.io/2022/09/06/octave%E5%9F%BA%E7%A1%80/</guid>
      <pubDate>Tue, 06 Sep 2022 15:36:36 GMT</pubDate>
      
      <description>&lt;p&gt;Octave精于矩阵运算，是一种解释性语言&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Octave精于矩阵运算，是一种解释性语言</p><span id="more"></span><h1>Octave基础</h1><h2 id="基本知识">基本知识</h2><blockquote><p>简单计算</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">octave:1&gt; 2+2</span><br><span class="line">ans = 4</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>优先级</code>：括号最大，乘方其次，之后是乘除、加减</p></li><li class="lvl-2"><p><code>ans变量</code>：存储每次最近运算的结果</p></li></ul><blockquote><p>内建函数</p></blockquote><img src="/2022/09/06/octave%E5%9F%BA%E7%A1%80/image-20220906233536180.png" alt="image-20220906233536180"><blockquote><p>显示</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">octave:32&gt; disp(&#x27;output string&#x27;)</span><br><span class="line">output string</span><br><span class="line">octave:33&gt; disp(t)</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>显示一个值或者字符串</p></li></ul><blockquote><p>特殊变量：本身已经定义</p></blockquote><p><code>pi</code>，<code>i</code>和<code>j</code>等</p><blockquote><p>变量</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">octave:1&gt; deg = pi/180</span><br><span class="line">deg = 0.017453</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>类型不用声明</p></li><li class="lvl-2"><p>所有变量都是浮点型或者字符串</p></li><li class="lvl-2"><p>octave的结果只以一定的精度展示出来，而实际上它存储的变量的精度要比其显示的高很多</p></li><li class="lvl-2"><p>变量名区分大小写</p></li><li class="lvl-2"><p>可以重新定义特殊变量和内建函数（覆盖），但不提倡</p></li><li class="lvl-2"><p>查看某个变量的值（输入变量名并回车）</p><ul class="lvl-2"><li class="lvl-4"></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">octave:10&gt; deg</span><br><span class="line">deg = 5</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p>查看当前所有变量</p><ul class="lvl-2"><li class="lvl-4"></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">octave:3&gt; who</span><br><span class="line">Variables visible from the current scope:</span><br><span class="line"></span><br><span class="line">ans  deg</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p>从当前的变量空间中删除某个变量</p><ul class="lvl-2"><li class="lvl-4"></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">octave:4&gt; clear deg</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>数值及其格式</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>计算机内二进制形式存储</p></li><li class="lvl-2"><p>Octave通常只显示一定的有效数字</p></li><li class="lvl-2"><p>format命令能让你选择数值显示的不同方式</p><ul class="lvl-2"><li class="lvl-4"></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">octave:1&gt; deg = pi</span><br><span class="line">deg = 3.1416</span><br><span class="line">#以15位的有效数字显示数值，这也是octave程序本身的计算精度</span><br><span class="line">octave:2&gt; format long</span><br><span class="line">octave:3&gt; deg</span><br><span class="line">deg = 3.141592653589793</span><br><span class="line">#不存在int</span><br><span class="line">octave:4&gt; format int</span><br><span class="line">error: format: unrecognized format state &#x27;int&#x27;</span><br><span class="line">#默认方式显示数据</span><br><span class="line">octave:5&gt; format short</span><br><span class="line">octave:6&gt; deg</span><br><span class="line">deg = 3.1416</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p>使用科学记数法来表达数值很大或者很小的数字</p><ul class="lvl-2"><li class="lvl-4"></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">octave:9&gt; deg * 0.000000001</span><br><span class="line">ans = 3.1416e-09</span><br></pre></td></tr></table></figure><ul class="lvl-2"><li class="lvl-4"><p>科学记数法的数值输入形式也同样能被Octave认可</p></li><li class="lvl-4"><p>其他被认可的数据形式</p><ol><li class="lvl-7">复数（3+4i)</li><li class="lvl-7">无穷大（Inf）一个数除零得到的结果</li><li class="lvl-7">非数值（NaN）零除以零或者其他数学表达式无法得到合法结果时的返回值</li><li class="lvl-7">Inf和NaN可以参与运算，得到的结果通常还是Inf或者NaN</li></ol></li></ul></li></ul><blockquote><p>数值的表示和精度</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">octave:14&gt; 1-0.2-0.2-0.2-0.2-0.2</span><br><span class="line">ans = 5.5511e-17</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>造成的原因在于0.2无法使用有效的位数精确表示出来</p></li></ul><blockquote><p>载入和保存数据</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">octave:15&gt; save anyname</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>将整个工作空间上的变量存储到默认workSpace（可修改）下的anyname文件中</p></li><li class="lvl-2"><p><code>C:\Users\21906\anyname</code></p></li><li class="lvl-2"><p>还有可能是这个目录<code>...\GNU Octave\Octave-7.2.0\mingw64\bin</code></p></li><li class="lvl-2"><p>修改工作目录</p><ul class="lvl-2"><li class="lvl-4"><img src="/2022/09/06/octave%E5%9F%BA%E7%A1%80/image-20220907193057925.png" alt="image-20220907193057925" style="zoom:75%;"></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">octave:16&gt; load anyname</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>载入之前保存的文件</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">octave:3&gt; save filename var1 var2 ... </span><br><span class="line">octave:1&gt; load filename</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>载入或保存特定的变量</p></li></ul><blockquote><p>重复之前命令</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>通过方向建上和下来查看之前输入的命令</p></li></ul><blockquote><p>查看命令或函数功能</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">octave:1&gt; help sin</span><br><span class="line">&#x27;sin&#x27; is a built-in function from the file libinterp/corefcn/mappers.cc</span><br><span class="line"></span><br><span class="line"> -- sin (X)</span><br><span class="line">     Compute the sine for each element of X in radians.</span><br><span class="line"></span><br><span class="line">     See also: asin, sind, sinh.</span><br><span class="line"></span><br><span class="line">Additional help for built-in functions and operators is</span><br><span class="line">available in the online version of the manual.  Use the command</span><br><span class="line">&#x27;doc &lt;topic&gt;&#x27; to search the manual index.</span><br><span class="line"></span><br><span class="line">Help and information about Octave is also available on the WWW</span><br><span class="line">at https://www.octave.org and via the help@octave.org</span><br><span class="line">mailing list.</span><br></pre></td></tr></table></figure><blockquote><p>取消一个命令</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p><code>Ctrl + C</code>：当一个命令执行很长时间时（或程序bug让程序无限重复等），中止该程序的执行</p></li></ul><blockquote><p>分号</p></blockquote><p>在一行语句的末尾添上分号，Octave将不会显出相应的结果</p><h2 id="数组和向量">数组和向量</h2><blockquote><p>构造向量</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">octave:7&gt; a = [1 2 3]</span><br><span class="line">a =</span><br><span class="line">   1   2   3</span><br><span class="line">octave:8&gt; a = [1, 2, 3]</span><br><span class="line">a =</span><br><span class="line">   1   2   3</span><br><span class="line">octave:9&gt; a = [1; 2; 3]</span><br><span class="line">a =</span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line">   3</span><br><span class="line">octave:10&gt; a = [ 1</span><br><span class="line">&gt; 2</span><br><span class="line">&gt; 3]</span><br><span class="line">a =</span><br><span class="line">   1</span><br><span class="line">   2</span><br><span class="line">   3</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>空格或逗号隔开的是行向量</p></li><li class="lvl-2"><p>分号或回车隔开的是列向量</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">octave:15&gt; d = [a 6]</span><br><span class="line">d =</span><br><span class="line">   1   2   3   6</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>通过已经定义的向量来定义新的向量</p></li></ul><blockquote><p>冒号表达式</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">octave:20&gt; a = 2: 6</span><br><span class="line">a =</span><br><span class="line">   2   3   4   5   6</span><br><span class="line">octave:19&gt; a = 2: 0.5: 4</span><br><span class="line">a =</span><br><span class="line">    2.0000    2.5000    3.0000    3.5000    4.0000</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>可以在第一个和第二个数之间插入第三个参数来声明向量中元素之间的递增量</p></li><li class="lvl-2"><p>增量可以是负数</p></li></ul><blockquote><p>大矩阵或矩阵的显示</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">octave:23&gt; v = 1: 1000</span><br><span class="line">-- less -- (f)orward, (b)ack, (q)uit</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>分屏显示</p></li><li class="lvl-2"><p>开启或关闭这个显示功能</p><ul class="lvl-2"><li class="lvl-4"></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">octave:26&gt; more on</span><br><span class="line">octave:27&gt; more off</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>向量构造函数</p></blockquote><img src="/2022/09/06/octave%E5%9F%BA%E7%A1%80/image-20220907202355581.png" alt="image-20220907202355581" style="zoom:80%;"><ul class="lvl-0"><li class="lvl-2"><p><code>size</code>函数返回矩阵或者向量的行数和列数</p></li></ul><blockquote><p>向量中的元素操作</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">octave:39&gt; a = [1:2:6 0]</span><br><span class="line">a =</span><br><span class="line">   1   3   5   0</span><br><span class="line">octave:40&gt; a(1)</span><br><span class="line">ans = 1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>下标从1开始</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">octave:43&gt; a(2:4)</span><br><span class="line">ans =</span><br><span class="line">   3   5   0</span><br><span class="line">octave:44&gt; a(2:2:4)</span><br><span class="line">ans =</span><br><span class="line">   3   0</span><br></pre></td></tr></table></figure><blockquote><p>向量的计算</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">octave:45&gt; 2*a</span><br><span class="line">ans =</span><br><span class="line">    2    6   10    0</span><br><span class="line">octave:49&gt; a+1</span><br><span class="line">ans =</span><br><span class="line">   2   4   6   1</span><br><span class="line">octave:50&gt; a-1</span><br><span class="line">ans =</span><br><span class="line">   0   2   4  -1</span><br><span class="line">octave:52&gt; a/2</span><br><span class="line">ans =</span><br><span class="line">   0.5000   1.5000   2.5000        0</span><br><span class="line">octave:54&gt; a.*a</span><br><span class="line">ans =</span><br><span class="line">    1    9   25    0</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>两个向量相乘遵循矩阵乘法法则</p></li><li class="lvl-2"><p>如果要进行对应元素乘除法可以在运算符前加<code>.</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">octave:56&gt; a.^2</span><br><span class="line">ans =</span><br><span class="line">    1    9   25    0</span><br><span class="line">octave:57&gt; 2.^a</span><br><span class="line">ans =</span><br><span class="line">    2    8   32    1</span><br><span class="line">octave:58&gt; a.^a</span><br><span class="line">ans =</span><br><span class="line">      1     27   3125      1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>逐个元素乘法计算</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">octave:60&gt; sin([0:pi/2:pi])</span><br><span class="line">ans =</span><br><span class="line">        0   1.0000   0.0000</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>大多数函数能以向量为输入</p></li></ul><h2 id="画图">画图</h2><p>Octave通过调用另一个开源软件<a href="http://www.gnuplot.info/">GNUPLOT</a>来实现非常丰富的画图功能</p><p>若是对图片的细节要求更高，推荐将数据格式化输出并单独使用gnuplot生成图形</p><blockquote><p>基本画图命令</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">octave:67&gt; plot([0,1,2], [0,1,4])</span><br></pre></td></tr></table></figure><img src="/2022/09/06/octave%E5%9F%BA%E7%A1%80/image-20220907210229482.png" alt="image-20220907210229482" style="zoom:75%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">octave:71&gt; plot([0,1,2], [0,1,4], &#x27;ro&#x27;)</span><br></pre></td></tr></table></figure><p>使用红色和圆圈来画图</p><img src="/2022/09/06/octave%E5%9F%BA%E7%A1%80/image-20220907210740751.png" alt="image-20220907210740751" style="zoom:75%;"><p>颜色和样式（见help plot）（†仅在Matlab中存在的选项）</p><img src="/2022/09/06/octave%E5%9F%BA%E7%A1%80/image-20220907211122272.png" alt="image-20220907211122272" style="zoom:100%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">octave:77&gt; title(&#x27;title&#x27;)</span><br><span class="line">octave:78&gt; xlabel(&#x27;x&#x27;)</span><br><span class="line">octave:79&gt; ylabel(&#x27;y&#x27;)</span><br><span class="line">octave:86&gt; grid off</span><br><span class="line">octave:87&gt; grid on</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>title</code>添加标题</p></li><li class="lvl-2"><p><code>xlabel</code>x轴名称</p></li><li class="lvl-2"><p><code>ylabel</code>y轴名称</p></li><li class="lvl-2"><p><code>grid</code>命令为图片添加网格线</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">octave:103&gt; plot(x,y,&#x27;ro&#x27;)</span><br><span class="line">octave:104&gt; hold on</span><br><span class="line">octave:105&gt; plot(x,cos(x),&#x27;g-&#x27;)</span><br><span class="line">octave:106&gt; legend(&#x27;Sine&#x27;, &#x27;Cosine&#x27;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>重新输入plot命令后原图将被覆盖</p></li><li class="lvl-2"><p><code>legend</code>命令为该图片添加相应的图例</p></li><li class="lvl-2"><p><code>hold</code>命令可以将新创建的图片层叠到原图上</p></li><li class="lvl-2"><p><code>hold off</code>命令可以关闭该功能</p></li></ul><img src="/2022/09/06/octave%E5%9F%BA%E7%A1%80/image-20220907213221511.png" alt="image-20220907213221511" style="zoom:75%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">octave:12&gt; axis([-1 4 -1 2])</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>设置坐标轴</p></li><li class="lvl-2"><p>x范围为[1, 4]</p></li><li class="lvl-2"><p>y范围为[1, 2]</p></li></ul><blockquote><p>新窗口绘制</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">octave:3&gt; figure</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>绘制一个新窗口，下一个plot命令将会在新窗口中绘制</p></li></ul><blockquote><p>返回上一个窗口</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">octave:8&gt; figure(1)</span><br></pre></td></tr></table></figure><blockquote><p>保存和打印图片</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">octave:16&gt; print(&#x27;cos.eps&#x27;,&#x27;-deps&#x27;)</span><br><span class="line">octave:17&gt; figure(1)</span><br><span class="line">octave:18&gt; print(&#x27;sin.png&#x27;,&#x27;-dpng&#x27;)</span><br><span class="line">octave:20&gt; print(&#x27;D:\sin.png&#x27;,&#x27;-dpng&#x27;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>可以通过figure切换窗口</p></li><li class="lvl-2"><p>默认保存在workSpace目录下</p></li><li class="lvl-2"><p>可以使用绝对路径</p></li></ul><h2 id="脚本文件">脚本文件</h2><ol><li class="lvl-3"><p>可以将一系列命令存入一个Octave脚本之中</p></li><li class="lvl-3"><p>需要有一个<code>.m</code>的后缀，通常也称为<code>M</code>文件</p></li></ol><blockquote><p>Path问题</p></blockquote><p>Octave中有一个比较重要的环境变量就是path变量，它存储了Octave中函数所在目录的一个列表。当一个函数被调用的时候，Octave就从path变量中的列表中搜索你输入的函数。默认的Octave的path包含一系列的系统目录和当前工作目录 (pwd)。当然你也可以添加自定义的一些目录，并在该目录中存放你自己创建的一些函数或者脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">octave:21&gt; path</span><br><span class="line">Octave&#x27;s search path contains the following directories:</span><br><span class="line">.</span><br><span class="line">E:\Program Files\GNU Octave\Octave-7.2.0\mingw64\lib\octave\7.2.0\site\oct\x86_64-w64-mingw32</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>查看path命令</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">octave:22&gt; addpath(&#x27;path&#x27;)</span><br><span class="line">octave:23&gt; savepath</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>添加和保存</p></li></ul><blockquote><p>创建和编辑脚本</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">octave:1&gt; edit</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>CLI调不出来文本编辑器GUI可以调出来</p></li><li class="lvl-2"><p>可以通过配置文件进行设置</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%Script to calculate and plot a rectified sine wave</span><br><span class="line">t=linspace(0,10,100)</span><br><span class="line">y=abs(sin(t))% The abs command makes all negative numbers positive</span><br><span class="line">plot(t,y)</span><br><span class="line">title(&#x27;Rectified Sine Wave&#x27;)</span><br><span class="line">xlabel(&#x27;t&#x27;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>百分号符号是表明注释</p></li><li class="lvl-2"><p>将该文件保存为<code>rectsin.m</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">octave:7&gt; rectsin</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>运行该脚本</p></li><li class="lvl-2"><p>默认从workSpace中读取</p></li></ul><blockquote><p>查看拥有的脚本</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">octave:1&gt; what</span><br><span class="line">M-files in directory E:\Program Files\GNU Octave\workSpace:</span><br><span class="line">   rectsin.m</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>获取一个你当前所有的脚本和数据的列表</p></li><li class="lvl-2"><p><code>help rectsin</code>：一个脚本文件的头几行注释是该脚本的描述</p></li></ul><h2 id="控制语句">控制语句</h2><h3 id="if…else语句">if…else语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if t == 1</span><br><span class="line">    f = 1</span><br><span class="line">    g = 1</span><br><span class="line">elseif t == 2</span><br><span class="line">f = 2</span><br><span class="line">else</span><br><span class="line">f = 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>通常使用在脚本之中，同样也能用在命令行中</p></li><li class="lvl-2"><p>和C++语法有一定的差异</p><ol><li class="lvl-5">条件不需要括起来（也可以括起来使程序更加明了）</li><li class="lvl-5">程序块不需要大括号括起来</li><li class="lvl-5">需要end命令来标识if语句结束</li><li class="lvl-5">if…end和if…endif都是合法的</li><li class="lvl-5">使用end可以让Octave和Matlab文件兼容</li></ol></li><li class="lvl-2"><p>真返回1假返回0</p></li><li class="lvl-2"><p>布尔表达式</p><ul class="lvl-2"><li class="lvl-4"><img src="/2022/09/06/octave%E5%9F%BA%E7%A1%80/image-20220908160538771.png" alt="image-20220908160538771" style="zoom:100%;"></li></ul></li></ul><h3 id="switch语句">switch语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = &#x27;t&#x27;</span><br><span class="line">switch t</span><br><span class="line">    case &#x27;x&#x27;</span><br><span class="line">        t = 0</span><br><span class="line">    case &#x27;t&#x27;</span><br><span class="line">        t = 1</span><br><span class="line">    otherwise</span><br><span class="line">        t = -1</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>不需要break语句</p></li></ul><h3 id="for语句">for语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for n = 1:5</span><br><span class="line">    disp(n)</span><br><span class="line">    f(n) = n;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>多使用向量计算而不是for循环，通常for循环会慢很多</p></li><li class="lvl-2"><p>加入分号能避免每次执行循环时的输出</p></li></ul><h3 id="while语句">while语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 0</span><br><span class="line">while x &lt; 10</span><br><span class="line">    x += 1;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="函数">函数</h2><ol><li class="lvl-3"><p>参数通过值传递</p></li><li class="lvl-3"><p>能返回多个返回值</p></li><li class="lvl-3"><p>跟脚本一样是写入一个纯文本文件中的</p></li><li class="lvl-3"><p>函数文件第一行遵循如下格式</p><ul class="lvl-2"><li class="lvl-5"></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function [output1, output2, ...] = name(input1, input2, ...)</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>每个函数写在不同的M文件中，该M文件名必须与函数名一致</p></li></ol><h3 id="函数定义">函数定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function s = sind(x)</span><br><span class="line">% 角度制正弦函数</span><br><span class="line">s = sin(x*pi/180);</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p>改行表示定义的是一个函数而不是脚本。定义了一个sind函数，有一个输入参数和一个返回值</p></li><li class="lvl-3"><p>该行是注释行。<code>help sind</code>的返回内容，注意使用中文时的字符集</p></li><li class="lvl-3"><p>改行实现函数的真正功能</p></li><li class="lvl-3"><p>结尾需以endfunction结束（通常不需要return语句，不过可以使用该语句从函数体中间跳出来终止函数体）</p><ul class="lvl-2"><li class="lvl-5">error函数可以打印一个信息并中止该函数的执行</li></ul></li><li class="lvl-3"><p><strong>同样适用于向量参数的输入</strong></p></li></ol><h2 id="矩阵和向量">矩阵和向量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">octave:13&gt; A = [1 2 3</span><br><span class="line">&gt; 4 5 6]</span><br><span class="line">A =</span><br><span class="line">   1   2   3</span><br><span class="line">   4   5   6</span><br><span class="line">octave:14&gt; B = [1 2; 3 4; 5 6]</span><br><span class="line">B =</span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">   5   6</span><br><span class="line">octave:15&gt; C = [1:3; 8:-2:4]</span><br><span class="line">C =</span><br><span class="line">   1   2   3</span><br><span class="line">   8   6   4</span><br><span class="line">% 逐行生成矩阵</span><br><span class="line">octave:16&gt; D = [1 2 3]</span><br><span class="line">octave:17&gt; D = [D; 4 5 6]</span><br><span class="line">D =</span><br><span class="line">   1   2   3</span><br><span class="line">   4   5   6</span><br></pre></td></tr></table></figure><h3 id="矩阵乘法">矩阵乘法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">octave:20&gt; A*B</span><br><span class="line">ans =</span><br><span class="line">   22   28</span><br><span class="line">   49   64</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>(l × m) ∗ (m × n) → (l × n)</p></li><li class="lvl-2"><p>如果是方阵还可以使用矩阵乘方计算</p><ul class="lvl-2"><li class="lvl-4"></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">octave:23&gt; A = [1 2</span><br><span class="line">&gt; 3 4];</span><br><span class="line">octave:24&gt; A^2</span><br><span class="line">ans =</span><br><span class="line">    7   10</span><br><span class="line">   15   22</span><br></pre></td></tr></table></figure><ul class="lvl-2"><li class="lvl-4"><p>A<sup>2</sup> = A * A</p></li></ul></li></ul><h3 id="转置算符">转置算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">octave:25&gt; A</span><br><span class="line">A =</span><br><span class="line">   1   2</span><br><span class="line">   3   4</span><br><span class="line">octave:26&gt; A&#x27;</span><br><span class="line">ans =</span><br><span class="line">   1   3</span><br><span class="line">   2   4</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>转置操作用单引号实现</p></li></ul><h3 id="矩阵创建函数">矩阵创建函数</h3><blockquote><p>创建单位矩阵</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">octave:27&gt; I = eye(4)</span><br><span class="line">I =</span><br><span class="line">Diagonal Matrix</span><br><span class="line">   1   0   0   0</span><br><span class="line">   0   1   0   0</span><br><span class="line">   0   0   1   0</span><br><span class="line">   0   0   0   1</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>数学上通常用<code>I</code>来表示单位矩阵</p></li></ul><blockquote><p>对角矩阵</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">octave:28&gt; diag([1 7 2])</span><br><span class="line">ans =</span><br><span class="line">Diagonal Matrix</span><br><span class="line">   1   0   0</span><br><span class="line">   0   7   0</span><br><span class="line">   0   0   2</span><br><span class="line">octave:29&gt; diag(A)</span><br><span class="line">ans =</span><br><span class="line">   1</span><br><span class="line">   4</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>单位矩阵是对角矩阵的特殊情况</p></li><li class="lvl-2"><p>对一个矩阵使用该函数将返回该矩阵的对角元</p></li></ul><blockquote><p>空矩阵</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">octave:30&gt; E = []</span><br><span class="line">E = [](0x0)</span><br></pre></td></tr></table></figure><blockquote><p>创建复合矩阵</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">octave:1&gt; B = [2 0; 0 1; 1 0]</span><br><span class="line">octave:2&gt; comp = [eye(3) B; B&#x27; zeros(2, 2)]</span><br><span class="line">comp =</span><br><span class="line">   1   0   0   2   0</span><br><span class="line">   0   1   0   0   1</span><br><span class="line">   0   0   1   1   0</span><br><span class="line">   2   0   1   0   0</span><br><span class="line">   0   1   0   0   0</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>注意各个子矩阵的行列数的匹配</p></li></ul><blockquote><p>引用矩阵元素</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">octave:6&gt; comp(1, 1)</span><br><span class="line">ans = 1</span><br><span class="line">octave:7&gt; comp(1:2, 4)</span><br><span class="line">ans =</span><br><span class="line">   2</span><br><span class="line">   0</span><br><span class="line">octave:8&gt; comp(3, :)</span><br><span class="line">ans =</span><br><span class="line">   0   0   1   1   0</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>可以用冒号来指定元素的范围</p></li><li class="lvl-2"><p>单独使用该符号表示整行或者整列</p></li></ul><blockquote><p>使用冒号进行矩阵元的赋值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">octave:9&gt; comp(3, 2:3) = [0 1]</span><br><span class="line">comp =</span><br><span class="line">   1   0   0   2   0</span><br><span class="line">   0   1   0   0   1</span><br><span class="line">   0   0   1   1   0</span><br><span class="line">   2   0   1   0   0</span><br><span class="line">   0   1   0   0   0</span><br></pre></td></tr></table></figure><blockquote><p>基本矩阵函数</p></blockquote><img src="/2022/09/06/octave%E5%9F%BA%E7%A1%80/image-20220909082230404.png" alt="image-20220909082230404" style="zoom:100%;"><h2 id="画图进阶">画图进阶</h2><p>Octave不仅仅能画简单的二维直角坐标系下的曲线。通过调用GNUPLOT，它可以画出 条形图，3D 表面，等高线图和极坐标图等等</p><blockquote><p>子图</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">octave:17&gt; subplot(2, 1, 1)</span><br><span class="line">octave:18&gt; plot(x, sin(x))</span><br><span class="line">octave:19&gt; subplot(2, 1, 2)</span><br><span class="line">octave:20&gt; plot(x, cos(x))</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在同一个窗口中创建多幅图片。<code>subplot(rows, columns , select)</code></p></li><li class="lvl-2"><p>子窗口序号按照从上到下、从左到右的次序递增</p></li><li class="lvl-2"><img src="/2022/09/06/octave%E5%9F%BA%E7%A1%80/image-20220909083617804.png" alt="image-20220909083617804" style="zoom:80%;"></li></ul><blockquote><p>3D画图</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% 螺旋线</span><br><span class="line">octave:27&gt; plot3(cos(2*pi*z), sin(2*pi*z), z, &quot;;helix;&quot;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><img src="/2022/09/06/octave%E5%9F%BA%E7%A1%80/image-20220909084110151.png" alt="image-20220909084110151" style="zoom:80%;"></li><li class="lvl-2"><p>xlabel和ylabel可以照常使用，同时还有新的zlabel命令</p></li><li class="lvl-2"><p>线条样式的选项也可以使用</p></li></ul><blockquote><p>调整3D绘图结果的视角</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>使用鼠标</p></li><li class="lvl-2"><p>使用<code>view</code>命令定量的确定一个特定的视角</p></li></ul><blockquote><p>3D绘图------曲面的绘制</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">octave:29&gt;  x=2:0.2:4;</span><br><span class="line">octave:30&gt; y=1:0.2:3;</span><br><span class="line">octave:31&gt; [X,Y]=meshgrid(x,y)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>初始化网格点</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">octave:33&gt; Z=(X-3).^2-(Y-2).^2;</span><br><span class="line">octave:34&gt; subplot(2, 2, 1);surf(Z);title(&#x27;surf&#x27;)</span><br><span class="line">octave:35&gt; subplot(2,2,2);mesh(Z);title(&#x27;mesh&#x27;)</span><br><span class="line">octave:36&gt;  subplot(2,2,3);meshz(Z);title(&#x27;meshz&#x27;)</span><br><span class="line">octave:37&gt;  subplot(2,2,4);contour(Z);title(&#x27;contour&#x27;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>f(x, y) = (x − 3)<sup>2</sup> − (y − 2)<sup>2</sup></p></li><li class="lvl-2"><img src="/2022/09/06/octave%E5%9F%BA%E7%A1%80/image-20220909090102233.png" alt="image-20220909090102233" style="zoom:80%;"></li></ul><h2 id="复数">复数</h2><blockquote><p>复数的创建</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">octave:43&gt; z = 4 - 3i</span><br><span class="line">z =  4 - 3i</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><img src="/2022/09/06/octave%E5%9F%BA%E7%A1%80/image-20220909092518664.png" alt="image-20220909092518664" style="zoom:100%;"></li><li class="lvl-2"><p><code>i</code>和<code>j</code>都可以代表单位虚数</p></li></ul><blockquote><p>复数运算</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">octave:46&gt; z2-z1</span><br><span class="line">ans = -3 + 6i</span><br><span class="line">octave:47&gt; z1+z2</span><br><span class="line">ans = 5</span><br><span class="line">octave:48&gt; z1/z2</span><br><span class="line">ans = -0.5000 - 1.5000i</span><br><span class="line">octave:49&gt; z1^2</span><br><span class="line">ans =   7 - 24i</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>内建函数如sin(x)或者e<sup>x</sup>都支持复数</p></li></ul><blockquote><p>绘制复数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">octave:50&gt; plot(z1, &#x27;*&#x27;, z2, &#x27;*&#x27;)</span><br><span class="line">octave:51&gt; axis([-5 5 -5 5])</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><img src="/2022/09/06/octave%E5%9F%BA%E7%A1%80/image-20220909093328080.png" alt="image-20220909093328080" style="zoom:80%;"></li></ul><h2 id="多项式求根">多项式求根</h2><p>提供了一个roots命令来求解多项式的根</p><p>方程通过其系数的向量表示来传递给roots函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">octave:57&gt; roots([1 2 -5 0 1 3])</span><br><span class="line">ans =</span><br><span class="line">  -3.4473 +      0i</span><br><span class="line">   1.1730 + 0.3902i</span><br><span class="line">   1.1730 - 0.3902i</span><br><span class="line">  -0.4494 + 0.6062i</span><br><span class="line">  -0.4494 - 0.6062i</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>x<sup>5</sup> + 2x<sup>4</sup> − 5x<sup>3</sup> + x + 3 = 0</p></li></ul><h2 id="可执行程序">可执行程序</h2><p><mark>使用Linux的Ubuntu系统</mark></p><blockquote><p>创建可执行程序</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/octave -qf</span><br><span class="line"># a sample Octave program</span><br><span class="line">printf(&quot;Hello, world!\n&quot;);</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>该文件第一行必须以<code>#!</code>开头。列出用于解释文件中语句的解释器的绝对路径和名称，还可以为该解释器指定一定的执行选项</p></li><li class="lvl-2"><p><code>-q</code> 选项能够屏蔽程序在普通情况下执行时输出到标准输出的一些介绍性的信息</p></li><li class="lvl-2"><p><code>f</code> 选项能够让程序忽略用户的在文件<code>~/.octaverc</code>中的一些设置</p><ul class="lvl-2"><li class="lvl-4">比如，如果你的Octave程序中调用了一些自定义的函数，而这样的函数在你自定义的path中，那么使用<code>-f</code>选项时，Octave会报错表示无法找到你的那个特定的函数</li></ul></li><li class="lvl-2"><p>Octave程序在系统终端执行的时候，还可以为其添加一些参数。这样的参数通过Octave的内部变量argv存储</p></li><li class="lvl-2"><p>该文件不加文件后缀名</p></li><li class="lvl-2"><p>添加可执行权限</p><ul class="lvl-2"><li class="lvl-4"></li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xuan@xuan-virtual-machine:~/桌面/test$ chmod u+x test</span><br></pre></td></tr></table></figure></li><li class="lvl-2"><p>运行</p><ul class="lvl-2"><li class="lvl-4"></li></ul>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xuan@xuan-virtual-machine:~/桌面/test$ ./test</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><ul class="lvl-2"><li class="lvl-4"><p>可以将test文件加入到系统PATH变量所在的目录中，就可以像调用<code>cd</code>等命令一样调用<code>test</code>命令了</p></li></ul></li></ul><blockquote><p>argv实例</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/octave -qf</span><br><span class="line">printf(&quot;%s\n&quot;, program_name());</span><br><span class="line">arg_list = argv();</span><br><span class="line">for i = 1:nargin</span><br><span class="line">printf(&quot; %s\n&quot;, arg_list&#123;i&#125;);</span><br><span class="line">endfor</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xuan@xuan-virtual-machine:~/桌面/test$ chmod u+x test</span><br><span class="line">xuan@xuan-virtual-machine:~/桌面/test$ ./test</span><br><span class="line">test</span><br><span class="line">xuan@xuan-virtual-machine:~/桌面/test$ ./test arg1 arg2 arg3</span><br><span class="line">test</span><br><span class="line"> arg1</span><br><span class="line"> arg2</span><br><span class="line"> arg3</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://xuan51.github.io/categories/octave/">octave</category>
      
      
      
      <comments>https://xuan51.github.io/2022/09/06/octave%E5%9F%BA%E7%A1%80/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>markdown语法</title>
      <link>https://xuan51.github.io/2022/08/30/markdown%E8%AF%AD%E6%B3%95/</link>
      <guid>https://xuan51.github.io/2022/08/30/markdown%E8%AF%AD%E6%B3%95/</guid>
      <pubDate>Tue, 30 Aug 2022 07:17:59 GMT</pubDate>
      
      <description>&lt;p&gt;介绍简单的markdown语法&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>介绍简单的markdown语法</p><span id="more"></span><h1>markdown语法</h1><h2 id="简介">简介</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://markdown.com.cn/basic-syntax/">官方文档</a></p></li><li class="lvl-2"><p>轻量级标记语言</p></li><li class="lvl-2"><p>排版语法简介</p></li><li class="lvl-2"><p>易读易写的纯文本格式编写文档</p></li><li class="lvl-2"><p>可与HTML混编</p></li><li class="lvl-2"><p>可导出HTML,PDF以及本身的.md格式的文件</p></li><li class="lvl-2"><p>因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等</p></li><li class="lvl-2"><p><a href="https://markdown.com.cn/editor/">Markdown在线编辑器</a></p></li></ul><h2 id="标题语法">标题语法</h2><ul class="lvl-0"><li class="lvl-2"><p>要创建标题，在单词或短语前面添加井号 (<code>#</code>) 。<code>#</code> 的数量代表了标题的级别</p></li><li class="lvl-2"><p>| Markdown语法 | HTML | 预览效果 |<br>| – | – | – |<br>| <code># Heading level 1</code> | <code>&lt;h1&gt;Heading level 1&lt;/h1&gt;</code> | </p><h1>Heading level 1</h1> |<br>| <code>## Heading level 2</code> | <code>&lt;h2&gt;Heading level 2&lt;/h2&gt;</code> | <h2>Heading level 2</h2> |<br>| <code>### Heading level 3</code> | <code>&lt;h3&gt;Heading level 3&lt;/h3&gt;</code> | <h3>Heading level 3</h3> |<br>| <code>#### Heading level 4</code> | <code>&lt;h4&gt;Heading level 4&lt;/h4&gt;</code> | <h4>Heading level 4</h4> |<br>| <code>##### Heading level 5</code> | <code>&lt;h5&gt;Heading level 5&lt;/h5&gt;</code> | <h5>Heading level 5</h5> |<br>| <code>###### Heading level 6</code> | <code>&lt;h6&gt;Heading level 6&lt;/h6&gt;</code> | <h6>Heading level 6</h6> |<p></p></li></ul><h3 id="可选语法">可选语法</h3><ul class="lvl-0"><li class="lvl-2"><p>可以在文本下方添加任意数量的 <code>==</code> 号来标识一级标题，或者 <code>--</code> 号来标识二级标题</p></li><li class="lvl-2"><p>| TH | TH | TH |<br>| – | – | – |<br>| <code>Heading level 1</code> <br> <code>==========</code> | <code>&lt;h1&gt;Heading level 1&lt;/h1&gt;</code> | </p><h1>Heading level 1</h1> |<br>| <code>Heading level 2</code> <br> <code>-----------------</code> | <code>&lt;h2&gt;Heading level 2&lt;/h2&gt;</code> | <h2>Heading level 2</h2> |<p></p></li></ul><h3 id="最佳实践">最佳实践</h3><ul class="lvl-0"><li class="lvl-2"><p>不同的 Markdown 应用程序处理 <code>#</code> 和标题之间的空格方式并不一致。为了兼容考虑，请用一个空格在 <code>#</code> 和标题之间进行分隔</p></li></ul><h2 id="段落语法">段落语法</h2><ul class="lvl-0"><li class="lvl-2"><p>要创建段落，请使用空白行将一行或多行文本进行分隔</p></li><li class="lvl-2"><p>| Markdown语法 | HTML | 预览效果 |<br>| – | – | – |<br>| <code>I really like using Markdown.</code> <br><br> <code>I think I'll use it to format all of my documents from now on.</code> | <code>&lt;p&gt;I really like using Markdown.&lt;/p&gt;</code> <br><br> <code>&lt;p&gt;I think I'll use it to format all of my documents from now on.&lt;/p&gt;</code> | </p><p>I really like using Markdown.</p> <p>I think I’ll use it to format all of my documents from now on.</p> |<p></p></li></ul><h3 id="最佳实践-2">最佳实践</h3><ul class="lvl-0"><li class="lvl-2"><p>不要用空格（spaces）或制表符（ tabs）缩进段落</p></li></ul><h2 id="换行语法">换行语法</h2><ul class="lvl-0"><li class="lvl-2"><p>在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行(<code>&lt;br&gt;</code>)</p></li><li class="lvl-2"><p>| Markdown语法 | HTML | 预览效果 |<br>| – | – | – |<br>| <code>This is the first line.  </code> <br> <code>And this is the second line.</code> | <code>&lt;p&gt;This is the first line. &lt;br&gt;</code> <br> <code>And this is the second line.&lt;/p&gt;</code> | </p><p>This is the first line. <br> And this is the second line.</p> |<p></p></li></ul><h3 id="最佳实践-3">最佳实践</h3><ul class="lvl-0"><li class="lvl-2"><p>几乎每个 Markdown 应用程序都支持两个或多个空格进行换行，称为 <code>结尾空格（trailing whitespace)</code> 的方式，但这是有争议的，因为很难在编辑器中直接看到空格，并且很多人在每个句子后面都会有意或无意地添加两个空格。由于这个原因，你可能要使用除结尾空格以外的其它方式来换行。幸运的是，几乎每个 Markdown 应用程序都支持另一种换行方式：HTML 的 <code>&lt;br&gt;</code> 标签</p></li><li class="lvl-2"><p>为了兼容性，请在行尾添加“结尾空格”或 HTML 的 <code>&lt;br&gt;</code> 标签来实现换行</p></li><li class="lvl-2"><p>还有两种其他方式我并不推荐使用。CommonMark 和其它几种轻量级标记语言支持在行尾添加反斜杠 (<code>\</code>) 的方式实现换行，但是并非所有 Markdown 应用程序都支持此种方式，因此从兼容性的角度来看，不推荐使用。并且至少有两种轻量级标记语言支持无须在行尾添加任何内容，只须键入回车键（<code>return</code>）即可实现换行</p></li></ul><h2 id="强调语法">强调语法</h2><ul class="lvl-0"><li class="lvl-2"><p>通过将文本设置为粗体或斜体来强调其重要性</p></li></ul><h3 id="粗体-Bold">粗体(Bold)</h3><ul class="lvl-0"><li class="lvl-2"><p>要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）</p></li><li class="lvl-2"><p>如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（asterisks）</p></li><li class="lvl-2"><p>| Markdown语法 | HTML | 预览效果 |<br>| – | – | – |<br>| <code>I just love **bold text**.</code> | <code>I just love &lt;strong&gt;bold text&lt;/strong&gt;.</code> | I just love <strong>bold text</strong>. |<br>| <code>I just love __bold text__.</code> | <code>I just love &lt;strong&gt;bold text&lt;/strong&gt;.</code> | I just love <strong>bold text</strong>. |<br>| <code>Love**is**bold</code> | <code>Love&lt;strong&gt;is&lt;/strong&gt;bold</code> | Love<strong>is</strong>bold |</p></li></ul><h3 id="最佳实践-4">最佳实践</h3><ul class="lvl-0"><li class="lvl-2"><p>Markdown 应用程序在如何处理单词或短语中间的下划线上并不一致。为兼容考虑，在单词或短语中间部分加粗的话，请使用星号（asterisks）</p></li></ul><h3 id="斜体">斜体</h3><ul class="lvl-0"><li class="lvl-2"><p>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格</p></li><li class="lvl-2"><p>| Markdown语法 | HTML | 预览效果 |<br>| – | – | – |<br>| <code>Italicized text is the *cat's meow*.</code> | <code>Italicized text is the &lt;em&gt;cat's meow&lt;/em&gt;.</code> | Italicized text is the <em>cat’s meow</em>. |<br>| <code>Italicized text is the _cat's meow_.</code> | <code>Italicized text is the &lt;em&gt;cat's meow&lt;/em&gt;.</code> | Italicized text is the <em>cat’s meow</em>. |<br>| <code>A*cat*meow</code> | <code>A&lt;em&gt;cat&lt;/em&gt;meow</code> | A<em>cat</em>meow |</p></li></ul><h3 id="最佳实践-5">最佳实践</h3><ul class="lvl-0"><li class="lvl-2"><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线</p></li><li class="lvl-2"><p>要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格</p></li></ul><h3 id="粗体-Bold-和斜体-Italic">粗体(Bold)和斜体(Italic)</h3><ul class="lvl-0"><li class="lvl-2"><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线</p></li><li class="lvl-2"><p>要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格</p></li></ul><h3 id="最佳实践-6">最佳实践</h3><ul class="lvl-0"><li class="lvl-2"><p>Markdown 应用程序在处理单词或短语中间添加的下划线上并不一致。为了实现兼容性，请使用星号将单词或短语的中间部分加粗并以斜体显示，以示重要。</p></li></ul><h2 id="引用语法">引用语法</h2><p>要创建块引用，请在段落前添加一个 <code>&gt;</code> 符号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用</span><br></pre></td></tr></table></figure><p>渲染效果:</p><blockquote><p>引用</p></blockquote><h3 id="多个段落的块引用">多个段落的块引用</h3><p>块引用可以包含多个段落。为段落之间的空白行添加一个 <code>&gt;</code> 符号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用</span><br><span class="line">&gt; </span><br><span class="line">&gt; 引用</span><br></pre></td></tr></table></figure><p>渲染效果:</p><blockquote><p>引用</p><p>引用</p></blockquote><h3 id="嵌套块引用">嵌套块引用</h3><p>块引用可以嵌套。在要嵌套的段落前添加一个 <code>&gt;&gt;</code> 符号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用</span><br><span class="line">&gt;&gt; 引用</span><br></pre></td></tr></table></figure><p>渲染效果:</p><blockquote><p>引用</p><blockquote><p>引用</p></blockquote></blockquote><h3 id="带有其他元素的块引用">带有其他元素的块引用</h3><p>块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; ### The quarterly results look great!</span><br><span class="line">&gt; </span><br><span class="line">&gt;- Revenue was off the chart.</span><br><span class="line">&gt;- Profits were highter than ever.</span><br><span class="line">&gt; </span><br><span class="line">&gt; *Everything* is going according to **plan**.</span><br></pre></td></tr></table></figure><p>渲染效果:</p><blockquote><h3 id="The-quarterly-results-look-great">The quarterly results look great!</h3><ul class="lvl-1"><li class="lvl-2">Revenue was off the chart.</li><li class="lvl-2">Profits were highter than ever.</li></ul><p><em>Everything</em> is going according to <strong>plan</strong>.</p></blockquote><h2 id="列表语法">列表语法</h2><p>可以将多个条目组织成有序或无序列表</p><h3 id="有序列表">有序列表</h3><ul class="lvl-0"><li class="lvl-2"><p>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。</p></li><li class="lvl-2"><p>| Markdown语法 | HTML | 预览效果 |<br>| – | – | – |<br>| <code>1. First item</code><br><code>2. Second item</code> | <code>&lt;ol&gt;</code><br><code>&lt;li&gt;First item&lt;/li&gt;</code><br><code>&lt;li&gt;Second item&lt;/li&gt;</code><br><code>&lt;/ol&gt;</code> | <ol><li>First item</li><li>Second item</li></ol> |<br>| <code>1. First item</code><br><code>1. Second item</code> | <code>&lt;ol&gt;</code><br><code>&lt;li&gt;First item&lt;/li&gt;</code><br><code>&lt;li&gt;Second item&lt;/li&gt;</code><br><code>&lt;/ol&gt;</code> | <ol><li>First item</li><li>Second item</li></ol> |<br>| <code>3. First item</code><br><code>1. Second item</code> | <code>&lt;ol&gt;</code><br><code>&lt;li&gt;First item&lt;/li&gt;</code><br><code>&lt;li&gt;Second item&lt;/li&gt;</code><br><code>&lt;/ol&gt;</code> | <ol><li>First item</li><li>Second item</li></ol> |<br>|<code>1. First item</code><br><code>2. Second item</code><br>    <code>1. Third item</code> | <code>&lt;ol&gt;</code><br><code>&lt;li&gt;First item&lt;/li&gt;</code><br><code>&lt;li&gt;Second item&lt;/li&gt;</code><br><code>&lt;ol&gt;</code><br><code>&lt;li&gt;Third item&lt;/li&gt;</code><br><code>&lt;/ol&gt;</code><br><code>&lt;/ol&gt;</code> | <ol><li>First item</li><li>Second item</li><ol><li>Third item</li></ol></ol> |</p></li></ul><h3 id="最佳实践-7">最佳实践</h3><p>CommonMark和其他一些轻量级标记语言允许使用括号(<code>)</code>)作为分隔符(例如，<code>1)</code>)，但并不是所有Markdown应用程序都支持这一点，所以从兼容性的角度来看，它不是一个很好的选择。为了兼容，请只使用句号</p><h3 id="无序列表">无序列表</h3><ul class="lvl-0"><li class="lvl-2"><p>要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。</p></li><li class="lvl-2"><p>| Markdown语法 | HTML | 预览效果 |<br>| – | – | – |<br>| <code>- First item</code><br><code>- Second item</code> | <code>&lt;ul&gt;</code><br><code>&lt;li&gt;First item&lt;/li&gt;</code><br><code>&lt;li&gt;Second item&lt;/li&gt;</code><br><code>&lt;/ul&gt;</code> | <ul><li>First item</li><li>Second item</li></ul> |<br>| <code>+ First item</code><br><code>+ Second item</code> | <code>&lt;ul&gt;</code><br><code>&lt;li&gt;First item&lt;/li&gt;</code><br><code>&lt;li&gt;Second item&lt;/li&gt;</code><br><code>&lt;/ul&gt;</code> | <ul><li>First item</li><li>Second item</li></ul> |<br>| <code>* First item</code><br><code>* Second item</code> | <code>&lt;ul&gt;</code><br><code>&lt;li&gt;First item&lt;/li&gt;</code><br><code>&lt;li&gt;Second item&lt;/li&gt;</code><br><code>&lt;/ul&gt;</code> | <ul><li>First item</li><li>Second item</li></ul> |<br>|<code>- First item</code><br><code>- Second item</code><br>    <code>- Third item</code> | <code>&lt;ul&gt;</code><br><code>&lt;li&gt;First item&lt;/li&gt;</code><br><code>&lt;li&gt;Second item&lt;/li&gt;</code><br><code>&lt;ul&gt;</code><br><code>&lt;li&gt;Third item&lt;/li&gt;</code><br><code>&lt;/ul&gt;</code><br><code>&lt;/ul&gt;</code> | <ul><li>First item</li><li>Second item</li><ul><li>Third item</li></ul></ul> |</p></li></ul><h3 id="最佳实践-8">最佳实践</h3><p>Markdown应用程序不同意如何处理同一列表中的不同分隔符。为了兼容性，不要在同一个列表中混合和匹配分隔符(选择一个并坚持使用它)。</p><h3 id="在列表中嵌套其他元素">在列表中嵌套其他元素</h3><p>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符</p><h3 id="段落">段落</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- This is the first list item.</span><br><span class="line">- Here&#x27;s hte second list item.</span><br><span class="line"></span><br><span class="line">    I need to add another paragraph below the second list item.</span><br><span class="line"></span><br><span class="line">- And here&#x27;s the third list item.</span><br></pre></td></tr></table></figure><p>渲染效果</p><ul class="lvl-0"><li class="lvl-2"><p>This is the first list item.</p></li><li class="lvl-2"><p>Here’s hte second list item.</p><p>I need to add another paragraph below the second list item.</p></li><li class="lvl-2"><p>And here’s the third list item.</p></li></ul><h3 id="引用块">引用块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- This is the first list item.</span><br><span class="line">- Here&#x27;s hte second list item.</span><br><span class="line"></span><br><span class="line">    &gt; A blockquote would look great  below the second list item.</span><br><span class="line"></span><br><span class="line">- And here&#x27;s the third list item.</span><br></pre></td></tr></table></figure><p>渲染效果</p><ul class="lvl-0"><li class="lvl-2"><p>This is the first list item.</p></li><li class="lvl-2"><p>Here’s hte second list item.</p><blockquote><p>A blockquote would look great  below the second list item.</p></blockquote></li><li class="lvl-2"><p>And here’s the third list item.</p></li></ul><h3 id="代码块">代码块</h3><p>代码块通常采用四个空格或一个制表符缩进。当它们被放在列表中时，请将它们缩进八个空格或两个制表符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. Open the file.</span><br><span class="line">2. Find the following code block:</span><br><span class="line"></span><br><span class="line">        &lt;html&gt;</span><br><span class="line">            &lt;head&gt;</span><br><span class="line">                &lt;title&gt;Test&lt;/title&gt;</span><br><span class="line">            &lt;/head&gt;</span><br><span class="line">        &lt;/html&gt;</span><br><span class="line"></span><br><span class="line">3. Update the title.</span><br></pre></td></tr></table></figure><p>渲染效果</p><ol><li class="lvl-3"><p>Open the file.</p></li><li class="lvl-3"><p>Find the following code block:</p><pre><code> &lt;html&gt;     &lt;head&gt;         &lt;title&gt;Test&lt;/title&gt;     &lt;/head&gt; &lt;/html&gt;</code></pre></li><li class="lvl-3"><p>Update the title.</p></li></ol><h3 id="图片">图片</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. Open the file containing the linux mascot.</span><br><span class="line">2. Marvel at its beauty.</span><br><span class="line"></span><br><span class="line">    ![Tux, the Linux mascot](./markdown语法.assets/tux.png)</span><br><span class="line"></span><br><span class="line">3. Close the file.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>渲染效果</p><ol><li class="lvl-3"><p>Open the file containing the linux mascot.</p></li><li class="lvl-3"><p>Marvel at its beauty.</p><p><img src="/2022/08/30/markdown%E8%AF%AD%E6%B3%95/tux.png" alt="Tux, the Linux mascot"></p></li><li class="lvl-3"><p>Close the file.</p></li></ol><h3 id="列表">列表</h3><p>可以在有序列表中嵌套无序列表，反之亦然。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. First item.</span><br><span class="line">2. Second item.</span><br><span class="line">3. Third item.</span><br><span class="line">   - Indented item</span><br><span class="line">   - Indented item</span><br><span class="line">4. Fourth item.</span><br></pre></td></tr></table></figure><p>渲染效果</p><ol><li class="lvl-3"><p>First item.</p></li><li class="lvl-3"><p>Second item.</p></li><li class="lvl-3"><p>Third item.</p><ul class="lvl-2"><li class="lvl-5">Indented item</li><li class="lvl-5">Indented item</li></ul></li><li class="lvl-3"><p>Fourth item.</p></li></ol><h2 id="代码语法">代码语法</h2><ul class="lvl-0"><li class="lvl-2"><p>要将单词或短语表示为代码，请将其包裹在反引号 (`) 中</p></li><li class="lvl-2"><p>| Markdown语法 | HTML | 预览效果 |<br>| – | – | – |<br>| <code>At the command prompt,Type `nano`.</code> | <code>At the command prompt,Type &lt;code&gt;nano&lt;/code&gt;.</code> | At the command prompt,Type <code>nano</code>. |</p></li></ul><h3 id="转义反引号">转义反引号</h3><ul class="lvl-0"><li class="lvl-2"><p>如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(<code>``</code>)中</p></li><li class="lvl-2"><p>| Markdown语法 | HTML | 预览效果 |<br>| – | – | – |<br>| <code>``Use `code` in your Markdown file.``</code> |<code>&lt;code&gt;Use `code` in your Markdown file.&lt;/code&gt;</code> | <code>Use <code>code</code> in your Markdown file.</code> |</p></li></ul><h3 id="代码块-2">代码块</h3><p>要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>渲染效果</p><pre><code>&lt;html&gt;    &lt;head&gt;    &lt;/head&gt;&lt;/html&gt;</code></pre><p><strong>Note:</strong> 要创建不用缩进的代码块，请使用 围栏式代码块（fenced code blocks）.</p><h2 id="分割线语法">分割线语法</h2><p>要创建分隔线，请在单独一行上使用三个或多个星号 (<code>***</code>)、破折号 (<code>---</code>) 或下划线 (<code>___</code>) ，并且不能包含其他内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">___</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>渲染效果</p><hr><hr><hr><p>以上三个分隔线的渲染效果看起来都一样</p><h3 id="最佳实践-9">最佳实践</h3><p><strong>为了兼容性，请在分隔线的前后均添加空白行</strong></p><h2 id="链接语法">链接语法</h2><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。</p><p>超链接Markdown语法代码：<code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></p><p>对应的HTML代码：<code>&lt;a href=&quot;超链接地址&quot; title=&quot;超链接title&quot;&gt;超链接显示名&lt;/a&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个链接[Markdown语法](https://markdown.com.cn).</span><br></pre></td></tr></table></figure><p>渲染效果</p><p>这是一个链接<a href="https://markdown.com.cn">Markdown语法</a>.</p><h3 id="给链接增加Title">给链接增加Title</h3><p>链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以<strong>空格分隔</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个链接[Markdown语法](https://markdown.com.cn &quot;官方文档&quot;).</span><br></pre></td></tr></table></figure><p>渲染效果</p><p>这是一个链接<a href="https://markdown.com.cn" title="官方文档">Markdown语法</a>.</p><h3 id="网址和Email地址">网址和Email地址</h3><p>使用尖括号可以很方便地把URL或者email地址变成可点击的链接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;https://markdown.com.cn&gt;</span><br><span class="line">&lt;fake@example.com&gt;</span><br></pre></td></tr></table></figure><p>渲染效果<br><a href="https://markdown.com.cn">https://markdown.com.cn</a><br><a href="mailto:fake@example.com">fake@example.com</a></p><h3 id="带格式化的链接">带格式化的链接</h3><p>强调 链接, 在链接语法前后增加星号。 要将链接表示为代码，请在方括号中添加反引号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I love supporting **the[EFF](https://eff.org)**.</span><br><span class="line">This is the *[Markdown Guide](https://www.markdownguide.org)*.</span><br><span class="line">See the section on[&#x27;链接语法&#x27;](#链接语法)</span><br></pre></td></tr></table></figure><p>渲染效果<br>I love supporting <strong>the<a href="https://eff.org">EFF</a></strong>.<br>This is the <em><a href="https://www.markdownguide.org">Markdown Guide</a></em>.<br>See the section on<a href="#%E9%93%BE%E6%8E%A5%E8%AF%AD%E6%B3%95">’链接语法’</a></p><h3 id="引用类型">引用类型</h3><p>引用样式链接是一种特殊的链接，它使URL在Markdown中更易于显示和阅读。参考样式链接分为两部分：与文本保持内联的部分以及存储在文件中其他位置的部分，以使文本易于阅读。</p><h4 id="链接的第一部分格式">链接的第一部分格式</h4><p>引用类型的链接的第一部分使用两组括号进行格式设置。第一组方括号包围应显示为链接的文本。第二组括号显示了一个标签，该标签用于指向您存储在文档其他位置的链接。</p><p>尽管不是必需的，可以在第一组和第二组括号之间包含一个空格。第二组括号中的标签不区分大小写，可以包含字母，数字，空格或标点符号。</p><h4 id="连接的第二部分格式">连接的第二部分格式</h4><p>引用类型链接的第二部分使用以下属性设置格式：</p><ol><li class="lvl-3"><p>放在括号中的标签，其后紧跟一个冒号和至少一个空格（例如<code>[label]: </code>）。</p></li><li class="lvl-3"><p>链接的URL，可以选择将其括在尖括号中。</p></li><li class="lvl-3"><p>链接的可选标题，可以将其括在双引号，单引号或括号中。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0. [Markdown][0]</span><br><span class="line">1. [Markdown][1]</span><br><span class="line">2. [Markdown][2]</span><br><span class="line">3. [Markdown][3]</span><br><span class="line">4. [Markdown][4]</span><br><span class="line">5. [Markdown][5]</span><br><span class="line">6. [Markdown][6]</span><br><span class="line"></span><br><span class="line">[0]: https://markdown.com.cn</span><br><span class="line">[1]: https://markdown.com.cn &#x27;markdown</span><br><span class="line">&#x27;</span><br><span class="line">[2]: https://markdown.com.cn &quot;markdown</span><br><span class="line">&quot;</span><br><span class="line">[3]: https://markdown.com.cn (markdown</span><br><span class="line">)</span><br><span class="line">[4]: &lt;https://markdown.com.cn&gt; &#x27;markdown</span><br><span class="line">&#x27;</span><br><span class="line">[5]: &lt;https://markdown.com.cn&gt;  &quot;markdown</span><br><span class="line">&quot;</span><br><span class="line">[6]: &lt;https://markdown.com.cn&gt;  (markdown</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>渲染效果</p><ol start="0"><li class="lvl-3"><p><a href="https://markdown.com.cn">Markdown</a></p></li><li class="lvl-3"><p><a href="https://markdown.com.cn" title="markdown">Markdown</a></p></li><li class="lvl-3"><p><a href="https://markdown.com.cn" title="markdown">Markdown</a></p></li><li class="lvl-3"><p><a href="https://markdown.com.cn" title="markdown">Markdown</a></p></li><li class="lvl-3"><p><a href="https://markdown.com.cn" title="markdown">Markdown</a></p></li><li class="lvl-3"><p><a href="https://markdown.com.cn" title="markdown">Markdown</a></p></li><li class="lvl-3"><p><a href="https://markdown.com.cn" title="markdown">Markdown</a></p></li></ol><h3 id="最佳实践-10">最佳实践</h3><p>不同的 Markdown 应用程序处理URL中间的空格方式不一样。为了兼容性，请尽量使用%20代替空格。</p><h2 id="图片语法">图片语法</h2><p>要添加图像，请使用感叹号 (<code>!</code>), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。</p><p>插入图片Markdown语法代码：<code>![图片alt](图片链接 &quot;图片title&quot;)</code>。</p><p>对应的HTML代码：<code>&lt;img src=&quot;图片链接&quot; alt=&quot;图片alt&quot; title=&quot;图片title&quot;&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Img](./markdown语法.assets/shiprock.png)</span><br></pre></td></tr></table></figure><p>渲染效果</p><p><img src="/2022/08/30/markdown%E8%AF%AD%E6%B3%95/shiprock.png" alt="Img"></p><h3 id="链接图片">链接图片</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[![markdown](./markdown语法.assets/markdown.png &quot;tux&quot;)](https://markdown.com.cn)</span><br></pre></td></tr></table></figure><p>渲染效果</p><p><a href="https://markdown.com.cn"><img src="/2022/08/30/markdown%E8%AF%AD%E6%B3%95/markdown.png" alt="markdown" title="tux"></a></p><h2 id="转义字符语法">转义字符语法</h2><p>要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \ 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\* Without the backslash, this would be a bullet in an unordered list.</span><br></pre></td></tr></table></figure><p>渲染效果</p><p>* Without the backslash, this would be a bullet in an unordered list.</p><h3 id="可做转义的字符">可做转义的字符</h3><p>以下列出的字符都可以通过使用反斜杠字符从而达到转义目的。</p><table><thead><tr><th>Character</th><th>Name</th></tr></thead><tbody><tr><td>\</td><td>backslash</td></tr><tr><td>`</td><td>backtick</td></tr><tr><td>*</td><td>asterisk</td></tr><tr><td>_</td><td>underscore</td></tr><tr><td>{}</td><td>curly braces</td></tr><tr><td>[]</td><td>brackets</td></tr><tr><td>()</td><td>parentheses</td></tr><tr><td>#</td><td>pound sign</td></tr><tr><td>+</td><td>plus sign</td></tr><tr><td>-</td><td>minus sign</td></tr><tr><td>.</td><td>dot</td></tr><tr><td>!</td><td>exclamation mark</td></tr><tr><td>|</td><td>pipe</td></tr></tbody></table><h3 id="特殊字符自动转义">特殊字符自动转义</h3><p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要使用这些符号，你必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p><p>Markdown 允许你直接使用这些符号，它帮你自动转义字符。如果你使用 <code>&amp;</code> 符号的作为 HTML 实体的一部分，那么它不会被转换，而在其它情况下，它则会被转换成 <code>&amp;amp;</code>。</p><p>如果要在文件中插入一个著作权的符号，你可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;copy;</span><br></pre></td></tr></table></figure><p>渲染效果</p><p>©</p><p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 支持 行内 HTML ，如果你使用 <code>&lt;</code> 符号作为 HTML 标签的分隔符，那 Markdown 也不会对它做任何转换</p><p>需要特别注意的是，在 Markdown 的块级元素和内联元素中， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都会被自动转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML。（在 HTML 语法中，你要手动把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体。）</p><h2 id="内嵌HTML标签">内嵌HTML标签</h2><p>对于 Markdown 涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是 HTML 或是 Markdown，只需 HTML 标签添加到 Markdown 文本中即可。</p><h3 id="行级内联标签">行级内联标签</h3><p>HTML 的行级內联标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 不受限制，可以在 Markdown 的段落、列表或是标题里任意使用。依照个人习惯，甚至可以不用 Markdown 格式，而采用 HTML 标签来格式化。例如：如果比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图片语法。当你需要更改元素的属性时（例如为文本指定颜色或更改图像的宽度），使用 HTML 标签更方便些。</p><p>HTML 行级內联标签和区块标签不同，在內联标签的范围内， Markdown 的语法是可以解析的。</p><h3 id="区块标签">区块标签</h3><p>区块元素──比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行，以便于内容区分。而且这些元素的开始与结尾标签，不可以用 tab 或是空白来缩进。Markdown 会自动识别这区块元素，避免在区块标签前后加上没有必要的 <code>&lt;p&gt;</code> 标签。</p><p><mark>请注意</mark>，Markdown 语法在 HTML 区块标签中将不会被进行处理。例如，你无法在 HTML 区块内使用 Markdown 形式的<code>*强调*</code>。</p><h3 id="最佳实践-11">最佳实践</h3><p>出于安全原因，并非所有 Markdown 应用程序都支持在 Markdown 文档中添加 HTML。</p><p>对于 HTML 的块级元素 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code> 和 <code>&lt;p&gt;</code>，请在其前后使用空行（blank lines）与其它内容进行分隔。尽量不要使用制表符（tabs）或空格（spaces）对 HTML 标签做缩进，否则将影响格式。</p><p>在 HTML 块级标签内不能使用 Markdown 语法。例如 <code>&lt;p&gt;italic and **bold**&lt;/p&gt;</code> 将不起作用。</p>]]></content:encoded>
      
      
      
      
      <comments>https://xuan51.github.io/2022/08/30/markdown%E8%AF%AD%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
